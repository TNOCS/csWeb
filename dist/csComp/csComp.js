var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var Widget = (function () {
            function Widget() {
            }
            return Widget;
        })();
        Services.Widget = Widget;
        var WidgetStyle = (function () {
            function WidgetStyle() {
            }
            return WidgetStyle;
        })();
        Services.WidgetStyle = WidgetStyle;
        var BaseWidget = (function () {
            //public static deserialize(input: IWidget): IWidget {
            //    var loader = new InstanceLoader(window);
            //    var w = <IWidget>loader.getInstance(widget.widgetType);
            //    var res = $.extend(new BaseWidget(), input);
            //    return res;
            //}
            function BaseWidget(title, type) {
                this.enabled = true;
                this.opacity = 1;
                this.background = "white";
                this.renderer = function ($compile, $scope) { };
                this.resize = function (status, width, height) { };
                if (title)
                    this.title = title;
                this.properties = {};
                this.dataSets = [];
            }
            BaseWidget.serializeableData = function (w) {
                var r = {
                    id: w.id,
                    directive: w.directive,
                    template: w.template,
                    title: w.title,
                    name: w.name,
                    timeDependent: w.timeDependent,
                    url: w.url,
                    elementId: w.elementId,
                    enabled: w.enabled,
                    customStyle: w.customStyle,
                    style: w.style,
                    left: w.left,
                    right: w.right,
                    top: w.top,
                    bottom: w.bottom,
                    width: w.width,
                    height: w.height,
                    allowFullscreen: w.allowFullscreen,
                    properties: w.properties,
                    hover: w.hover,
                    //dataSets:      {},// w.dataSets,
                    range: w.range,
                    collapse: w.collapse,
                    canCollapse: w.canCollapse,
                    data: BaseWidget.cloneWithout0(w.data)
                };
                return r;
            };
            BaseWidget.cloneWithout0 = function (v) {
                var _this = this;
                if (typeof v !== "object")
                    return v;
                if (v instanceof Array) {
                    var a = [];
                    v.forEach(function (i) {
                        a.push(_this.cloneWithout0(i));
                    });
                    return a;
                }
                else {
                    var c = {};
                    for (var k in v) {
                        if (k[0] !== '_')
                            c[k] = this.cloneWithout0(v[k]);
                    }
                    return c;
                }
                // if (v['0']) {
                //   for (var k in v['0']) {
                //     if (k !== '0') c[k] = this.cloneWithout0(v['0'][k]);
                //   }
                // }
            };
            BaseWidget.prototype.start = function () { };
            BaseWidget.prototype.init = function () {
                //if (!sizeX)
                //this.sizeX = sX;
                //this.sizeY = sY;
                //this.col = c;
                //this.row = r;
                this.background = "red";
                if (!this.id)
                    this.id = "widget" + csComp.Helpers.getGuid().replace('-', '');
                //this.width = (width) ? width : 300;
                //this.height = (height) ? height : 150;
                //this.id = id;
                this.elementId = this.id;
                this.start();
            };
            BaseWidget.prototype.updateDateRange = function (r) {
                this.range = r;
            };
            return BaseWidget;
        })();
        Services.BaseWidget = BaseWidget;
        var Dashboard = (function () {
            function Dashboard() {
                this.showTimeline = true;
                this.showLegend = false;
                this.showRightmenu = false;
                this.showBackgroundImage = false;
                this.draggable = true;
                this.resizable = true;
                this.widgets = [];
            }
            /**
             * Returns an object which contains all the data that must be serialized.
             */
            Dashboard.serializeableData = function (d) {
                return {
                    id: d.id,
                    name: d.name,
                    editMode: d.editMode,
                    showMap: d.showMap,
                    showTimeline: d.showTimeline,
                    showLeftmenu: d.showLeftmenu,
                    showLegend: d.showLegend,
                    showRightmenu: d.showRightmenu,
                    showBackgroundImage: d.showBackgroundImage,
                    background: d.background,
                    backgroundimage: d.backgroundimage,
                    visiblelayers: d.visiblelayers,
                    baselayer: d.baselayer,
                    viewBounds: d.viewBounds,
                    widgets: csComp.Helpers.serialize(d.widgets, BaseWidget.serializeableData),
                    visibleLeftMenuItems: d.visibleLeftMenuItems
                };
            };
            Dashboard.deserialize = function (input, solution) {
                var _this = this;
                var res = $.extend(new Dashboard(), input);
                res.widgets = [];
                if (input.widgets)
                    input.widgets.forEach(function (w) {
                        _this.addNewWidget(w, res, solution);
                    });
                if (input.timeline)
                    res.timeline = $.extend(new Services.DateRange(), input.timeline);
                return res;
            };
            Dashboard.addNewWidget = function (widget, dashboard, solution) {
                //var loader = new InstanceLoader(window);
                //var w = <IWidget>loader.getInstance(widget.widgetType);
                //w.messageBusService = this.$messageBusService;
                //w.layerService = this.$layerService;
                //w.init();
                //var w = BaseWidget();
                if (!widget.id)
                    widget.id = csComp.Helpers.getGuid();
                //alert(widget.id);
                widget.elementId = "widget-" + widget.id;
                widget.parentDashboard = dashboard;
                if (widget.style && widget.style !== "custom") {
                    if (!solution.hasOwnProperty('widgetStyles') || !solution.widgetStyles.hasOwnProperty(widget.style))
                        widget.style = "default";
                    widget.effectiveStyle = solution.widgetStyles[widget.style];
                }
                else {
                    widget.effectiveStyle = widget.customStyle;
                }
                dashboard.widgets.push(widget);
                /*if (this.$rootScope.$root.$$phase != '$apply' && this.$rootScope.$root.$$phase != '$digest') { this.$rootScope.$apply(); }
                setTimeout(() => {
                    //if (w != null) w.renderer(this.$compile, this.$rootScope);
                    this.updateWidget(widget);
    
                }, 50);*/
                //this.editWidget(w);
                return widget;
            };
            return Dashboard;
        })();
        Services.Dashboard = Dashboard;
        var Timeline = (function () {
            function Timeline() {
            }
            return Timeline;
        })();
        Services.Timeline = Timeline;
        var TimedDataSet = (function () {
            function TimedDataSet() {
            }
            return TimedDataSet;
        })();
        Services.TimedDataSet = TimedDataSet;
        var DataSet = (function () {
            function DataSet(id, title) {
                this.id = id;
                this.title = title;
                this.data = [];
            }
            return DataSet;
        })();
        Services.DataSet = DataSet;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var SensorSet = (function () {
            function SensorSet() {
                this.max = 100;
                this.min = 0;
            }
            SensorSet.prototype.activeValueText = function () {
                return csComp.Helpers.convertPropertyInfo(this.propertyType, this.activeValue);
            };
            SensorSet.prototype.addValue = function (date, value) {
                this.timestamps.push(date);
                this.values.push(value);
                this.activeValue = value;
            };
            /**
             * Serialize the project to a JSON string.
             */
            SensorSet.prototype.serialize = function () {
                return JSON.stringify(SensorSet.serializeableData(this), function (key, value) {
                    // Skip serializing certain keys
                    return value;
                }, 2);
            };
            /**
             * Returns an object which contains all the data that must be serialized.
             */
            SensorSet.serializeableData = function (d) {
                return {
                    id: d.id,
                    title: d.title,
                    type: d.type,
                    propertyTypeKey: d.propertyTypeKey
                };
            };
            return SensorSet;
        })();
        Services.SensorSet = SensorSet;
        var DataSource = (function () {
            function DataSource() {
                this.sensors = {};
            }
            DataSource.merge_sensor = function (s1, s2) {
                var obj3 = new SensorSet();
                for (var attrname in s1) {
                    obj3[attrname] = s1[attrname];
                }
                for (var attrname in s2) {
                    obj3[attrname] = s2[attrname];
                }
                return obj3;
            };
            /**
             * Returns an object which contains all the data that must be serialized.
             */
            DataSource.serializeableData = function (d) {
                var res = {
                    id: d.id,
                    url: d.url,
                    type: d.type,
                    title: d.title,
                    sensors: {}
                };
                //for (var ss in d.sensors) res.sensors[ss] = d.sensors[ss].serialize();
                return res;
            };
            /**
             * Load JSON data.
             * @type {DataSource}
             *
             * @param $http {ng.IHttpService}
             * @param ds {DataSource}
             * @param callback {Function}
             */
            DataSource.LoadData = function ($http, ds, callback) {
                var _this = this;
                if (ds.url != null) {
                    $http.get(ds.url)
                        .success(function (temp) {
                        if (temp != null) {
                            ds.id = temp.id;
                            if (!ds.hasOwnProperty('sensors')) {
                                ds.sensors = temp.sensors;
                            }
                            else {
                                for (var s in temp.sensors) {
                                    if (temp.sensors.hasOwnProperty(s)) {
                                        ds.sensors[s] = _this.merge_sensor(ds.sensors[s], temp.sensors[s]);
                                    }
                                }
                            }
                            ds.title = temp.title;
                            callback();
                        }
                    })
                        .error(function () { console.log("Error on Data source -- do something ?"); });
                }
            };
            return DataSource;
        })();
        Services.DataSource = DataSource;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var Log = (function () {
            function Log() {
            }
            return Log;
        })();
        Services.Log = Log;
        /**
         * A feature is a single object that is show on a map (e.g. point, polyline, etc)
         * Features are part of a layer and filtered and styled using group filters and styles
         *
         */
        var Feature = (function () {
            function Feature() {
                this.gui = {};
                this.logs = {};
            }
            Feature.serialize = function (f) {
                var res = {};
                res.id = f.id;
                res.geometry = f.geometry;
                res.properties = f.properties;
                res.logs = f.logs;
                if (f.timestamps)
                    res.timestamps = f.timestamps;
                if (f.sensors)
                    res.sensors = f.sensors;
                return res;
            };
            return Feature;
        })();
        Services.Feature = Feature;
        (function (DrawingModeType) {
            DrawingModeType[DrawingModeType["None"] = 0] = "None";
            DrawingModeType[DrawingModeType["Image"] = 1] = "Image";
            DrawingModeType[DrawingModeType["Point"] = 2] = "Point";
            DrawingModeType[DrawingModeType["Square"] = 3] = "Square";
            DrawingModeType[DrawingModeType["Rectangle"] = 4] = "Rectangle";
            DrawingModeType[DrawingModeType["Line"] = 5] = "Line";
            DrawingModeType[DrawingModeType["Circle"] = 6] = "Circle";
            DrawingModeType[DrawingModeType["Freehand"] = 7] = "Freehand";
            DrawingModeType[DrawingModeType["Polyline"] = 8] = "Polyline";
            DrawingModeType[DrawingModeType["Polygon"] = 9] = "Polygon";
            DrawingModeType[DrawingModeType["MultiPolygon"] = 10] = "MultiPolygon";
        })(Services.DrawingModeType || (Services.DrawingModeType = {}));
        var DrawingModeType = Services.DrawingModeType;
        //export enum propertyTypeType {
        //    Text,
        //    TextArea,
        //    Rating,
        //    Number,
        //    Bbcode,
        //    Boolean,
        //    Bit,
        //    Sensor,
        //    Xml,
        //    Options,
        //    Unknown,
        //    Image,
        //    DateTime,
        //    Mediafolder
        //}
        (function (featureFilterType) {
            /** Turn filtering off */
            featureFilterType[featureFilterType["none"] = 0] = "none";
            /** Default for numbers: histogram */
            featureFilterType[featureFilterType["bar"] = 1] = "bar";
            /** Default for text */
            featureFilterType[featureFilterType["text"] = 2] = "text";
        })(Services.featureFilterType || (Services.featureFilterType = {}));
        var featureFilterType = Services.featureFilterType;
        (function (LayerActivationTypes) {
            LayerActivationTypes[LayerActivationTypes["manual"] = 0] = "manual";
            LayerActivationTypes[LayerActivationTypes["automatic"] = 1] = "automatic";
        })(Services.LayerActivationTypes || (Services.LayerActivationTypes = {}));
        var LayerActivationTypes = Services.LayerActivationTypes;
        var PropertyInfo = (function () {
            function PropertyInfo() {
            }
            return PropertyInfo;
        })();
        Services.PropertyInfo = PropertyInfo;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var Feed = (function (_super) {
            __extends(Feed, _super);
            function Feed() {
                _super.apply(this, arguments);
            }
            return Feed;
        })(Services.Feature);
        Services.Feed = Feed;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        (function (LayerType) {
            LayerType[LayerType["GeoJson"] = 0] = "GeoJson";
            LayerType[LayerType["Kml"] = 1] = "Kml";
        })(Services.LayerType || (Services.LayerType = {}));
        var LayerType = Services.LayerType;
        /** a project group contains a list of layers that can be grouped together.
         * Filters, styles can clustering is always defined on the group level.
         * If a filter is selected (e.g. show only the features within a certain property range)
         * this filter is applied to all layers within this group.
         * If clustering is enabled all features in all layers are grouped together
         */
        var ProjectGroup = (function () {
            function ProjectGroup() {
                /**
                 * gui is used for setting temp. properties for rendering
                 */
                this.gui = {};
            }
            /**
             * Returns an object which contains all the data that must be serialized.
             */
            ProjectGroup.serializeableData = function (projectGroup) {
                return {
                    id: projectGroup.id,
                    title: projectGroup.title,
                    description: projectGroup.description,
                    showTitle: projectGroup.showTitle,
                    clustering: projectGroup.clustering,
                    clusterLevel: projectGroup.clusterLevel,
                    maxClusterRadius: projectGroup.maxClusterRadius,
                    oneLayerActive: projectGroup.oneLayerActive,
                    styleProperty: projectGroup.styleProperty,
                    languages: projectGroup.languages,
                    layers: csComp.Helpers.serialize(projectGroup.layers, Services.ProjectLayer.serializeableData)
                };
            };
            ProjectGroup.deserialize = function (input) {
                var res = $.extend(new ProjectGroup(), input);
                if (res.owsurl) {
                    res.loadLayersFromOWS();
                }
                return res;
            };
            ProjectGroup.prototype.loadLayersFromOWS = function ($injector) {
                var _this = this;
                if ($injector === void 0) { $injector = null; }
                this.layers = []; // add some layers here...
                if ($injector == null) {
                    $injector = angular.injector(["ng"]);
                }
                $injector.invoke(function ($http) {
                    $http.get(_this.owsurl)
                        .success(function (xml) { _this.parseXML(xml); })
                        .error(function (xml, status) {
                        console.log("Unable to load OWSurl: " + _this.owsurl);
                        console.log("          HTTP status: " + status);
                    });
                });
            };
            ProjectGroup.prototype.parseXML = function (xml) {
                var theGroup = this;
                var baseurl = this.owsurl.split("?")[0];
                $(xml).find("Layer").each(function () {
                    // DO NOT use arrow notation (=>) as it will break this !!!
                    var layerName = $(this).children("Name").text();
                    if (layerName != null && layerName != "") {
                        var title = $(this).children("Title").text();
                        // TODO: should be using layerService.initLayer(theGroup, layer);
                        // But I don't know how to 'inject' layerService :(
                        var layer = theGroup.buildLayer(baseurl, title, layerName);
                        theGroup.layers.push(layer);
                    }
                });
            };
            ProjectGroup.prototype.buildLayer = function (baseurl, title, layerName) {
                var extraInfo = {
                    "id": csComp.Helpers.getGuid(),
                    "reference": layerName,
                    "title": title,
                    "enabled": false,
                    "group": this
                };
                // Image layers
                if (this.owsgeojson) {
                    extraInfo["type"] = "geojson";
                    extraInfo["url"] = baseurl + "?service=wfs&request=getFeature" +
                        "&outputFormat=application/json&typeName=" + layerName;
                }
                else {
                    extraInfo["type"] = "wms";
                    extraInfo["wmsLayers"] = layerName;
                    extraInfo["url"] = baseurl;
                }
                var layer = jQuery.extend(new Services.ProjectLayer(), extraInfo);
                return layer;
            };
            return ProjectGroup;
        })();
        Services.ProjectGroup = ProjectGroup;
        /**
         * Filters are used to select a subset of features within a group.
         */
        var GroupFilter = (function () {
            function GroupFilter() {
            }
            return GroupFilter;
        })();
        Services.GroupFilter = GroupFilter;
        /**
         * Styles can determine how features are shown on the map
         */
        var GroupStyle = (function () {
            function GroupStyle($translate) {
                var _this = this;
                this.availableAspects = ['strokeColor', 'fillColor', 'strokeWidth', 'height'];
                this.colorScales = {};
                this.legends = {};
                this.fixedColorRange = false;
                $translate('WHITE_RED').then(function (translation) {
                    _this.colorScales[translation] = ['white', 'red'];
                });
                $translate('GREEN_RED').then(function (translation) {
                    _this.colorScales[translation] = ['green', 'red'];
                });
                $translate('RED_GREEN').then(function (translation) {
                    _this.colorScales[translation] = ['red', 'green'];
                });
                $translate('BLUE_RED').then(function (translation) {
                    _this.colorScales[translation] = ['#F04030', '#3040F0'];
                });
                $translate('RED_BLUE').then(function (translation) {
                    _this.colorScales[translation] = ['#3040F0', '#F04030'];
                });
                $translate('WHITE_BLUE').then(function (translation) {
                    _this.colorScales[translation] = ['white', 'blue'];
                });
                $translate('BLUE_WHITE').then(function (translation) {
                    _this.colorScales[translation] = ['blue', 'white'];
                });
                $translate('WHITE_GREEN').then(function (translation) {
                    _this.colorScales[translation] = ['white', 'green'];
                });
                $translate('GREEN_WHITE').then(function (translation) {
                    _this.colorScales[translation] = ['green', 'white'];
                });
                $translate('WHITE_ORANGE').then(function (translation) {
                    _this.colorScales[translation] = ['white', '#FF5500'];
                });
                $translate('ORANGE_WHITE').then(function (translation) {
                    _this.colorScales[translation] = ['#FF5500', 'white'];
                });
                $translate('RED_WHITE_BLUE').then(function (translation) {
                    _this.colorScales[translation] = ['red', 'white', 'blue'];
                });
            }
            return GroupStyle;
        })();
        Services.GroupStyle = GroupStyle;
        /**
         * the Legend class provides a data structure that is used to map a value to a color
         * (see also the function getColor())
        */
        var Legend = (function () {
            function Legend() {
            }
            return Legend;
        })();
        Services.Legend = Legend;
        var LegendEntry = (function () {
            function LegendEntry() {
            }
            return LegendEntry;
        })();
        Services.LegendEntry = LegendEntry;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        /** Layer information. a layer is described in a project file and is always part of a group */
        var ProjectLayer = (function () {
            function ProjectLayer() {
                /**
                 * gui is used for setting temp. values for rendering
                 */
                this.gui = {};
                /** show notification on new feature*/
                this.showFeatureNotifications = true;
            }
            /**
             * Returns an object which contains all the data that must be serialized.
             */
            ProjectLayer.serializeableData = function (pl) {
                return {
                    id: pl.id,
                    title: pl.title,
                    description: pl.description,
                    type: pl.type,
                    renderType: pl.renderType,
                    heatmapSettings: pl.heatmapSettings,
                    heatmapItems: csComp.Helpers.serialize(pl.heatmapItems, Heatmap.HeatmapItem.serializeableData),
                    url: pl.url,
                    typeUrl: pl.typeUrl,
                    wmsLayers: pl.wmsLayers,
                    opacity: pl.opacity,
                    isSublayer: pl.isSublayer,
                    BBOX: pl.BBOX,
                    refreshBBOX: pl.refreshBBOX,
                    refreshTimeInterval: pl.refreshTimeInterval,
                    quickRefresh: pl.quickRefresh,
                    languages: pl.languages,
                    events: pl.events,
                    dataSourceParameters: pl.dataSourceParameters,
                    defaultFeatureType: pl.defaultFeatureType,
                    defaultLegendProperty: pl.defaultLegendProperty,
                    useProxy: pl.useProxy,
                    isDynamic: pl.isDynamic,
                    useLog: pl.useLog,
                    gui: {},
                    tags: pl.tags,
                };
            };
            return ProjectLayer;
        })();
        Services.ProjectLayer = ProjectLayer;
        var BaseLayer = (function () {
            function BaseLayer() {
            }
            return BaseLayer;
        })();
        Services.BaseLayer = BaseLayer;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        Services.availableZoomLevels = [
            { title: "decades", value: 315360000000 },
            { title: "years", value: 31536000000 },
            { title: "weeks", value: 604800000 },
            { title: "days", value: 86400000 },
            { title: "hours", value: 3600000 },
            { title: "quarters", value: 900000 },
            { title: "minutes", value: 60000 },
            { title: "seconds", value: 1000 },
            { title: "milliseconds", value: 1 }
        ];
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        /**
        * Expert level for determining what options to show to the user.
        */
        (function (Expertise) {
            Expertise[Expertise["Beginner"] = 1] = "Beginner";
            Expertise[Expertise["Intermediate"] = 2] = "Intermediate";
            Expertise[Expertise["Expert"] = 3] = "Expert";
            Expertise[Expertise["Admin"] = 4] = "Admin";
        })(Services.Expertise || (Services.Expertise = {}));
        var Expertise = Services.Expertise;
        var VisualState = (function () {
            function VisualState() {
                this.leftPanelVisible = true;
                this.rightPanelVisible = false;
                this.dashboardVisible = true;
                this.mapVisible = true;
                this.timelineVisible = true;
            }
            return VisualState;
        })();
        Services.VisualState = VisualState;
        //** class for describing time ranges for timeline, including focus time */
        var DateRange = (function () {
            function DateRange() {
                var _this = this;
                this.startDate = function () {
                    if (_this.focus < _this.start) {
                        _this.start = _this.focus - _this.range / 5;
                    }
                    return new Date(_this.start);
                };
                this.focusDate = function () { return new Date(_this.focus); };
                this.endDate = function () {
                    if (_this.focus > _this.end) {
                        _this.end = _this.focus + _this.range / 5;
                    }
                    return new Date(_this.end);
                };
            }
            //constructor() {
            //    if (!this.focus) this.setFocus(new Date());
            //}
            DateRange.deserialize = function (input) {
                var res = $.extend(new DateRange(), input);
                if (typeof res.focus === "undefined" || res.focus === null) {
                    res.focus = Date.now();
                }
                return res;
            };
            /**
            * Set the focus time of the timeline, optionally including start and end time.
            */
            DateRange.prototype.setFocus = function (d, s, e) {
                var _this = this;
                this.focus = d.getTime();
                if (s) {
                    this.start = s.getTime();
                }
                if (e) {
                    this.end = e.getTime();
                }
                var newRange = this.end - this.start;
                if (this.range !== newRange) {
                    this.range = newRange;
                    Services.availableZoomLevels.some(function (tl) {
                        _this.zoomLevel = tl.value;
                        _this.zoomLevelName = tl.title;
                        return (tl.value < (_this.range / 10));
                    });
                }
            };
            return DateRange;
        })();
        Services.DateRange = DateRange;
        /**
         * Represents to the overall solution class. A solution can contain multiple project.
         * This can be usefull when you want to have the same website, but with different content.
         * e.g. you could make it so that you can switch between different regions or different domains of interest.
         */
        var Solution = (function () {
            function Solution() {
                this.widgetStyles = {};
            }
            return Solution;
        })();
        Services.Solution = Solution;
        /** Project within a solution file, refers to a project url*/
        var SolutionProject = (function () {
            function SolutionProject() {
            }
            return SolutionProject;
        })();
        Services.SolutionProject = SolutionProject;
        /** project configuration. */
        var Project = (function () {
            function Project() {
                this.expertMode = Expertise.Expert;
                this.markers = {};
            }
            /**
             * Serialize the project to a JSON string.
             */
            Project.prototype.serialize = function () {
                return JSON.stringify(Project.serializeableData(this), function (key, value) {
                    // Skip serializing certain keys
                    switch (key) {
                        case "timestamp":
                        //case "values":
                        case "mcas":
                        case "$$hashKey":
                        case "div":
                            return undefined;
                        default:
                            return value;
                    }
                }, 2);
            };
            Project.serializeFeatureType = function (ft) {
                return {
                    name: ft.name,
                    style: ft.style,
                    propertyTypeKeys: ft.propertyTypeKeys,
                    showAllProperties: ft.showAllProperties
                };
            };
            /**
             * Returns an object which contains all the data that must be serialized.
             */
            Project.serializeableData = function (project) {
                return {
                    id: project.id,
                    title: project.title,
                    description: project.description,
                    logo: project.logo,
                    otpServer: project.otpServer,
                    url: project.url,
                    connected: project.connected,
                    startPosition: project.startposition,
                    timeLine: project.timeLine,
                    opacity: project.opacity,
                    mcas: project.mcas,
                    datasources: csComp.Helpers.serialize(project.datasources, Services.DataSource.serializeableData),
                    dashboards: csComp.Helpers.serialize(project.dashboards, Services.Dashboard.serializeableData),
                    viewBounds: project.viewBounds,
                    collapseAllLayers: project.collapseAllLayers,
                    userPrivileges: project.userPrivileges,
                    languages: project.languages,
                    expertMode: project.expertMode,
                    baselayers: project.baselayers,
                    featureTypes: project.featureTypes,
                    propertyTypeData: project.propertyTypeData,
                    groups: csComp.Helpers.serialize(project.groups, Services.ProjectGroup.serializeableData),
                    layerDirectory: project.layerDirectory
                };
            };
            Project.prototype.deserialize = function (input) {
                var res = jQuery.extend(new Project(), input);
                res.solution = input.solution;
                if (!input.opacity)
                    input.opacity = 100;
                if (input.timeLine) {
                    res.timeLine = DateRange.deserialize(input.timeLine);
                } // <DateRange>jQuery.extend(new DateRange(), input.timeLine);
                if (input.dashboards) {
                    res.dashboards = [];
                    input.dashboards.forEach(function (d) {
                        res.dashboards.push(Services.Dashboard.deserialize(d, input.solution));
                    });
                }
                res.mcas = [];
                for (var index in input.mcas) {
                    var mca = new Mca.Models.Mca();
                    res.mcas.push(mca.deserialize(input.mcas[index]));
                }
                if (!res.propertyTypeData) {
                    res.propertyTypeData = {};
                }
                if (!res.mcas) {
                    res.mcas = [];
                }
                if (input.groups) {
                    res.groups = [];
                    input.groups.forEach(function (group) {
                        res.groups.push(Services.ProjectGroup.deserialize(group));
                    });
                }
                if (res.id == null) {
                    res.id = res.title;
                }
                return res;
            };
            return Project;
        })();
        Services.Project = Project;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        /** Class containing references to feature & property types */
        var TypeResource = (function () {
            function TypeResource() {
            }
            /**
             * Serialize the project to a JSON string.
             */
            TypeResource.serialize = function (resource) {
                var data = {
                    featureTypes: {},
                    propertyTypeData: {}
                };
                for (var rt in resource.featureTypes)
                    data.featureTypes[rt] = Services.Project.serializeFeatureType(resource.featureTypes[rt]);
                for (var pt in resource.propertyTypeData)
                    data.propertyTypeData[pt] = resource.propertyTypeData[pt];
                return JSON.stringify(data);
            };
            return TypeResource;
        })();
        Services.TypeResource = TypeResource;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

var ColorExt;
(function (ColorExt) {
    /** Color utility class */
    var Utils = (function () {
        function Utils() {
        }
        /**
         * HSV to RGB color conversion.
         *
         * HSV:
         * 		Hue (the actual color between 0 and 360 degrees),
         *   	Saturation between 0 (grey) and 100 (full color),
         *   	Value of Brightness between 0 (black) and 100 white.
         */
        Utils.hsv2rgb = function (h, s, v) {
            // adapted from http://schinckel.net/2012/01/10/hsv-to-rgb-in-javascript/
            var rgb, i, data = [];
            if (s === 0) {
                rgb = [v, v, v];
            }
            else {
                h = h / 60;
                i = Math.floor(h);
                data = [v * (1 - s), v * (1 - s * (h - i)), v * (1 - s * (1 - (h - i)))];
                switch (i) {
                    case 0:
                        rgb = [v, data[2], data[0]];
                        break;
                    case 1:
                        rgb = [data[1], v, data[0]];
                        break;
                    case 2:
                        rgb = [data[0], v, data[2]];
                        break;
                    case 3:
                        rgb = [data[0], data[1], v];
                        break;
                    case 4:
                        rgb = [data[2], data[0], v];
                        break;
                    default:
                        rgb = [v, data[0], data[1]];
                        break;
                }
            }
            return '#' + rgb.map(function (x) {
                return ("0" + Math.round(x * 255).toString(16)).slice(-2);
            }).join('');
        };
        Utils.toColor = function (val, min, max, primaryColorHue, secondaryColorHue) {
            var h = primaryColorHue + Math.floor(val / (max - min) * (secondaryColorHue - primaryColorHue));
            return Utils.hsv2rgb(h, 1, 1);
        };
        /**
         * Calculate the hue value from a hexadecimal RGB string. Return a value between 0 and 360 degrees
         * equation from: en.wikipedia.org/wiki/Hue#Computing_hue_from_RGB
         */
        Utils.rgbToHue = function (rgb) {
            if (!rgb)
                return;
            if (rgb[0] === '#')
                rgb = rgb.substr(1);
            if (rgb.length !== 6) {
                console.log("Wrong rgb format: " + rgb);
                return;
            }
            var r = parseInt(rgb.substring(0, 2), 16) / 255;
            var g = parseInt(rgb.substring(2, 4), 16) / 255;
            var b = parseInt(rgb.substring(4, 6), 16) / 255;
            var h = Math.atan2(Math.sqrt(3) * (g - b), 2 * (r - g - b));
            while (h < 0) {
                h += (2 * Math.PI);
            }
            ;
            while (h >= (2 * Math.PI)) {
                h -= (2 * Math.PI);
            }
            ;
            h = (h * 180 / Math.PI);
            return h;
        };
        /**
         * Convert an R, G and B combination to hexadecimal string (with preceding #)
         * @param  number[] rgb array
         * @return string  hex string
         */
        Utils.rgbToHex = function (rgb) {
            return '#' + rgb.map(function (x) {
                return ("0" + x.toString(16)).slice(-2);
            }).join('');
        };
        Utils.colorNameToHex = function (color) {
            var colors = { "aliceblue": "#f0f8ff", "antiquewhite": "#faebd7", "aqua": "#00ffff", "aquamarine": "#7fffd4", "azure": "#f0ffff", "beige": "#f5f5dc", "bisque": "#ffe4c4", "black": "#000000", "blanchedalmond": "#ffebcd", "blue": "#0000ff", "blueviolet": "#8a2be2", "brown": "#a52a2a", "burlywood": "#deb887", "cadetblue": "#5f9ea0", "chartreuse": "#7fff00", "chocolate": "#d2691e", "coral": "#ff7f50", "cornflowerblue": "#6495ed", "cornsilk": "#fff8dc", "crimson": "#dc143c", "cyan": "#00ffff", "darkblue": "#00008b", "darkcyan": "#008b8b", "darkgoldenrod": "#b8860b", "darkgray": "#a9a9a9", "darkgreen": "#006400", "darkkhaki": "#bdb76b", "darkmagenta": "#8b008b", "darkolivegreen": "#556b2f", "darkorange": "#ff8c00", "darkorchid": "#9932cc", "darkred": "#8b0000", "darksalmon": "#e9967a", "darkseagreen": "#8fbc8f", "darkslateblue": "#483d8b", "darkslategray": "#2f4f4f", "darkturquoise": "#00ced1", "darkviolet": "#9400d3", "deeppink": "#ff1493", "deepskyblue": "#00bfff", "dimgray": "#696969", "dodgerblue": "#1e90ff", "firebrick": "#b22222", "floralwhite": "#fffaf0", "forestgreen": "#228b22", "fuchsia": "#ff00ff", "gainsboro": "#dcdcdc", "ghostwhite": "#f8f8ff", "gold": "#ffd700", "goldenrod": "#daa520", "gray": "#808080", "green": "#008000", "greenyellow": "#adff2f", "honeydew": "#f0fff0", "hotpink": "#ff69b4", "indianred": "#cd5c5c", "indigo": "#4b0082", "ivory": "#fffff0", "khaki": "#f0e68c", "lavender": "#e6e6fa", "lavenderblush": "#fff0f5", "lawngreen": "#7cfc00", "lemonchiffon": "#fffacd", "lightblue": "#add8e6", "lightcoral": "#f08080", "lightcyan": "#e0ffff", "lightgoldenrodyellow": "#fafad2", "lightgrey": "#d3d3d3", "lightgreen": "#90ee90", "lightpink": "#ffb6c1", "lightsalmon": "#ffa07a", "lightseagreen": "#20b2aa", "lightskyblue": "#87cefa", "lightslategray": "#778899", "lightsteelblue": "#b0c4de", "lightyellow": "#ffffe0", "lime": "#00ff00", "limegreen": "#32cd32", "linen": "#faf0e6", "magenta": "#ff00ff", "maroon": "#800000", "mediumaquamarine": "#66cdaa", "mediumblue": "#0000cd", "mediumorchid": "#ba55d3", "mediumpurple": "#9370d8", "mediumseagreen": "#3cb371", "mediumslateblue": "#7b68ee", "mediumspringgreen": "#00fa9a", "mediumturquoise": "#48d1cc", "mediumvioletred": "#c71585", "midnightblue": "#191970", "mintcream": "#f5fffa", "mistyrose": "#ffe4e1", "moccasin": "#ffe4b5", "navajowhite": "#ffdead", "navy": "#000080", "oldlace": "#fdf5e6", "olive": "#808000", "olivedrab": "#6b8e23", "orange": "#ffa500", "orangered": "#ff4500", "orchid": "#da70d6", "palegoldenrod": "#eee8aa", "palegreen": "#98fb98", "paleturquoise": "#afeeee", "palevioletred": "#d87093", "papayawhip": "#ffefd5", "peachpuff": "#ffdab9", "peru": "#cd853f", "pink": "#ffc0cb", "plum": "#dda0dd", "powderblue": "#b0e0e6", "purple": "#800080", "red": "#ff0000", "rosybrown": "#bc8f8f", "royalblue": "#4169e1", "saddlebrown": "#8b4513", "salmon": "#fa8072", "sandybrown": "#f4a460", "seagreen": "#2e8b57", "seashell": "#fff5ee", "sienna": "#a0522d", "silver": "#c0c0c0", "skyblue": "#87ceeb", "slateblue": "#6a5acd", "slategray": "#708090", "snow": "#fffafa", "springgreen": "#00ff7f", "steelblue": "#4682b4", "tan": "#d2b48c", "teal": "#008080", "thistle": "#d8bfd8", "tomato": "#ff6347", "turquoise": "#40e0d0", "violet": "#ee82ee", "wheat": "#f5deb3", "white": "#ffffff", "whitesmoke": "#f5f5f5", "yellow": "#ffff00", "yellowgreen": "#9acd32" };
            if (typeof colors[color.toLowerCase()] != 'undefined' && colors.hasOwnProperty(color.toLowerCase())) {
                return colors[color.toLowerCase()];
            }
            else {
                return "#000000";
            }
        };
        return Utils;
    })();
    ColorExt.Utils = Utils;
})(ColorExt || (ColorExt = {}));

var csComp;
(function (csComp) {
    var Helpers;
    (function (Helpers) {
        /**
         * Translated Jason Davies' JavaScript version to TypeScript in 2015.
         * Erik Vullings
         *
         * Copyright (c) 2010, Jason Davies.
         *
         * All rights reserved.  This code is based on Bradley White's Java version,
         * which is in turn based on Nicholas Yue's C++ version, which in turn is based
         * on Paul D. Bourke's original Fortran version.  See below for the respective
         * copyright notices.
         *
         * See http://paulbourke.net/papers/conrec for the original
         * paper by Paul D. Bourke.
         *
         * The vector conversion code is based on http://apptree.net/conrec.htm by
         * Graham Cox.
         *
         * Redistribution and use in source and binary forms, with or without
         * modification, are permitted provided that the following conditions are met:
         *     * Redistributions of source code must retain the above copyright
         *       notice, this list of conditions and the following disclaimer.
         *     * Redistributions in binary form must reproduce the above copyright
         *       notice, this list of conditions and the following disclaimer in the
         *       documentation and/or other materials provided with the distribution.
         *     * Neither the name of the <organization> nor the
         *       names of its contributors may be used to endorse or promote products
         *       derived from this software without specific prior written permission.
         *
         * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
         * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
         * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
         * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
         * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
         * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
         * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
         * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
         * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
         * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
         */
        /*
         * Copyright (c) 1996-1997 Nicholas Yue
         *
         * This software is copyrighted by Nicholas Yue. This code is based on Paul D.
         * Bourke's CONREC.F routine.
         *
         * The authors hereby grant permission to use, copy, and distribute this
         * software and its documentation for any purpose, provided that existing
         * copyright notices are retained in all copies and that this notice is
         * included verbatim in any distributions. Additionally, the authors grant
         * permission to modify this software and its documentation for any purpose,
         * provided that such modifications are not distributed without the explicit
         * consent of the authors and that existing copyright notices are retained in
         * all copies. Some of the algorithms implemented by this software are
         * patented, observe all applicable patent law.
         *
         * IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
         * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
         * OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES THEREOF,
         * EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
         *
         * THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
         * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
         * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE IS
         * PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE NO
         * OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
         * MODIFICATIONS.
         */
        var EPSILON = 1e-10;
        var ContourBuilder = (function () {
            function ContourBuilder(level) {
                this.level = level;
                this.count = 0;
                this.s = null;
            }
            ContourBuilder.prototype.addSegment = function (a, b) {
                var ss = this.s;
                var ma = null, mb = null;
                var prependA = false, prependB = false;
                while (ss) {
                    if (ma === null) {
                        // no match for a yet
                        if (this.pointsEqual(a, ss.head.p)) {
                            ma = ss;
                            prependA = true;
                        }
                        else if (this.pointsEqual(a, ss.tail.p)) {
                            ma = ss;
                        }
                    }
                    if (mb === null) {
                        // no match for b yet
                        if (this.pointsEqual(b, ss.head.p)) {
                            mb = ss;
                            prependB = true;
                        }
                        else if (this.pointsEqual(b, ss.tail.p)) {
                            mb = ss;
                        }
                    }
                    // if we matched both no need to continue searching
                    if (mb != null && ma != null) {
                        break;
                    }
                    else {
                        ss = ss.next;
                    }
                }
                // c is the case selector based on which of ma and/or mb are set
                var c = ((ma != null) ? 1 : 0) | ((mb != null) ? 2 : 0);
                switch (c) {
                    case 0:
                        var aa = { p: a, prev: null };
                        var bb = { p: b, next: null };
                        aa.next = bb;
                        bb.prev = aa;
                        // create sequence element and push onto head of main list. The order
                        // of items in this list is unimportant
                        ma = { head: aa, tail: bb, next: this.s, prev: null, closed: false };
                        if (this.s) {
                            this.s.prev = ma;
                        }
                        this.s = ma;
                        ++this.count; // not essential - tracks number of unmerged sequences
                        break;
                    case 1:
                        var pp = { p: b };
                        if (prependA) {
                            pp.next = ma.head;
                            pp.prev = null;
                            ma.head.prev = pp;
                            ma.head = pp;
                        }
                        else {
                            pp.next = null;
                            pp.prev = ma.tail;
                            ma.tail.next = pp;
                            ma.tail = pp;
                        }
                        break;
                    case 2:
                        var pp = { p: a };
                        if (prependB) {
                            pp.next = mb.head;
                            pp.prev = null;
                            mb.head.prev = pp;
                            mb.head = pp;
                        }
                        else {
                            pp.next = null;
                            pp.prev = mb.tail;
                            mb.tail.next = pp;
                            mb.tail = pp;
                        }
                        break;
                    case 3:
                        // if the sequences are the same, do nothing, as we are simply closing this path (could set a flag)
                        if (ma === mb) {
                            var pp = { p: ma.tail.p, next: ma.head, prev: null };
                            ma.head.prev = pp;
                            ma.head = pp;
                            ma.closed = true;
                            break;
                        }
                        // there are 4 ways the sequence pair can be joined. The current setting of prependA and
                        // prependB will tell us which type of join is needed. For head/head and tail/tail joins
                        // one sequence needs to be reversed
                        switch ((prependA ? 1 : 0) | (prependB ? 2 : 0)) {
                            case 0:
                                // reverse ma and append to mb
                                this.reverseList(ma);
                            // fall through to head/tail case
                            case 1:
                                // ma is appended to mb and ma discarded
                                mb.tail.next = ma.head;
                                ma.head.prev = mb.tail;
                                mb.tail = ma.tail;
                                //discard ma sequence record
                                this.remove_seq(ma);
                                break;
                            case 3:
                                // reverse ma and append mb to it
                                this.reverseList(ma);
                            // fall through to tail/head case
                            case 2:
                                // mb is appended to ma and mb is discarded
                                ma.tail.next = mb.head;
                                mb.head.prev = ma.tail;
                                ma.tail = mb.tail;
                                //discard mb sequence record
                                this.remove_seq(mb);
                                break;
                        }
                }
            };
            ContourBuilder.prototype.remove_seq = function (list) {
                // if list is the first item, static ptr s is updated
                if (list.prev) {
                    list.prev.next = list.next;
                }
                else {
                    this.s = list.next;
                }
                if (list.next) {
                    list.next.prev = list.prev;
                }
                --this.count;
            };
            /**
             * Are two points equal.
             * @param  {IPoint} a Point 1
             * @param  {IPoint} b Point 2
             * @return {boolean}  [True if equal, false otherwise]
             */
            ContourBuilder.prototype.pointsEqual = function (a, b) {
                var dx = a.x - b.x, dy = a.y - b.y;
                return dx * dx + dy * dy < EPSILON;
            };
            ContourBuilder.prototype.reverseList = function (list) {
                var pp = list.head;
                while (pp) {
                    // swap prev/next pointers
                    var temp = pp.next;
                    pp.next = pp.prev;
                    pp.prev = temp;
                    // continue through the list
                    pp = temp;
                }
                // swap head/tail pointers
                var temp = list.head;
                list.head = list.tail;
                list.tail = temp;
            };
            return ContourBuilder;
        })();
        /**
          * Implements CONREC.
          *
          * @param {function} drawContour function for drawing contour.  Defaults to a
          *                               custom "contour builder", which populates the
          *                               contourList property.
          */
        var Conrec = (function () {
            /**
             * Create a new Conrec class, optionally specifying the function to use for drawing the contour line.
             * @param  {number} drawContour [description]
             * @return {[type]}             [description]
             */
            function Conrec(drawContour) {
                this.h = new Array(5);
                this.sh = new Array(5);
                this.xh = new Array(5);
                this.yh = new Array(5);
                if (drawContour)
                    this.drawContour = drawContour;
            }
            /**
             * contour is a contouring subroutine for rectangularily spaced data
             *
             * It emits calls to a line drawing subroutine supplied by the user which
             * draws a contour map corresponding to real*4data on a randomly spaced
             * rectangular grid. The coordinates emitted are in the same units given in
             * the x() and y() arrays.
             *
             * Any number of contour levels may be specified but they must be in order of
             * increasing value.
             *
             *
             * @param {number[][]} d - matrix of data to contour
             * @param {number} ilb,iub,jlb,jub - index lower and upper bounds of data matrix,
             *                                 	 i in rows/latitude direction, j in columns/longitude direction
             *
             *             The following two, one dimensional arrays (x and y) contain
             *             the horizontal and vertical coordinates of each sample points.
             * @param {number[]} x  - data matrix column coordinates, e.g. latitude coordinates
             * @param {number[]} y  - data matrix row coordinates, e.g. longitude coordinates
             * @param {number} nc   - number of contour levels
             * @param {number[]} z  - contour levels in increasing order.
             * @param {number[]} noDataValue  - when one of the corners of the grid cell contains a noDataValue, that cell is skipped.
             */
            Conrec.prototype.contour = function (d, ilb, iub, jlb, jub, x, y, nc, z, noDataValue) {
                var h = this.h, sh = this.sh, xh = this.xh, yh = this.yh;
                var drawContour = this.drawContour;
                this.contours = {};
                /** private */
                var xsect = function (p1, p2) {
                    return (h[p2] * xh[p1] - h[p1] * xh[p2]) / (h[p2] - h[p1]);
                };
                var ysect = function (p1, p2) {
                    return (h[p2] * yh[p1] - h[p1] * yh[p2]) / (h[p2] - h[p1]);
                };
                var m1, m2, m3;
                var case_value;
                var dmin, dmax;
                var x1 = 0.0;
                var x2 = 0.0;
                var y1 = 0.0;
                var y2 = 0.0;
                // The indexing of im and jm should be noted as it has to start from zero
                // unlike the fortran counter part
                var im = [0, 1, 1, 0];
                var jm = [0, 0, 1, 1];
                // Note that castab is arranged differently from the FORTRAN code because
                // Fortran and C/C++ arrays are transposed of each other, in this case
                // it is more tricky as castab is in 3 dimensions
                var castab = [
                    [
                        [0, 0, 8], [0, 2, 5], [7, 6, 9]
                    ],
                    [
                        [0, 3, 4], [1, 3, 1], [4, 3, 0]
                    ],
                    [
                        [9, 6, 7], [5, 2, 0], [8, 0, 0]
                    ]
                ];
                for (var j = (jub - 1); j >= jlb; j--) {
                    for (var i = ilb; i < iub; i++) {
                        if (d[i][j] === noDataValue || d[i + 1][j] === noDataValue || d[i][j + 1] === noDataValue || d[i + 1][j + 1] === noDataValue)
                            return;
                        var temp1, temp2;
                        temp1 = Math.min(d[i][j], d[i][j + 1]);
                        temp2 = Math.min(d[i + 1][j], d[i + 1][j + 1]);
                        dmin = Math.min(temp1, temp2);
                        temp1 = Math.max(d[i][j], d[i][j + 1]);
                        temp2 = Math.max(d[i + 1][j], d[i + 1][j + 1]);
                        dmax = Math.max(temp1, temp2);
                        if (dmax < z[0] && dmin > z[nc - 1])
                            continue;
                        for (var k = 0; k < nc; k++) {
                            if (z[k] >= dmin && z[k] <= dmax) {
                                for (var m = 4; m >= 0; m--) {
                                    if (m > 0) {
                                        // The indexing of im and jm should be noted as it has to
                                        // start from zero
                                        h[m] = d[i + im[m - 1]][j + jm[m - 1]] - z[k];
                                        xh[m] = x[i + im[m - 1]];
                                        yh[m] = y[j + jm[m - 1]];
                                    }
                                    else {
                                        h[0] = 0.25 * (h[1] + h[2] + h[3] + h[4]);
                                        xh[0] = 0.5 * (x[i] + x[i + 1]);
                                        yh[0] = 0.5 * (y[j] + y[j + 1]);
                                    }
                                    if (h[m] > EPSILON) {
                                        sh[m] = 1;
                                    }
                                    else if (h[m] < -EPSILON) {
                                        sh[m] = -1;
                                    }
                                    else
                                        sh[m] = 0;
                                }
                                //
                                // Note: at this stage the relative heights of the corners and the
                                // centre are in the h array, and the corresponding coordinates are
                                // in the xh and yh arrays. The centre of the box is indexed by 0
                                // and the 4 corners by 1 to 4 as shown below.
                                // Each triangle is then indexed by the parameter m, and the 3
                                // vertices of each triangle are indexed by parameters m1,m2,and
                                // m3.
                                // It is assumed that the centre of the box is always vertex 2
                                // though this isimportant only when all 3 vertices lie exactly on
                                // the same contour level, in which case only the side of the box
                                // is drawn.
                                //
                                //
                                //      vertex 4 +-------------------+ vertex 3
                                //               | \               / |
                                //               |   \    m-3    /   |
                                //               |     \       /     |
                                //               |       \   /       |
                                //               |  m=2    X   m=2   |       the centre is vertex 0
                                //               |       /   \       |
                                //               |     /       \     |
                                //               |   /    m=1    \   |
                                //               | /               \ |
                                //      vertex 1 +-------------------+ vertex 2
                                //
                                //
                                //
                                //               Scan each triangle in the box
                                //
                                for (m = 1; m <= 4; m++) {
                                    m1 = m;
                                    m2 = 0;
                                    if (m != 4) {
                                        m3 = m + 1;
                                    }
                                    else {
                                        m3 = 1;
                                    }
                                    case_value = castab[sh[m1] + 1][sh[m2] + 1][sh[m3] + 1];
                                    if (case_value != 0) {
                                        switch (case_value) {
                                            case 1:
                                                x1 = xh[m1];
                                                y1 = yh[m1];
                                                x2 = xh[m2];
                                                y2 = yh[m2];
                                                break;
                                            case 2:
                                                x1 = xh[m2];
                                                y1 = yh[m2];
                                                x2 = xh[m3];
                                                y2 = yh[m3];
                                                break;
                                            case 3:
                                                x1 = xh[m3];
                                                y1 = yh[m3];
                                                x2 = xh[m1];
                                                y2 = yh[m1];
                                                break;
                                            case 4:
                                                x1 = xh[m1];
                                                y1 = yh[m1];
                                                x2 = xsect(m2, m3);
                                                y2 = ysect(m2, m3);
                                                break;
                                            case 5:
                                                x1 = xh[m2];
                                                y1 = yh[m2];
                                                x2 = xsect(m3, m1);
                                                y2 = ysect(m3, m1);
                                                break;
                                            case 6:
                                                x1 = xh[m3];
                                                y1 = yh[m3];
                                                x2 = xsect(m1, m2);
                                                y2 = ysect(m1, m2);
                                                break;
                                            case 7:
                                                x1 = xsect(m1, m2);
                                                y1 = ysect(m1, m2);
                                                x2 = xsect(m2, m3);
                                                y2 = ysect(m2, m3);
                                                break;
                                            case 8:
                                                x1 = xsect(m2, m3);
                                                y1 = ysect(m2, m3);
                                                x2 = xsect(m3, m1);
                                                y2 = ysect(m3, m1);
                                                break;
                                            case 9:
                                                x1 = xsect(m3, m1);
                                                y1 = ysect(m3, m1);
                                                x2 = xsect(m1, m2);
                                                y2 = ysect(m1, m2);
                                                break;
                                            default:
                                                break;
                                        }
                                        // Put your processing code here and comment out the printf
                                        //printf("%f %f %f %f %f\n",x1,y1,x2,y2,z[k]);
                                        this.drawContour(x1, y1, x2, y2, z[k], k);
                                    } // if case_value
                                } // for m
                            } // for z
                        } // for k
                    } // for i
                } // for j
            };
            /**
             * drawContour - interface for implementing the user supplied method to
             * render the countours.
             *
             * Draws a line between the start and end coordinates.
             *
             * @param startX    - start coordinate for X
             * @param startY    - start coordinate for Y
             * @param endX      - end coordinate for X
             * @param endY      - end coordinate for Y
             * @param contourLevel - Contour level for line.
             */
            Conrec.prototype.drawContour = function (startX, startY, endX, endY, contourLevel, k) {
                var cb = this.contours[k];
                if (!cb) {
                    cb = this.contours[k] = new ContourBuilder(contourLevel);
                }
                cb.addSegment({ x: startX, y: startY }, { x: endX, y: endY });
            };
            Object.defineProperty(Conrec.prototype, "contourList", {
                get: function () {
                    var l = [];
                    var a = this.contours;
                    for (var k in a) {
                        var s = a[k].s;
                        var level = a[k].level;
                        while (s) {
                            var h = s.head;
                            var l2 = [];
                            l2.level = level;
                            l2.k = k;
                            while (h && h.p) {
                                l2.push(h.p);
                                h = h.next;
                            }
                            l.push(l2);
                            s = s.next;
                        }
                    }
                    l.sort(function (a, b) { return a.k - b.k; });
                    return l;
                },
                enumerable: true,
                configurable: true
            });
            return Conrec;
        })();
        Helpers.Conrec = Conrec;
    })(Helpers = csComp.Helpers || (csComp.Helpers = {}));
})(csComp || (csComp = {}));

Date.prototype.getJulian = function () {
    /* Calculate the present UTC Julian Date. Function is valid after
     * the beginning of the UNIX epoch 1970-01-01 and ignores leap
     * seconds. */
    return (this / 86400000) + 2440587.5;
};
Date.prototype.getGMST = function () {
    /* Calculate Greenwich Mean Sidereal Time according to
       http://aa.usno.navy.mil/faq/docs/GAST.php */
    var julianDay = this.getJulian();
    var d = julianDay - 2451545.0;
    // Low precision equation is good enough for our purposes.
    return (18.697374558 + 24.06570982441908 * d) % 24;
};
Date.prototype.yyyymmdd = function () {
    var yyyy = this.getFullYear().toString();
    var mm = (this.getMonth() + 1).toString(); // getMonth() is zero-based
    var dd = this.getDate().toString();
    return yyyy + (mm[1] ? mm : "0" + mm[0]) + (dd[1] ? dd : "0" + dd[0]); // padding
};

var csComp;
(function (csComp) {
    var Helpers;
    (function (Helpers) {
        var Dictionary = (function () {
            function Dictionary() {
                this.theKeys = [];
                this.theValues = [];
            }
            Dictionary.prototype.initialize = function (init) {
                for (var x = 0; x < init.length; x++) {
                    this[init[x].key] = init[x].value;
                    this.theKeys.push(init[x].key);
                    this.theValues.push(init[x].value);
                }
            };
            Dictionary.prototype.add = function (key, value) {
                this[key] = value;
                this.theKeys.push(key);
                this.theValues.push(value);
            };
            Dictionary.prototype.remove = function (key) {
                var index = this.theKeys.indexOf(key, 0);
                this.theKeys.splice(index, 1);
                this.theValues.splice(index, 1);
                delete this[key];
            };
            Dictionary.prototype.clear = function () {
                for (var i = this.theKeys.length; i >= 0; i--) {
                    var key = this.theKeys[i];
                    this.remove(key);
                }
            };
            Dictionary.prototype.count = function () {
                return this.theKeys.length;
            };
            Dictionary.prototype.keys = function () {
                return this.theKeys;
            };
            Dictionary.prototype.values = function () {
                return this.theValues;
            };
            Dictionary.prototype.containsKey = function (key) {
                return (typeof this[key] !== "undefined");
            };
            Dictionary.prototype.toLookup = function () {
                return this;
            };
            return Dictionary;
        })();
        Helpers.Dictionary = Dictionary;
    })(Helpers = csComp.Helpers || (csComp.Helpers = {}));
})(csComp || (csComp = {}));

var esriJsonConverter;
(function (esriJsonConverter_1) {
    var esriJsonConverter = (function () {
        function esriJsonConverter() {
            this.esriCon = {};
            /************************************************
             * GeoJSON to ESRI Rest Converter
             ************************************************/
            this.gCon = {};
        }
        /*determine if polygon ring coordinates are clockwise. clockwise signifies outer ring, counter-clockwise an inner ring
          or hole. this logic was found at http://stackoverflow.com/questions/1165647/how-to-determine-if-a-list-of-polygon-
          points-are-in-clockwise-order*/
        esriJsonConverter.prototype.ringIsClockwise = function (ringToTest) {
            var total = 0, i = 0, rLength = ringToTest.length, pt1 = ringToTest[i], pt2;
            for (i; i < rLength - 1; i++) {
                pt2 = ringToTest[i + 1];
                total += (pt2[0] - pt1[0]) * (pt2[1] + pt1[1]);
                pt1 = pt2;
            }
            return (total >= 0);
        };
        /*Converts ESRI Rest Geometry to GeoJSON Geometry
          Input is ESRI Rest Geometry Object*/
        esriJsonConverter.prototype.esriGeometryToGcGeometry = function (esriGeom) {
            var gcGeom, i, g, coordinates, geomType, geomParts, polyArray, ringArray, ring;
            //check for x, points, paths, or rings to determine geometry type.
            if (esriGeom) {
                //gcGeom = {};
                if (((esriGeom.x && esriGeom.x !== "NaN") || esriGeom.x === 0) &&
                    ((esriGeom.y && esriGeom.y !== "NaN") || esriGeom.y === 0)) {
                    geomType = "Point";
                    coordinates = [esriGeom.x, esriGeom.y];
                }
                else if (esriGeom.points && esriGeom.points.length) {
                    geomType = "MultiPoint";
                    coordinates = esriGeom.points;
                }
                else if (esriGeom.paths && esriGeom.paths.length) {
                    geomParts = esriGeom.paths;
                    if (geomParts.length === 1) {
                        geomType = "LineString";
                        coordinates = geomParts[0];
                    }
                    else {
                        geomType = "MultiLineString";
                        coordinates = geomParts;
                    }
                }
                else if (esriGeom.rings && esriGeom.rings.length) {
                    //array to hold the individual polygons. A polygon is an outer ring with one or more inner rings
                    //the conversion logic assumes that the Esri json is in the format of an outer ring (clockwise)
                    //followed by inner rings (counter-clockwise) with a clockwise ring signalling the start of a new polygon
                    polyArray = [];
                    geomParts = esriGeom.rings;
                    for (i = 0; i < geomParts.length; i++) {
                        ring = geomParts[i];
                        if (this.ringIsClockwise(ring)) {
                            //outer ring so new polygon. Add to poly array
                            polyArray.push([ring]);
                        }
                        else if (polyArray.length > 0) {
                            //inner ring. Add as part of last polygon in poly array
                            polyArray[polyArray.length - 1].push(ring);
                        }
                    }
                    if (polyArray.length > 1) {
                        //MultiPolygon. Leave coordinates wrapped in outer array
                        coordinates = polyArray;
                        geomType = "MultiPolygon";
                    }
                    else {
                        //Polygon. Remove outer array wrapper.
                        coordinates = polyArray.pop();
                        geomType = "Polygon";
                    }
                }
                gcGeom = (coordinates && geomType) ? { type: geomType, coordinates: coordinates } : null;
                return gcGeom;
            }
            return gcGeom;
        };
        /*
         * Converts GeoJSON feature to ESRI REST Feature.
         * Input parameter is an ESRI Rest Feature object
         */
        esriJsonConverter.prototype.esriFeatureToGcFeature = function (esriFeature) {
            var gcFeat = null, prop, gcProps, i, p;
            if (esriFeature) {
                gcFeat = {
                    type: "Feature"
                };
                if (esriFeature.geometry) {
                    gcFeat.geometry = this.esriGeometryToGcGeometry(esriFeature.geometry);
                }
                if (esriFeature.attributes) {
                    gcProps = {};
                    p = esriFeature.attributes;
                    for (prop in esriFeature.attributes) {
                        gcProps[prop] = esriFeature.attributes[prop];
                    }
                    gcFeat.properties = gcProps;
                }
            }
            return gcFeat;
        };
        /*Converts ESRI Rest Featureset, Feature, or Geometry
          to GeoJSON FeatureCollection, Feature, or Geometry */
        esriJsonConverter.prototype.toGeoJson = function (esriObject) {
            var outObj, i, esriFeats, gcFeat;
            if (esriObject) {
                if (esriObject.features) {
                    outObj = {
                        type: "FeatureCollection",
                        features: []
                    };
                    esriFeats = esriObject.features;
                    for (i = 0; i < esriFeats.length; i++) {
                        gcFeat = this.esriFeatureToGcFeature(esriFeats[i]);
                        if (gcFeat) {
                            outObj.features.push(gcFeat);
                        }
                    }
                }
                else if (esriObject.geometry) {
                    outObj = this.esriFeatureToGcFeature(esriObject);
                }
                else {
                    outObj = this.esriGeometryToGcGeometry(esriObject);
                }
            }
            return outObj;
        };
        ;
        /*compares a GeoJSON geometry type and ESRI geometry type to see if they can be safely
          put together in a single ESRI feature. ESRI features must only have one
          geometry type, point, line, polygon*/
        esriJsonConverter.prototype.isCompatible = function (esriGeomType, gcGeomType) {
            var compatible = false;
            if ((esriGeomType === "esriGeometryPoint" || esriGeomType === "esriGeometryMultipoint") && (gcGeomType === "Point" || gcGeomType === "MultiPoint")) {
                compatible = true;
            }
            else if (esriGeomType === "esriGeometryPolyline" && (gcGeomType === "LineString" || gcGeomType === "MultiLineString")) {
                compatible = true;
            }
            else if (esriGeomType === "esriGeometryPolygon" && (gcGeomType === "Polygon" || gcGeomType === "MultiPolygon")) {
                compatible = true;
            }
            return compatible;
        };
        /*Take a GeoJSON geometry type and make an object that has information about
          what the ESRI geometry should hold. Includes the ESRI geometry type and the name
          of the member that holds coordinate information*/
        esriJsonConverter.prototype.gcGeomTypeToEsriGeomInfo = function (gcType) {
            var esriType, geomHolderId;
            if (gcType === "Point") {
                esriType = "esriGeometryPoint";
            }
            else if (gcType === "MultiPoint") {
                esriType = "esriGeometryMultipoint";
                geomHolderId = "points";
            }
            else if (gcType === "LineString" || gcType === "MultiLineString") {
                esriType = "esriGeometryPolyline";
                geomHolderId = "paths";
            }
            else if (gcType === "Polygon" || gcType === "MultiPolygon") {
                esriType = "esriGeometryPolygon";
                geomHolderId = "rings";
            }
            return {
                type: esriType,
                geomHolder: geomHolderId
            };
        };
        /*Convert GeoJSON polygon coordinates to ESRI polygon coordinates.
          GeoJSON rings are listed starting with a singular outer ring. ESRI
          rings can be listed in any order, but unlike GeoJSON, the ordering of
          vertices determines whether it's an outer or inner ring. Clockwise
          vertices indicate outer ring and counter-clockwise vertices indicate
          inner ring */
        esriJsonConverter.prototype.gcPolygonCoordinatesToEsriPolygonCoordinates = function (gcCoords) {
            var i, len, esriCoords = [], ring;
            for (i = 0, len = gcCoords.length; i < len; i++) {
                ring = gcCoords[i];
                // Exclusive OR.
                if ((i == 0) != this.ringIsClockwise(ring)) {
                    ring = ring.reverse();
                }
                esriCoords.push(ring);
            }
            return esriCoords;
        };
        /*Wraps GeoJSON coordinates in an array if necessary so code can iterate
          through array of points, rings, or lines and add them to an ESRI geometry
          Input is a GeoJSON geometry object. A GeoJSON GeometryCollection is not a
          valid input */
        esriJsonConverter.prototype.gcCoordinatesToEsriCoordinates = function (gcGeom) {
            var i, len, esriCoords;
            if (gcGeom.type === "MultiPoint" || gcGeom.type === "MultiLineString") {
                esriCoords = gcGeom.coordinates;
            }
            else if (gcGeom.type === "Point" || gcGeom.type === "LineString") {
                esriCoords = [gcGeom.coordinates];
            }
            else if (gcGeom.type === "Polygon") {
                esriCoords = this.gcPolygonCoordinatesToEsriPolygonCoordinates(gcGeom.coordinates);
            }
            else if (gcGeom.type === "MultiPolygon") {
                esriCoords = [];
                for (i = 0, len = gcGeom.coordinates.length; i < len; i++) {
                    esriCoords.push(this.gcPolygonCoordinatesToEsriPolygonCoordinates(gcGeom.coordinates[i])[0]);
                }
            }
            return esriCoords;
        };
        /*Converts GeoJSON geometry to ESRI geometry. The ESRI geometry is
          only allowed to contain one type of geometry, so if the GeoJSON
          geometry is a GeometryCollection, then only geometries compatible
          with the first geometry type in the collection are added to the ESRI geometry

          Input parameter is a GeoJSON geometry object.*/
        esriJsonConverter.prototype.gcGeometryToEsriGeometry = function (gcGeom) {
            var esriGeometry, esriGeomInfo, gcGeometriesToConvert, i, g, coords;
            //if geometry collection, get info about first geometry in collection
            if (gcGeom.type === "GeometryCollection") {
                gcGeometriesToConvert = [gcGeom.geometries.shift()];
                esriGeomInfo = this.gcGeomTypeToEsriGeomInfo(gcGeometriesToConvert[0].type);
                //loop through collection and only add compatible geometries to the array
                //of geometries that will be converted
                for (i = 0; i < gcGeom.geometries.length; i++) {
                    if (this.isCompatible(esriGeomInfo.type, gcGeom.geometries[i].type)) {
                        gcGeometriesToConvert.push(gcGeom.geometries[i]);
                    }
                }
            }
            else {
                esriGeomInfo = this.gcGeomTypeToEsriGeomInfo(gcGeom.type);
                gcGeometriesToConvert = [gcGeom];
            }
            //if a collection contained multiple points, change the ESRI geometry
            //type to MultiPoint
            if (esriGeomInfo.type === "esriGeometryPoint" && gcGeometriesToConvert.length > 1) {
                esriGeomInfo = this.gcGeomTypeToEsriGeomInfo("MultiPoint");
            }
            //make new empty ESRI geometry object
            esriGeometry = {
                //type: esriGeomInfo.type,
                spatialReference: {
                    wkid: 4326
                }
            };
            //perform conversion
            if (esriGeomInfo.type === "esriGeometryPoint") {
                if (gcGeometriesToConvert[0].coordinates.length === 0) {
                    esriGeometry.x = null;
                    esriGeometry.y = null;
                }
                else {
                    esriGeometry.x = gcGeometriesToConvert[0].coordinates[0];
                    esriGeometry.y = gcGeometriesToConvert[0].coordinates[1];
                }
            }
            else {
                esriGeometry[esriGeomInfo.geomHolder] = [];
                for (i = 0; i < gcGeometriesToConvert.length; i++) {
                    coords = this.gcCoordinatesToEsriCoordinates(gcGeometriesToConvert[i]);
                    for (g = 0; g < coords.length; g++) {
                        esriGeometry[esriGeomInfo.geomHolder].push(coords[g]);
                    }
                }
            }
            return esriGeometry;
        };
        /*Converts GeoJSON feature to ESRI REST Feature.
          Input parameter is a GeoJSON Feature object*/
        esriJsonConverter.prototype.gcFeatureToEsriFeature = function (gcFeature) {
            var esriFeat, prop, esriAttribs;
            if (gcFeature) {
                esriFeat = {};
                if (gcFeature.geometry) {
                    esriFeat.geometry = this.gcGeometryToEsriGeometry(gcFeature.geometry);
                }
                if (gcFeature.properties) {
                    esriAttribs = {};
                    for (prop in gcFeature.properties) {
                        esriAttribs[prop] = gcFeature.properties[prop];
                    }
                    esriFeat.attributes = esriAttribs;
                }
            }
            return esriFeat;
        };
        /*Converts GeoJSON FeatureCollection, Feature, or Geometry
          to ESRI Rest Featureset, Feature, or Geometry*/
        esriJsonConverter.prototype.toEsri = function (geoJsonObject) {
            var outObj, i, gcFeats, esriFeat;
            if (geoJsonObject) {
                if (geoJsonObject.type === "FeatureCollection") {
                    outObj = {
                        features: []
                    };
                    gcFeats = geoJsonObject.features;
                    for (i = 0; i < gcFeats.length; i++) {
                        esriFeat = this.gcFeatureToEsriFeature(gcFeats[i]);
                        if (esriFeat) {
                            outObj.features.push(esriFeat);
                        }
                    }
                }
                else if (geoJsonObject.type === "Feature") {
                    outObj = this.gcFeatureToEsriFeature(geoJsonObject);
                }
                else {
                    outObj = this.gcGeometryToEsriGeometry(geoJsonObject);
                }
            }
            return outObj;
        };
        ;
        return esriJsonConverter;
    })();
    esriJsonConverter_1.esriJsonConverter = esriJsonConverter;
})(esriJsonConverter || (esriJsonConverter = {}));

var csComp;
(function (csComp) {
    var Helpers;
    (function (Helpers) {
        /**
        * A set of static geo tools
        * Source: http://www.csgnetwork.com/degreelenllavcalc.html
        */
        var GeoExtensions = (function () {
            function GeoExtensions() {
            }
            GeoExtensions.getBoundingBox = function (data) {
                var bounds = {}, coords, point, latitude, longitude;
                // We want to use the features key of the FeatureCollection (see above)
                data = data.features;
                // Loop through each feature
                for (var i = 0; i < data.length; i++) {
                    // get bound
                    var b = d3.geo.bounds(data[i]);
                    // Update the bounds recursively by comparing the current
                    // xMin/xMax and yMin/yMax with the coordinate
                    // we're currently checking
                    bounds.xMin = bounds.xMin < b[0][0] ? bounds.xMin : b[0][0];
                    bounds.xMax = bounds.xMax > b[1][0] ? bounds.xMax : b[1][0];
                    bounds.yMin = bounds.yMin < b[0][1] ? bounds.yMin : b[0][1];
                    bounds.yMax = bounds.yMax > b[1][1] ? bounds.yMax : b[1][1];
                }
                bounds.southWest = [bounds.yMin, bounds.xMin];
                bounds.northEast = [bounds.yMax, bounds.xMax];
                // Returns an object that contains the bounds of this GeoJSON
                // data. The keys of this object describe a box formed by the
                // northwest (xMin, yMin) and southeast (xMax, yMax) coordinates.
                return bounds;
            };
            /**
            * Convert topojson data to geojson data.
            */
            GeoExtensions.convertTopoToGeoJson = function (data) {
                // Convert topojson to geojson format
                var o = typeof data === 'string'
                    ? JSON.parse(data)
                    : data;
                var newData = {};
                newData.featureTypes = data.featureTypes;
                newData.features = [];
                for (var i in o.objects) {
                    var ft = topojson.feature(o, o.objects[i]);
                    if (ft.features) {
                        // ft contains multiple features
                        ft.features.forEach(function (f) { return newData.features.push(f); });
                    }
                    else {
                        newData.features.push(ft);
                    }
                }
                return newData;
            };
            GeoExtensions.deg2rad = function (degree) {
                var conv_factor = (2.0 * Math.PI) / 360.0;
                return (degree * conv_factor);
            };
            GeoExtensions.rad2deg = function (rad) {
                var conv_factor = 360 / (2.0 * Math.PI);
                return (rad * conv_factor);
            };
            /**
             * Convert RD (Rijksdriehoek) coordinates to WGS84.
             * @param  {number} x [RD X coordinate]
             * @param  {number} y [RD Y coordinate]
             * @return {[type]}   [object with latitude and longitude coordinate in WGS84]
             * Source: http://home.solcon.nl/pvanmanen/Download/Transformatieformules.pdf, http://www.roelvanlisdonk.nl/?p=2950
             */
            GeoExtensions.convertRDToWGS84 = function (x, y) {
                var x0 = 155000.000, y0 = 463000.000, f0 = 52.156160556, l0 = 5.387638889, a01 = 3236.0331637, b10 = 5261.3028966, a20 = -32.5915821, b11 = 105.9780241, a02 = -0.2472814, b12 = 2.4576469, a21 = -0.8501341, b30 = -0.8192156, a03 = -0.0655238, b31 = -0.0560092, a22 = -0.0171137, b13 = 0.0560089, a40 = 0.0052771, b32 = -0.0025614, a23 = -0.0003859, b14 = 0.0012770, a41 = 0.0003314, b50 = 0.0002574, a04 = 0.0000371, b33 = -0.0000973, a42 = 0.0000143, b51 = 0.0000293, a24 = -0.0000090, b15 = 0.0000291;
                var dx = (x - x0) * Math.pow(10, -5);
                var dy = (y - y0) * Math.pow(10, -5);
                var df = a01 * dy + a20 * Math.pow(dx, 2) + a02 * Math.pow(dy, 2) + a21 * Math.pow(dx, 2) * dy + a03 * Math.pow(dy, 3);
                df += a40 * Math.pow(dx, 4) + a22 * Math.pow(dx, 2) * Math.pow(dy, 2) + a04 * Math.pow(dy, 4) + a41 * Math.pow(dx, 4) * dy;
                df += a23 * Math.pow(dx, 2) * Math.pow(dy, 3) + a42 * Math.pow(dx, 4) * Math.pow(dy, 2) + a24 * Math.pow(dx, 2) * Math.pow(dy, 4);
                var f = f0 + df / 3600;
                var dl = b10 * dx + b11 * dx * dy + b30 * Math.pow(dx, 3) + b12 * dx * Math.pow(dy, 2) + b31 * Math.pow(dx, 3) * dy;
                dl += b13 * dx * Math.pow(dy, 3) + b50 * Math.pow(dx, 5) + b32 * Math.pow(dx, 3) * Math.pow(dy, 2) + b14 * dx * Math.pow(dy, 4);
                dl += b51 * Math.pow(dx, 5) * dy + b33 * Math.pow(dx, 3) * Math.pow(dy, 3) + b15 * dx * Math.pow(dy, 5);
                var l = l0 + dl / 3600;
                var lat = f + (-96.862 - 11.714 * (f - 52) - 0.125 * (l - 5)) / 100000, lon = l + (-37.902 + 0.329 * (f - 52) - 14.667 * (l - 5)) / 100000;
                return { latitude: lat, longitude: lon };
            };
            /**
            * Calculate the log base 10 of val
            */
            GeoExtensions.log10 = function (val) {
                return (Math.LOG10E * Math.log(val));
            };
            GeoExtensions.convertDegreesToMeters = function (latitudeDegrees) {
                // Convert latitude to radians
                var lat = GeoExtensions.deg2rad(latitudeDegrees);
                // Set up "Constants"
                var m1 = 111132.92, // latitude calculation term 1
                m2 = -559.82, // latitude calculation term 2
                m3 = 1.175, // latitude calculation term 3
                m4 = -0.0023, // latitude calculation term 4
                p1 = 111412.84, // longitude calculation term 1
                p2 = -93.5, // longitude calculation term 2
                p3 = 0.118; // longitude calculation term 3
                // Calculate the length of a degree of latitude and longitude in meters
                var latlen = m1 + (m2 * Math.cos(2 * lat)) + (m3 * Math.cos(4 * lat)) + (m4 * Math.cos(6 * lat));
                var lonlen = (p1 * Math.cos(lat)) + (p2 * Math.cos(3 * lat)) + (p3 * Math.cos(5 * lat));
                return {
                    /**
                    * Length of a degree of latitude in meters
                    */
                    latitudeLength: latlen,
                    /**
                    * Length of a degree of longitude in meters
                    */
                    longitudeLength: lonlen
                };
            };
            /**
             * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a {@link Polygon} feature.
             *
             * @module turf/polygon
             * @category helper
             * @param {Array<Array<Number>>} rings an array of LinearRings
             * @param {Object=} properties a properties object
             * @returns {Feature<Polygon>} a Polygon feature
             * @throws {Error} throw an error if a LinearRing of the polygon has too few positions
             * or if a LinearRing of the Polygon does not have matching Positions at the
             * beginning & end.
             * @example
             * var polygon = createPolygon([[
             *  [-2.275543, 53.464547],
             *  [-2.275543, 53.489271],
             *  [-2.215118, 53.489271],
             *  [-2.215118, 53.464547],
             *  [-2.275543, 53.464547]
             * ]], { name: 'poly1', population: 400});
             *
             * @seealso https://github.com/Turfjs/turf-polygon/blob/master/index.js
             */
            GeoExtensions.createPolygonFeature = function (coordinates, properties) {
                if (coordinates === null)
                    throw new Error('No coordinates passed');
                for (var i = 0; i < coordinates.length; i++) {
                    var ring = coordinates[i];
                    for (var j = 0; j < ring[ring.length - 1].length; j++) {
                        if (ring.length < 4) {
                            new Error('Each LinearRing of a Polygon must have 4 or more Positions.');
                        }
                        if (ring[ring.length - 1][j] !== ring[0][j]) {
                            new Error('First and last Position are not equivalent.');
                        }
                    }
                }
                var polygon = {
                    "type": "Feature",
                    "geometry": {
                        "type": "Polygon",
                        "coordinates": coordinates
                    },
                    "properties": properties
                };
                if (!polygon.properties) {
                    polygon.properties = {};
                }
                return polygon;
            };
            /**
             * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
             *
             * @param {Feature[]} features input features
             * @returns {FeatureCollection} a FeatureCollection of input features
             * @example
             * var features = [
             *  turf.point([-75.343, 39.984], {name: 'Location A'}),
             *  turf.point([-75.833, 39.284], {name: 'Location B'}),
             *  turf.point([-75.534, 39.123], {name: 'Location C'})
             * ];
             *
             * var fc = turf.featurecollection(features);
             *
             * @seealso https://github.com/Turfjs/turf-featurecollection/blob/master/index.js
             */
            GeoExtensions.createFeatureCollection = function (features) {
                return {
                    type: "FeatureCollection",
                    features: features
                };
            };
            GeoExtensions.createPointFeature = function (lon, lat, properties, sensors) {
                var gjson = {
                    type: "Feature",
                    geometry: {
                        type: "Point",
                        coordinates: [lon, lat]
                    },
                    properties: properties
                };
                if (sensors && sensors !== {}) {
                    gjson["sensors"] = sensors;
                }
                return gjson;
            };
            GeoExtensions.createLineFeature = function (coordinates, properties) {
                if (coordinates === null)
                    throw new Error('No coordinates passed');
                for (var i = 0; i < coordinates.length; i++) {
                    var ring = coordinates[i];
                    if (ring.length < 2) {
                        new Error('Each LineString of a Polygon must have 2 or more Positions.');
                    }
                }
                var lines = {
                    "type": "Feature",
                    "geometry": {
                        "type": "LineString",
                        "coordinates": coordinates
                    },
                    "properties": properties
                };
                if (!lines.properties) {
                    lines.properties = {};
                }
                return lines;
            };
            GeoExtensions.createPropertyType = function (name, section) {
                if (!name)
                    return;
                var propType = {
                    label: name,
                    title: name,
                    type: "text",
                    visibleInCallOut: true,
                    canEdit: true,
                    isSearchable: false
                };
                if (section)
                    propType["section"] = section;
                return propType;
            };
            GeoExtensions.convertMileToKm = function (miles) {
                if (!miles || isNaN(miles))
                    return;
                return (miles * 1.609344);
            };
            GeoExtensions.convertKmToMile = function (km) {
                if (!km || isNaN(km))
                    return;
                return (km * 0.621371192);
            };
            /**
             * pointInsidePolygon returns true if a 2D point lies within a polygon of 2D points
             * @param  {number[]}   point   [lat, lng]
             * @param  {number[][]} polygon [[lat, lng], [lat,lng],...]
             * @return {boolean}            Inside == true
             */
            GeoExtensions.pointInsidePolygon = function (point, polygon) {
                // https://github.com/substack/point-in-polygon
                // ray-casting algorithm based on
                // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
                var x = point[0];
                var y = point[1];
                var p = polygon[0];
                var inside = false;
                for (var i = 0, j = p.length - 1; i < p.length; j = i++) {
                    var xi = p[i][0], yi = p[i][1];
                    var xj = p[j][0], yj = p[j][1];
                    var intersect = ((yi > y) != (yj > y))
                        && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                    if (intersect)
                        inside = !inside;
                }
                return inside;
            };
            /**
             * pointInsideMultiPolygon returns true if a 2D point lies within a multipolygon
             * @param  {number[]}   point   [lat, lng]
             * @param  {number[][][]} polygon [[[lat, lng], [lat,lng]],...]]
             * @return {boolean}            Inside == true
             */
            GeoExtensions.pointInsideMultiPolygon = function (point, multipoly) {
                // https://github.com/substack/point-in-polygon
                // ray-casting algorithm based on
                // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
                var inside = false;
                for (var i = 0; i < multipoly.length; i++) {
                    var polygon = multipoly[i];
                    if (GeoExtensions.pointInsidePolygon(point, polygon))
                        inside = !inside;
                }
                return inside;
            };
            return GeoExtensions;
        })();
        Helpers.GeoExtensions = GeoExtensions;
    })(Helpers = csComp.Helpers || (csComp.Helpers = {}));
})(csComp || (csComp = {}));

// export interface Array<T> {
//     serialize<T>(): string
// }
//
// Array<T>.prototype.serialize<T> = function() {
//     return "";
// }
var csComp;
(function (csComp) {
    var Helpers;
    (function (Helpers) {
        /**
         * Serialize an array of type T to a JSON string, by calling the callback on each array element.
         */
        function serialize(arr, callback) {
            if (typeof arr === 'undefined' || arr === null || arr.length === 0)
                return null;
            var result = [];
            arr.forEach(function (a) {
                result.push(callback(a));
            });
            return result;
        }
        Helpers.serialize = serialize;
        function getDefaultFeatureStyle() {
            //TODO: check compatibility for both heatmaps and other features
            var s = {
                nameLabel: "Name",
                strokeWidth: 3,
                strokeColor: "#0033ff",
                fillOpacity: 0.75,
                opacity: 1,
                fillColor: "#FFFF00",
                stroke: true,
                rotate: 0,
                iconUri: "cs/images/marker.png",
                iconHeight: 32,
                iconWidth: 32
            };
            return s;
        }
        Helpers.getDefaultFeatureStyle = getDefaultFeatureStyle;
        /**
         * Export data to the file system.
         */
        function saveData(data, filename, fileType) {
            fileType = fileType.replace(".", "");
            filename = filename.replace("." + fileType, "") + "." + fileType; // if the filename already contains a type, first remove it before adding it.
            if (navigator.msSaveBlob) {
                // IE 10+
                var link = document.createElement('a');
                link.addEventListener("click", function (event) {
                    var blob = new Blob([data], { "type": "text/" + fileType + ";charset=utf-8;" });
                    navigator.msSaveBlob(blob, filename);
                }, false);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
            else if (!csComp.Helpers.supportsDataUri()) {
                // Older versions of IE: show the data in a new window
                var popup = window.open('', fileType, '');
                popup.document.body.innerHTML = '<pre>' + data + '</pre>';
            }
            else {
                // Support for browsers that support the data uri.
                var a = document.createElement('a');
                document.body.appendChild(a);
                a.href = "data:text/" + fileType + ";charset=utf-8," + encodeURI(data);
                a.target = '_blank';
                a.download = filename;
                a.click();
                document.body.removeChild(a);
            }
        }
        Helpers.saveData = saveData;
        function supportsDataUri() {
            var isOldIE = navigator.appName === "Microsoft Internet Explorer";
            var isIE11 = !!navigator.userAgent.match(/Trident\/7\./);
            return !(isOldIE || isIE11); //Return true if not any IE
        }
        Helpers.supportsDataUri = supportsDataUri;
        function standardDeviation(values) {
            var avg = average(values);
            var squareDiffs = values.map(function (value) {
                var diff = value - avg;
                var sqrDiff = diff * diff;
                return sqrDiff;
            });
            var avgSquareDiff = average(squareDiffs);
            var stdDev = Math.sqrt(avgSquareDiff);
            return { avg: avg, stdDev: stdDev };
        }
        Helpers.standardDeviation = standardDeviation;
        function average(data) {
            var sum = data.reduce(function (accumulatedSum, value) { return (accumulatedSum + value); }, 0);
            var avg = sum / data.length;
            return avg;
        }
        Helpers.average = average;
        function getFeatureTitle(feature) {
            return featureTitle(feature.fType, feature);
        }
        Helpers.getFeatureTitle = getFeatureTitle;
        function featureTitle(type, feature) {
            var title = '';
            if (feature.hasOwnProperty('properties')) {
                if (feature.properties.hasOwnProperty('Name'))
                    title = feature.properties['Name'];
                else if (feature.properties.hasOwnProperty('name'))
                    title = feature.properties['name'];
                else if (feature.properties.hasOwnProperty('naam'))
                    title = feature.properties['naam'];
            }
            else if (type != null && type.style != null && type.style.nameLabel) {
                title = feature.properties[type.style.nameLabel];
            }
            if (!csComp.StringExt.isNullOrEmpty(title) && !$.isNumeric(title))
                title = title.replace(/&amp;/g, '&');
            return title;
        }
        Helpers.featureTitle = featureTitle;
        /**
         * Collect all the property types that are referenced by a feature type.
         */
        function getPropertyTypes(type, propertyTypeData, feature) {
            var propertyTypes = [];
            if (type.propertyTypeKeys != null) {
                var keys = type.propertyTypeKeys.split(';');
                keys.forEach(function (key) {
                    // First, lookup key in global propertyTypeData
                    if (propertyTypeData && propertyTypeData.hasOwnProperty(key))
                        propertyTypes.push(propertyTypeData[key]);
                    else if (type.propertyTypeData != null) {
                        var result = $.grep(type.propertyTypeData, function (e) { return e.label === key; });
                        if (result.length >= 1)
                            propertyTypes.push(result);
                    }
                });
            }
            if (type.showAllProperties && feature && feature.properties) {
                for (var key in feature.properties) {
                    if (!propertyTypes.some(function (pt) { return pt.label == key; })) {
                    }
                }
            }
            if (type.propertyTypeData != null) {
                if (type.propertyTypeData.forEach) {
                    type.propertyTypeData.forEach(function (pt) {
                        propertyTypes.push(pt);
                    });
                }
                else {
                    for (var ptlabel in type.propertyTypeData) {
                        if (type.propertyTypeData.hasOwnProperty(ptlabel)) {
                            propertyTypes.push(type.propertyTypeData[ptlabel]);
                        }
                    }
                }
            }
            return propertyTypes;
        }
        Helpers.getPropertyTypes = getPropertyTypes;
        function getMissingPropertyTypes(feature) {
            //var type = featureType;
            var res = [];
            //        if (!type.propertyTypeData) type.propertyTypeData = [];
            for (var key in feature.properties) {
                //if (!type.propertyTypeData.some((pt: csComp.Services.IPropertyType) => { return pt.label === key; })) {
                if (!feature.properties.hasOwnProperty(key))
                    continue;
                var propertyType = [];
                propertyType.label = key;
                propertyType.title = key.replace('_', ' ');
                propertyType.isSearchable = true;
                propertyType.visibleInCallOut = true;
                propertyType.canEdit = false;
                var value = feature.properties[key]; // TODO Why does TS think we are returning an IStringToString object?
                if (csComp.StringExt.isDate(value))
                    propertyType.type = 'date';
                else if (csComp.StringExt.isNumber(value))
                    propertyType.type = 'number';
                else if (csComp.StringExt.isBoolean(value))
                    propertyType.type = 'boolean';
                else if (csComp.StringExt.isArray(value))
                    propertyType.type = 'tags';
                else if (csComp.StringExt.isBbcode(value))
                    propertyType.type = 'bbcode';
                else
                    propertyType.type = 'text';
                res.push(propertyType);
            }
            return res;
        }
        Helpers.getMissingPropertyTypes = getMissingPropertyTypes;
        function addPropertyTypes(feature, featureType) {
            var type = featureType;
            if (!type.propertyTypeData)
                type.propertyTypeData = [];
            for (var key in feature.properties) {
                if (!type.propertyTypeData.some(function (pt) { return pt.label === key; })) {
                    if (!feature.properties.hasOwnProperty(key))
                        continue;
                    var propertyType = [];
                    propertyType.label = key;
                    propertyType.title = key.replace('_', ' ');
                    propertyType.isSearchable = true;
                    propertyType.visibleInCallOut = true;
                    propertyType.canEdit = false;
                    var value = feature.properties[key]; // TODO Why does TS think we are returning an IStringToString object?
                    if (csComp.StringExt.isNumber(value))
                        propertyType.type = 'number';
                    else if (csComp.StringExt.isBoolean(value))
                        propertyType.type = 'boolean';
                    else if (csComp.StringExt.isBbcode(value))
                        propertyType.type = 'bbcode';
                    else
                        propertyType.type = 'text';
                    type.propertyTypeData.push(propertyType);
                }
            }
            return type;
        }
        Helpers.addPropertyTypes = addPropertyTypes;
        /**
         * In case we are dealing with a regular JSON file without type information, create a default type.
         */
        function createDefaultType(feature) {
            var type = {};
            type.style = getDefaultFeatureStyle();
            type.propertyTypeData = [];
            this.addPropertyTypes(feature, type);
            return type;
        }
        Helpers.createDefaultType = createDefaultType;
        /**
         * Convert a property value to a display value using the property info.
         */
        function convertPropertyInfo(pt, text) {
            var displayValue;
            // if (!csComp.StringExt.isNullOrEmpty(text) && !$.isNumeric(text))
            //     text = text.replace(/&amp;/g, '&');
            if (csComp.StringExt.isNullOrEmpty(text))
                return text;
            if (!pt.type)
                return text;
            switch (pt.type) {
                case "bbcode":
                    if (!csComp.StringExt.isNullOrEmpty(pt.stringFormat))
                        text = String.format(pt.stringFormat, text);
                    displayValue = XBBCODE.process({ text: text }).html;
                    break;
                case "number":
                    if (!$.isNumeric(text))
                        displayValue = text;
                    else if (!pt.stringFormat)
                        displayValue = text.toString();
                    else
                        displayValue = String.format(pt.stringFormat, parseFloat(text));
                    break;
                case "options":
                    if (!$.isNumeric(text))
                        displayValue = text;
                    else
                        displayValue = pt.options[text];
                    break;
                case "rank":
                    var rank = text.split(',');
                    if (rank.length != 2)
                        return text;
                    if (pt.stringFormat)
                        displayValue = String.format(pt.stringFormat, rank[0], rank[1]);
                    else
                        displayValue = String.format("{0} / {1}", rank[0], rank[1]);
                    break;
                case "hierarchy":
                    var hierarchy = text.split(";");
                    var count = hierarchy[0];
                    var calculation = hierarchy[1];
                    displayValue = count.toString();
                    break;
                case "date":
                    var d = new Date(Date.parse(text));
                    displayValue = d.toLocaleString();
                    break;
                case "duration":
                    if (!$.isNumeric(text)) {
                        displayValue = text;
                    }
                    else {
                        var d0 = new Date(0);
                        var d1 = new Date(text);
                        var h = d1.getHours() - d0.getHours();
                        var m = d1.getMinutes() - d0.getMinutes();
                        var s = d1.getSeconds() - d0.getSeconds();
                        displayValue = ('0' + h).slice(-2) + 'h' + ('0' + m).slice(-2) + 'm' + ('0' + s).slice(-2) + 's';
                    }
                    break;
                default:
                    displayValue = text;
                    break;
            }
            return displayValue;
        }
        Helpers.convertPropertyInfo = convertPropertyInfo;
        /**
        * Set the name of a feature.
        * @param {csComp.Services.IFeature} feature
        */
        function setFeatureName(feature, propertyTypeData) {
            // Case one: we don't need to set it, as it's already present.
            if (feature.properties.hasOwnProperty('Name'))
                return feature;
            if (feature.properties.hasOwnProperty('name')) {
                feature.properties['Name'] = feature.properties['name'];
                return feature;
            }
            // Case two: the feature's style tells us what property to use for the name.
            if (feature.fType && feature.fType.style && feature.fType.style.nameLabel) {
                var nameLabel = feature.fType.style.nameLabel;
                if (nameLabel && feature.properties.hasOwnProperty(nameLabel)) {
                    if (propertyTypeData && propertyTypeData.hasOwnProperty(nameLabel)) {
                        feature.properties['Name'] = convertPropertyInfo(propertyTypeData[nameLabel], feature.properties[nameLabel]);
                    }
                    else {
                        feature.properties['Name'] = feature.properties[nameLabel];
                    }
                    return feature;
                }
            }
            // Case three: the feature has a Name property which specifies a string format, meaning that the Name is derived from several existing properties.
            if (feature.fType.propertyTypeData != null) {
                for (var i = 0; i < feature.fType.propertyTypeData.length; i++) {
                    var propertyType = feature.fType.propertyTypeData[i];
                    if (propertyType.label !== 'Name' || !propertyType.stringFormat)
                        continue;
                    feature.properties['Name'] = Helpers.convertStringFormat(feature, propertyType.stringFormat);
                    return feature;
                }
            }
            // If all else fails, use the first property
            for (var prop in feature.properties) {
                feature.properties['Name'] = prop.toString(); //feature.properties[prop];
                return feature;
            }
            // Finally, just create a GUID.
            feature.properties['Name'] = Helpers.getGuid();
            return feature;
        }
        Helpers.setFeatureName = setFeatureName;
        /**
        * Convert a feature's stringFormat to a string.
        * @param {Services.IFeature} feature
        * @param {string} stringFormat
        */
        function convertStringFormat(feature, stringFormat) {
            var openingBrackets = Helpers.indexes(stringFormat, '{');
            var closingBrackets = Helpers.indexes(stringFormat, '}');
            var convertedStringFormat = stringFormat;
            for (var j = 0; j < openingBrackets.length; j++) {
                var searchValue = stringFormat.substring(openingBrackets[j] + 1, closingBrackets[j]);
                convertedStringFormat = convertedStringFormat.replace('{' + searchValue + '}', feature.properties[searchValue]);
            }
            return convertedStringFormat;
        }
        Helpers.convertStringFormat = convertStringFormat;
        /**
        * Get all indexes of the 'find' substring in the 'source' string.
        * @param {string} source
        * @param {string} find
        */
        function indexes(source, find) {
            if (!source)
                return [];
            var result = [];
            for (var i = 0; i < source.length; i++) {
                if (source.substr(i, find.length) === find)
                    result.push(i);
            }
            return result;
        }
        Helpers.indexes = indexes;
        function getGuid() {
            var guid = (this.S4() + this.S4() + "-" + this.S4() + "-4" + this.S4().substr(0, 3) + "-" + this.S4() + "-" + this.S4() + this.S4() + this.S4()).toLowerCase();
            return guid;
        }
        Helpers.getGuid = getGuid;
        function S4() {
            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        }
        Helpers.S4 = S4;
        /**
         * Load the features as visible on the map, effectively creating a virtual
         * GeoJSON file that represents all visible items.
         * Also loads the keys into the featuretype's propertyTypeData collection.
         */
        function loadMapLayers(layerService) {
            var data = {
                type: '',
                features: [],
                featureTypes: {}
            };
            // If we are filtering, load the filter results
            layerService.project.groups.forEach(function (group) {
                if (group.filterResult != null)
                    group.filterResult.forEach(function (f) { return data.features.push(f); });
            });
            // Otherwise, take all loaded features
            if (data.features.length === 0)
                data.features = layerService.project.features;
            data.features.forEach(function (f) {
                if (!(data.featureTypes.hasOwnProperty(f.featureTypeName))) {
                    var featureType = layerService.getFeatureType(f);
                    if (!featureType.name)
                        featureType.name = f.featureTypeName.replace('_Default', '');
                    data.featureTypes[f.featureTypeName] = featureType;
                    if (featureType.propertyTypeKeys) {
                        featureType.propertyTypeData = [];
                        featureType.propertyTypeKeys.split(';').forEach(function (key) {
                            if (layerService.propertyTypeData.hasOwnProperty(key)) {
                                featureType.propertyTypeData.push(layerService.propertyTypeData[key]);
                            }
                        });
                    }
                }
            });
            return data;
        }
        Helpers.loadMapLayers = loadMapLayers;
        /**
         * Helper function to create content for the RightPanelTab
         * @param  {string} container The container name
         * @param  {string} directive The directive of the container
         * @param  {any}    data      Panel data
         * @return {RightPanelTab}    Returns the RightPanelTab instance. Add it to the
         * rightpanel by publishing it on the MessageBus.
         */
        function createRightPanelTab(container, directive, data, title, popover, icon) {
            var rpt = new csComp.Services.RightPanelTab();
            rpt.container = container;
            rpt.data = data;
            rpt.title = title;
            rpt.directive = directive;
            rpt.popover = popover || '';
            rpt.icon = icon || 'tachometer';
            return rpt;
        }
        Helpers.createRightPanelTab = createRightPanelTab;
        /**
         * Helper function to parse a query of an url (e.g localhost:8080/api?a=1&b=2&c=3)
         */
        function parseUrlParameters(url, baseDelimiter, subDelimiter, valueDelimiter) {
            var baseUrl = url.split(baseDelimiter)[0];
            var croppedUrl = url.split(baseDelimiter)[1];
            var splittedUrl = croppedUrl.split(subDelimiter);
            var urlParameters = {};
            splittedUrl.forEach(function (param) {
                var keyValue = param.split(valueDelimiter);
                urlParameters[keyValue[0]] = (isNaN(+keyValue[1])) ? keyValue[1] : +keyValue[1]; //Store as number when possible
            });
            urlParameters['baseUrl'] = baseUrl;
            return urlParameters;
        }
        Helpers.parseUrlParameters = parseUrlParameters;
        /**
         * Helper function to parse a query of an url (e.g localhost:8080/api?a=1&b=2&c=3)
         */
        function joinUrlParameters(params, baseDelimiter, subDelimiter, valueDelimiter) {
            var url = params['baseUrl'] + baseDelimiter;
            for (var key in params) {
                if (params.hasOwnProperty(key) && key !== 'baseUrl' && params[key]) {
                    url = url + key + valueDelimiter + params[key] + subDelimiter;
                }
            }
            url = url.substring(0, url.length - 1);
            return url;
        }
        Helpers.joinUrlParameters = joinUrlParameters;
        function createIconHtml(feature, featureType) {
            var html = '<div ';
            var props = {};
            var ft = featureType;
            //if (feature.poiTypeName != null) html += "class='style" + feature.poiTypeName + "'";
            var iconUri = feature.effectiveStyle.iconUri; //ft.style.iconUri;
            //if (ft.style.fillColor == null && iconUri == null) ft.style.fillColor = 'lightgray';
            // TODO refactor to object
            var iconPlusBorderWidth, iconPlusBorderHeight;
            if (feature.effectiveStyle.hasOwnProperty('strokeWidth') && feature.effectiveStyle.strokeWidth > 0) {
                iconPlusBorderWidth = feature.effectiveStyle.iconWidth + (2 * feature.effectiveStyle.strokeWidth);
                iconPlusBorderHeight = feature.effectiveStyle.iconHeight + (2 * feature.effectiveStyle.strokeWidth);
            }
            else {
                iconPlusBorderWidth = feature.effectiveStyle.iconWidth;
                iconPlusBorderHeight = feature.effectiveStyle.iconHeight;
            }
            props['background'] = feature.effectiveStyle.fillColor;
            props['width'] = iconPlusBorderWidth + 'px';
            props['height'] = iconPlusBorderWidth + 'px';
            props['border-radius'] = feature.effectiveStyle.cornerRadius + '%';
            props['border-style'] = 'solid';
            props['border-color'] = feature.effectiveStyle.strokeColor;
            props['border-width'] = feature.effectiveStyle.strokeWidth + 'px';
            props['opacity'] = feature.effectiveStyle.opacity;
            //if (feature.isSelected) {
            //props['border-width'] = '3px';
            //}
            html += ' style=\'display: inline-block;vertical-align: middle;text-align: center;';
            for (var key in props) {
                if (!props.hasOwnProperty(key))
                    continue;
                html += key + ':' + props[key] + ';';
            }
            html += '\'>';
            if (feature.effectiveStyle.innerTextProperty != null && feature.properties.hasOwnProperty(feature.effectiveStyle.innerTextProperty)) {
                html += "<span style='font-size:12px;vertical-align:-webkit-baseline-middle'>" + feature.properties[feature.effectiveStyle.innerTextProperty] + "</span>";
            }
            else if (iconUri != null) {
                // Must the iconUri be formatted?
                if (iconUri != null && iconUri.indexOf('{') >= 0)
                    iconUri = Helpers.convertStringFormat(feature, iconUri);
                html += '<img src=\'' + iconUri + '\' style=\'width:' + (feature.effectiveStyle.iconWidth) + 'px;height:' + (feature.effectiveStyle.iconHeight) + 'px;display:block';
                if (feature.effectiveStyle.rotate && feature.effectiveStyle.rotate > 0)
                    html += ';transform:rotate(' + feature.effectiveStyle.rotate + 'deg)';
                html += '\' />';
            }
            html += '</div>';
            var iconHtml = {};
            iconHtml['html'] = html;
            iconHtml['iconPlusBorderWidth'] = iconPlusBorderWidth;
            iconHtml['iconPlusBorderHeight'] = iconPlusBorderHeight;
            return iconHtml;
        }
        Helpers.createIconHtml = createIconHtml;
    })(Helpers = csComp.Helpers || (csComp.Helpers = {}));
})(csComp || (csComp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var csComp;
(function (csComp) {
    var Helpers;
    (function (Helpers) {
        var PieData = (function () {
            function PieData() {
            }
            return PieData;
        })();
        Helpers.PieData = PieData;
        var AsterPieData = (function (_super) {
            __extends(AsterPieData, _super);
            function AsterPieData() {
                _super.apply(this, arguments);
            }
            return AsterPieData;
        })(PieData);
        Helpers.AsterPieData = AsterPieData;
        var Plot = (function () {
            function Plot() {
            }
            /**
             * Draw a histogram, and, if xy is specified, a line plot of x versus y (e.g. a scoring function).
             */
            Plot.drawHistogram = function (values, options) {
                var id = (options != null && options.hasOwnProperty("id")) ? options.id : "myHistogram";
                var numberOfBins = (options != null && options.hasOwnProperty("numberOfBins")) ? options.numberOfBins : 10;
                var width = (options != null && options.hasOwnProperty("width")) ? options.width : 200;
                var height = (options != null && options.hasOwnProperty("height")) ? options.height : 150;
                var xLabel = (options != null && options.hasOwnProperty("xLabel")) ? options.xLabel : "";
                var selectedValue = (options != null && options.hasOwnProperty("selectedValue")) ? options.selectedValue : null;
                // var yLabel       = (options != null && options.hasOwnProperty('yLabel'))        ? options.yLabel        : '#';
                var margin = { top: 0, right: 6, bottom: 24, left: 6 };
                width -= margin.left + margin.right,
                    height -= margin.top + margin.bottom;
                var svgId = 'the_SVG_ID';
                Plot.clearSvg(svgId);
                if (values.length < numberOfBins)
                    return;
                // A formatter for counts.
                var formatCount = d3.format(",.0f");
                var max = Math.max.apply(null, values);
                var min = Math.min.apply(null, values);
                var range = max - min;
                // Scale the x-range, so we don't have such long numbers
                var scale = Plot.getScale(range / numberOfBins, max);
                // var scale = range >= 10
                //    ? Math.max(d3.round(range, 0), d3.round(max, 0)).toString().length - 2 // 100 -> 1
                //    : -2;
                var scaleFactor = 0;
                if (Math.abs(scale) > 0) {
                    xLabel += " (x10^" + scale + ")";
                    scaleFactor = Math.pow(10, scale);
                }
                var tickFormatter = function (value) {
                    return scaleFactor > 0
                        ? d3.round(value / scaleFactor, 0).toString()
                        : d3.round(value, 0).toString();
                };
                var tempScale = d3.scale.linear().domain([0, numberOfBins]).range([min, max]);
                var tickArray = d3.range(numberOfBins + 1).map(tempScale);
                var x = d3.scale.linear()
                    .domain([min, max])
                    .range([0, width]);
                var xAxis = d3.svg.axis()
                    .scale(x)
                    .tickValues(tickArray)
                    .tickFormat(tickFormatter)
                    .orient("bottom");
                // Generate a histogram using numberOfBins uniformly-spaced bins.
                var data = d3.layout.histogram().bins(numberOfBins)(values);
                var y = d3.scale.linear()
                    .domain([0, d3.max(data, function (d) { return d.y; })])
                    .range([height, 0]);
                var svg = d3.select("#" + id)
                    .append("svg")
                    .attr("id", svgId)
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .attr("style", "display: block; margin: 0 auto;")
                    .append("g")
                    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                var bar = svg.selectAll(".bar")
                    .data(data)
                    .enter().append("g")
                    .attr("class", function (d, i) {
                    return selectedValue != null && (d.x < selectedValue && selectedValue < d.x + data[i].dx)
                        ? "bar highlight"
                        : "bar";
                })
                    .attr("transform", function (d) { return "translate(" + x(d.x) + "," + y(d.y) + ")"; });
                bar.append("rect")
                    .attr("x", 1)
                    .attr("width", x(min + data[0].dx) - 1)
                    .attr("height", function (d) { return height - y(d.y); });
                var conditionalFormatCounter = function (value) {
                    return (height - y(value) > 6)
                        ? formatCount(value)
                        : "";
                };
                // Text (count) inside the bins
                bar.append("text")
                    .attr("dy", ".75em")
                    .attr("y", 6)
                    .attr("x", x(min + data[0].dx) / 2)
                    .attr("text-anchor", "middle")
                    .text(function (d) { return conditionalFormatCounter(d.y); });
                // x-label
                svg.append("text")
                    .attr("class", "x label")
                    .attr("text-anchor", "end")
                    .attr("x", width)
                    .attr("y", height / 2 - 6)
                    .text(xLabel);
                svg.append("g")
                    .attr("class", "x axis")
                    .attr("transform", "translate(0," + height + ")")
                    .call(xAxis);
            };
            Plot.getScale = function (stepSize, max) {
                for (var sf = -5; sf < 5; sf++) {
                    var scale = Math.pow(10, sf);
                    var ls = d3.round(stepSize / scale, 0);
                    var lm = d3.round(max / scale, 0);
                    if (0 < ls && ls < 10 && 0 < lm && lm < 100)
                        return sf;
                }
                return 0;
            };
            Plot.drawMcaPlot = function (values, options) {
                var id = (options != null && options.hasOwnProperty("id")) ? options.id : "myHistogram";
                var numberOfBins = (options != null && options.hasOwnProperty("numberOfBins")) ? options.numberOfBins : 10;
                var width = (options != null && options.hasOwnProperty("width")) ? options.width : 200;
                var height = (options != null && options.hasOwnProperty("height")) ? options.height : 150;
                var xLabel = (options != null && options.hasOwnProperty("xLabel")) ? options.xLabel : "";
                var xyData = (options != null && options.hasOwnProperty("xy")) ? options.xy : null;
                var featureValue = (options != null && options.hasOwnProperty("featureValue")) ? options.featureValue : null;
                // var yLabel       = (options != null && options.hasOwnProperty('yLabel'))       ? options.yLabel       : '#';
                var margin = { top: 0, right: 6, bottom: 24, left: 6 };
                width -= margin.left + margin.right,
                    height -= margin.top + margin.bottom;
                var svgId = id + "_histogram";
                Plot.clearSvg(svgId);
                // A formatter for counts.
                var formatCount = d3.format(",.0f");
                var max, min, range;
                if (xyData != null) {
                    max = xyData.x[xyData.x.length - 1];
                    min = xyData.x[0];
                    range = max - min;
                    max += range / 10;
                    min -= range / 10;
                }
                else {
                    max = Math.max.apply(null, values);
                    min = Math.min.apply(null, values);
                }
                range = max - min;
                // Scale the x-range, so we don't have such long numbers
                var scale = Plot.getScale(range / numberOfBins, max);
                // var scale = range >= 10
                //    ? Math.max(d3.round(range, 0), d3.round(max, 0)).toString().length - 2 // 100 -> 1
                //    : -2;
                var scaleFactor = 0;
                xLabel += " (";
                if (Math.abs(scale) > 0) {
                    xLabel += "x10^" + scale;
                    scaleFactor = Math.pow(10, scale);
                }
                var tickFormatter = function (value) {
                    return scaleFactor > 0
                        ? d3.round(value / scaleFactor, 0).toString()
                        : d3.round(value, 0).toString();
                };
                var tempScale = d3.scale.linear().domain([0, numberOfBins]).range([min, max]);
                var tickArray = d3.range(numberOfBins + 1).map(tempScale);
                var x = d3.scale.linear()
                    .domain([min, max])
                    .range([0, width]);
                var xAxis = d3.svg.axis()
                    .scale(x)
                    .tickValues(tickArray)
                    .tickFormat(tickFormatter)
                    .orient("bottom");
                // Generate a histogram using numberOfBins uniformly-spaced bins.
                var valuesInRange = values.filter(function (value) { return (min <= value && value <= max); });
                if (valuesInRange.length < 3) {
                    var svg1 = d3.select("#" + id)
                        .append("svg")
                        .attr("id", svgId)
                        .attr("width", width + margin.left + margin.right)
                        .attr("height", height + margin.top + margin.bottom)
                        .append("g")
                        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                    svg1.append("text")
                        .attr("class", "x label")
                        .attr("text-anchor", "center")
                        .attr("x", width / 2)
                        .attr("y", height / 2 + 6)
                        .text("\u03A7 NO DATA IN RANGE");
                    return;
                }
                xLabel += " \u03A3" + valuesInRange.length;
                var data = d3.layout.histogram().bins(numberOfBins)(valuesInRange);
                var y = d3.scale.linear()
                    .domain([0, d3.max(data, function (d) { return d.y; })])
                    .range([height, 0]);
                var svg = d3.select("#" + id)
                    .append("svg")
                    .attr("id", svgId)
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .attr("style", "display: block; margin: 0 auto;")
                    .append("g")
                    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                var bar = svg.selectAll(".bar")
                    .data(data)
                    .enter().append("g")
                    .attr("class", "bar")
                    .attr("transform", function (d) { return "translate(" + x(d.x) + "," + y(d.y) + ")"; });
                bar.append("rect")
                    .attr("x", 1)
                    .attr("width", x(min + data[0].dx) - 1)
                    .attr("height", function (d) { return height - y(d.y); });
                var conditionalFormatCounter = function (value) {
                    return (height - y(value) > 6)
                        ? formatCount(value)
                        : "";
                };
                // Text (count) inside the bins
                bar.append("text")
                    .attr("dy", ".75em")
                    .attr("y", 6)
                    .attr("x", x(min + data[0].dx) / 2)
                    .attr("text-anchor", "middle")
                    .text(function (d) { return conditionalFormatCounter(d.y); });
                // x-label
                xLabel += ")";
                svg.append("text")
                    .attr("class", "x label")
                    .attr("text-anchor", "end")
                    .attr("x", width)
                    .attr("y", height / 2 - 6)
                    .text(xLabel);
                svg.append("g")
                    .attr("class", "x axis")
                    .attr("transform", "translate(0," + height + ")")
                    .call(xAxis);
                if (xyData == null)
                    return;
                // Draw line chart
                var xy = [];
                xy.push({ x: min, y: xyData.y[0] });
                for (var i = 0; i < xyData.x.length; i++) {
                    xy.push({ x: xyData.x[i], y: xyData.y[i] });
                }
                xy.push({ x: max, y: xyData.y[xyData.y.length - 1] });
                var y2 = d3.scale.linear()
                    .domain([0, d3.max(xy, function (d) { return d.y; })])
                    .range([height - 1, 1]);
                var lineFunc = d3.svg.line()
                    .x(function (d) { return x(d.x); })
                    .y(function (d) { return y2(d.y); })
                    .interpolate("linear");
                svg.append("svg:path")
                    .attr("d", lineFunc(xy))
                    .attr("stroke", "red")
                    .attr("stroke-width", 2)
                    .attr("fill", "none");
                if (featureValue == null)
                    return;
                // Draw feature on the score
                xy = [];
                xy.push({ x: featureValue, y: 0 });
                xy.push({ x: featureValue, y: height });
                svg.append("svg:path")
                    .attr("d", lineFunc(xy))
                    .attr("stroke", "blue")
                    .attr("stroke-width", 2)
                    .attr("fill", "none");
            };
            /**
            * Draw a Pie chart.
            */
            Plot.drawPie = function (pieRadius, data, parentId, colorScale, svgId) {
                if (parentId === void 0) { parentId = 'mcaPieChart'; }
                if (colorScale === void 0) { colorScale = 'Reds'; }
                if (svgId === void 0) { svgId = 'the_SVG_ID'; }
                Plot.clearSvg(svgId);
                if (!data)
                    return;
                var width = pieRadius, height = pieRadius, radius = Math.min(width, height) / 2, innerRadius = 0;
                var pie = d3.layout.pie()
                    .sort(null)
                    .value(function (d) { return d.weight; });
                var tip = d3.tip()
                    .attr('class', 'd3-tip')
                    .offset([0, 0])
                    .html(function (d) { return '<strong>' + d.data.label + ": </strong><span style='color:orangered'>" +
                    Math.round(d.data.weight * 100) + "%</span>"; });
                var arc = d3.svg.arc()
                    .innerRadius(innerRadius)
                    .outerRadius(radius);
                var outlineArc = d3.svg.arc()
                    .innerRadius(innerRadius)
                    .outerRadius(radius);
                var svg = d3.select('#' + parentId)
                    .append("svg")
                    .attr("id", svgId)
                    .attr("width", width)
                    .attr("height", height)
                    .attr("style", "display: block; margin: 0 auto;")
                    .append("g")
                    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
                // svg.call(tip);
                var colors = chroma.scale(colorScale).domain([0, data.length - 1], data.length);
                var path = svg.selectAll(".solidArc")
                    .data(pie(data))
                    .enter().append("path")
                    .attr("fill", function (d, i) { return d.data.color || colors(i).hex(); })
                    .attr("class", "solidArc")
                    .attr("stroke", "gray")
                    .attr("d", arc)
                    .on('mouseover', function (d, i) {
                    tip.show(d, i);
                })
                    .on('mouseout', tip.hide);
                var outerPath = svg.selectAll(".outlineArc")
                    .data(pie(data))
                    .enter().append("path")
                    .attr("fill", "none")
                    .attr("stroke", "gray")
                    .attr("class", "outlineArc")
                    .attr("d", outlineArc);
            };
            /**
            * Draw an Aster Pie chart, i.e. a pie chart with varying radius depending on the score,
            * where the maximum score of 100 equals the pie radius.
            * See http://bl.ocks.org/bbest/2de0e25d4840c68f2db1
            */
            Plot.drawAsterPlot = function (pieRadius, data, parentId, colorScale, svgId) {
                if (parentId === void 0) { parentId = 'mcaPieChart'; }
                if (colorScale === void 0) { colorScale = 'Reds'; }
                if (svgId === void 0) { svgId = 'the_SVG_ID'; }
                Plot.clearSvg(svgId);
                if (!data)
                    return;
                var width = pieRadius, height = pieRadius, radius = Math.min(width, height) / 2, innerRadius = 0.3 * radius;
                var pie = d3.layout.pie()
                    .sort(null)
                    .value(function (d) { return d.weight; });
                var tip = d3.tip()
                    .attr('class', 'd3-tip')
                    .offset([0, 0])
                    .html(function (d) { return '<strong>' + d.data.label + ": </strong> <span style='color:orangered'>" +
                    Math.round(d.data.weight * 100) + "% x " + Math.round(d.data.score) + "&nbsp; = " +
                    Math.round(d.data.weight * d.data.score) + "</span>"; });
                var arc = d3.svg.arc()
                    .innerRadius(innerRadius)
                    .outerRadius(function (d) { return (radius - innerRadius) * (d.data.score / 100.0) + innerRadius; });
                var outlineArc = d3.svg.arc()
                    .innerRadius(innerRadius)
                    .outerRadius(radius);
                var svg = d3.select('#' + parentId)
                    .append("svg")
                    .attr("id", svgId)
                    .attr("width", width)
                    .attr("height", height)
                    .attr("style", "display: block; margin: 0 auto;")
                    .append("g")
                    .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
                try {
                    svg.call(tip);
                }
                catch (err) {
                    console.log("Error: " + err.message);
                }
                var colors = chroma.scale(colorScale).domain([0, data.length - 1], data.length);
                var path = svg.selectAll(".solidArc")
                    .data(pie(data))
                    .enter().append("path")
                    .attr("fill", function (d, i) { return d.data.color || colors(i).hex(); })
                    .attr("class", "solidArc")
                    .attr("stroke", "gray")
                    .attr("d", arc)
                    .on('mouseover', function (d, i) {
                    tip.show(d, i);
                    // $rootScope.$broadcast('tooltipShown', { id: d.data.id });
                })
                    .on('mouseout', tip.hide);
                var outerPath = svg.selectAll(".outlineArc")
                    .data(pie(data))
                    .enter().append("path")
                    .attr("fill", "none")
                    .attr("stroke", "gray")
                    .attr("class", "outlineArc")
                    .attr("d", outlineArc);
                // calculate the weighted mean score
                var totalWeight = 0;
                var totalScore = 0;
                data.forEach(function (p) {
                    totalWeight += p.weight;
                    totalScore += p.weight * p.score;
                });
                svg.append("svg:text")
                    .attr("class", "aster-score")
                    .attr("dy", ".35em")
                    .attr("text-anchor", "middle") // text-align: right
                    .text(Math.round(totalScore / totalWeight));
            };
            Plot.clearSvg = function (svgId) {
                var svgElement = d3.select('#' + svgId);
                if (svgElement)
                    svgElement.remove();
            };
            Plot.pieColors = ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"];
            return Plot;
        })();
        Helpers.Plot = Plot;
    })(Helpers = csComp.Helpers || (csComp.Helpers = {}));
})(csComp || (csComp = {}));

var csComp;
(function (csComp) {
    var StringExt;
    (function (StringExt) {
        function isNullOrEmpty(s) {
            return !isNumber(s) && !s;
        }
        StringExt.isNullOrEmpty = isNullOrEmpty;
        /**
         * String formatting
         * 'Added {0} by {1} to your collection'.f(title, artist)
         * 'Your balance is {0} USD'.f(77.7)
         */
        function format(s) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var i = args.length;
            while (i--) {
                // "gm" = RegEx options for Global search (more than one instance) and for Multiline search
                s = s.replace(new RegExp('\\{' + i + '\\}', 'gm'), args[i]);
            }
            return s;
        }
        StringExt.format = format;
        ;
        /*
         * Returns true if we are dealing with a number, false otherwise.
         */
        function isDate(n) {
            return moment(n, moment.ISO_8601).isValid();
        }
        StringExt.isDate = isDate;
        /*
         * Returns true if we are dealing with a number, false otherwise.
         */
        function isNumber(n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
        }
        StringExt.isNumber = isNumber;
        /*
         * Returns true if we are dealing with a boolean, false otherwise.
         */
        function isBoolean(s) {
            return s === 'true' || s === 'false';
            if (typeof s === 'boolean')
                return true;
        }
        StringExt.isBoolean = isBoolean;
        /*
         * Returns true if we are dealing with a array, false otherwise.
         */
        function isArray(s) {
            return s && s.constructor === Array;
        }
        StringExt.isArray = isArray;
        /*
         * Returns true if we are dealing with a bbcode, false otherwise.
         */
        function isBbcode(s) {
            return false;
            if (s == null)
                return false;
            return s.indexOf("[b]") > 0 || s.indexOf("[i]") > 0 || s.indexOf("[url") > 0;
        }
        StringExt.isBbcode = isBbcode;
    })(StringExt = csComp.StringExt || (csComp.StringExt = {}));
})(csComp || (csComp = {}));

var StringFormat;
(function (StringFormat) {
    /**
     * Config
     */
    var moduleName = 'csComp';
    try {
        StringFormat.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        StringFormat.myModule = angular.module(moduleName, []);
    }
    /**
     * Directive to display a feature's properties in a panel.
     *
     * @seealso          : http://www.youtube.com/watch?v=gjJ5vLRK8R8&list=UUGD_0i6L48hucTiiyhb5QzQ
     * @seealso          : http://plnkr.co/edit/HyBP9d?p=preview
     */
    StringFormat.myModule.directive('stringy', ['$compile',
        function ($compile) {
            return {
                require: "ngModel",
                terminal: false,
                restrict: 'A',
                scope: {},
                link: function (scope, element, attr, ngModel) {
                    scope.$watch(function () {
                        return ngModel.$modelValue;
                    }, function (modelValue) {
                        element[0].innerText = String.format("{0:0,0}", ngModel.$modelValue);
                    });
                }
            };
        }
    ]);
})(StringFormat || (StringFormat = {}));

/*!
 * string_score.js: String Scoring Algorithm 0.1.22
 *
 * http://joshaven.com/string_score
 * https://github.com/joshaven/string_score
 *
 * Copyright (C) 2009-2014 Joshaven Potter <yourtech@gmail.com>
 * Special thanks to all of the contributors listed here https://github.com/joshaven/string_score
 * MIT License: http://opensource.org/licenses/MIT
 *
 * Date: Tue Mar 1 2011
 * Updated: Tue Mar 10 2015
*/
/*jslint nomen:true, white:true, browser:true,devel:true */
/**
 * Scores a string against another string.
 *    'Hello World'.score('he');         //=> 0.5931818181818181
 *    'Hello World'.score('Hello');    //=> 0.7318181818181818
 */
String.prototype.score = function (word, fuzziness) {
    'use strict';
    // If the string is equal to the word, perfect match.
    if (this === word) {
        return 1;
    }
    //if it's not a perfect match and is empty return 0
    if (word === "") {
        return 0;
    }
    var runningScore = 0, charScore, finalScore, string = this, lString = string.toLowerCase(), strLength = string.length, lWord = word.toLowerCase(), wordLength = word.length, idxOf, startAt = 0, fuzzies = 1, fuzzyFactor, i;
    // Cache fuzzyFactor for speed increase
    if (fuzziness) {
        fuzzyFactor = 1 - fuzziness;
    }
    // Walk through word and add up scores.
    // Code duplication occurs to prevent checking fuzziness inside for loop
    if (fuzziness) {
        for (i = 0; i < wordLength; i += 1) {
            // Find next first case-insensitive match of a character.
            idxOf = lString.indexOf(lWord[i], startAt);
            if (idxOf === -1) {
                fuzzies += fuzzyFactor;
            }
            else {
                if (startAt === idxOf) {
                    // Consecutive letter & start-of-string Bonus
                    charScore = 0.7;
                }
                else {
                    charScore = 0.1;
                    // Acronym Bonus
                    // Weighing Logic: Typing the first character of an acronym is as if you
                    // preceded it with two perfect character matches.
                    if (string[idxOf - 1] === ' ') {
                        charScore += 0.8;
                    }
                }
                // Same case bonus.
                if (string[idxOf] === word[i]) {
                    charScore += 0.1;
                }
                // Update scores and startAt position for next round of indexOf
                runningScore += charScore;
                startAt = idxOf + 1;
            }
        }
    }
    else {
        for (i = 0; i < wordLength; i += 1) {
            idxOf = lString.indexOf(lWord[i], startAt);
            if (-1 === idxOf) {
                return 0;
            }
            if (startAt === idxOf) {
                charScore = 0.7;
            }
            else {
                charScore = 0.1;
                if (string[idxOf - 1] === ' ') {
                    charScore += 0.8;
                }
            }
            if (string[idxOf] === word[i]) {
                charScore += 0.1;
            }
            runningScore += charScore;
            startAt = idxOf + 1;
        }
    }
    // Reduce penalty for longer strings.
    finalScore = 0.5 * (runningScore / strLength + runningScore / wordLength) / fuzzies;
    if ((lWord[0] === lString[0]) && (finalScore < 0.85)) {
        finalScore += 0.15;
    }
    return finalScore;
};

var csComp;
(function (csComp) {
    var Helpers;
    (function (Helpers) {
        function getColorFromStringValue(v, gs) {
            if (gs.activeLegend) {
                var defaultcolor = '#000000';
                var l = gs.activeLegend;
                var s = l.id;
                var n = l.legendEntries.length;
                if (n == 0)
                    return (defaultcolor);
                if (l.legendKind.toLowerCase() == 'discretestrings') {
                    var i = 0;
                    while (i < n) {
                        var e = l.legendEntries[i];
                        if (v == e.stringValue) {
                            return e.color;
                        }
                        i++;
                    }
                    return defaultcolor;
                }
                return defaultcolor;
            }
        }
        Helpers.getColorFromStringValue = getColorFromStringValue;
        function getImageUri(ft) {
            var iconUri = (ft && ft.style && ft.style.iconUri) ? ft.style.iconUri : "cs/images/marker.png";
            if (iconUri.indexOf('{') >= 0)
                iconUri = iconUri.replace('{', '').replace('}', '');
            if (ft && ft.style != null && ft.style.drawingMode != null && ft.style.drawingMode.toLowerCase() != "point") {
                if (iconUri.indexOf('_Media') < 0)
                    return iconUri;
                else
                    return "cs/images/polygon.png";
            }
            else if (ft && ft.style != null && iconUri != null) {
                return iconUri;
            }
            else {
                return "cs/images/marker.png";
            }
        }
        Helpers.getImageUri = getImageUri;
        function getColorFromStringLegend(v, l) {
            var defaultcolor = '#000000';
            var s = l.id;
            var n = l.legendEntries.length;
            if (n === 0)
                return (defaultcolor);
            if (l.legendKind.toLowerCase() === 'discretestrings') {
                var i = 0;
                while (i < n) {
                    var e = l.legendEntries[i];
                    if (v === e.stringValue) {
                        return e.color;
                    }
                    i++;
                }
                return defaultcolor;
            }
            return defaultcolor;
        }
        Helpers.getColorFromStringLegend = getColorFromStringLegend;
        function getColorFromLegend(v, l, defaultcolor) {
            if (defaultcolor === void 0) { defaultcolor = '#000000'; }
            var s = l.id;
            var n = l.legendEntries.length;
            if (n == 0)
                return (defaultcolor);
            var e1 = l.legendEntries[0]; // first
            var e2 = l.legendEntries[n - 1]; // last
            if (l.legendKind.toLowerCase() === 'interpolated') {
                // interpolate between two colors
                if (v < e1.value)
                    return e1.color;
                if (v > e2.value)
                    return e2.color;
                var i = 0;
                while (i < n - 1) {
                    e1 = l.legendEntries[i];
                    e2 = l.legendEntries[i + 1];
                    if ((v >= e1.value) && (v <= e2.value)) {
                        var bezInterpolator = chroma.interpolate.bezier([e1.color, e2.color]);
                        var r = bezInterpolator((v - e1.value) / (e2.value - e1.value)).hex();
                        return r;
                    }
                    i++;
                }
                return (defaultcolor);
            }
            if (l.legendKind.toLowerCase() === 'discrete') {
                if (v < e1.interval.min)
                    return l.legendEntries[0].color;
                if (v > e2.interval.max)
                    return l.legendEntries[n - 1].color;
                var i = 0;
                while (i < n) {
                    var e = l.legendEntries[i];
                    if ((v >= e.interval.min) && (v <= e.interval.max)) {
                        return e.color;
                    }
                    i++;
                }
                return defaultcolor;
            }
            return defaultcolor;
        }
        Helpers.getColorFromLegend = getColorFromLegend;
        function getColor(v, gs) {
            if (gs.activeLegend) {
                return getColorFromLegend(v, gs.activeLegend);
            }
            if (v > gs.info.max)
                return gs.colors[gs.colors.length - 1];
            if (v < gs.info.min)
                return gs.colors[0];
            //var bezInterpolator = chroma.interpolate.bezier(gs.colors);
            //var r = bezInterpolator((v - gs.info.sdMin) / (gs.info.sdMax - gs.info.sdMin)).hex();
            //return r;
            var color = d3.scale.linear()
                .domain([gs.info.min, gs.info.max]) //domain and range should have the same arraylength!!!
                .range(gs.colors);
            var hexColor = color(v).toString();
            return hexColor;
        }
        Helpers.getColor = getColor;
        /**
         * Extract a valid color string, without transparency.
         */
        function getColorString(color, defaultColor) {
            if (defaultColor === void 0) { defaultColor = '#f00'; }
            if (!color)
                return defaultColor;
            if (color.length == 4 || color.length == 7)
                return color;
            if (color.length === 9)
                return '#' + color.substr(3, 6);
            return defaultColor;
        }
        Helpers.getColorString = getColorString;
    })(Helpers = csComp.Helpers || (csComp.Helpers = {}));
})(csComp || (csComp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var FSM;
(function (FSM) {
    /**
     * Transition grouping to faciliate fluent api
     * @class Transitions<T>
     */
    var Transitions = (function () {
        function Transitions(fsm) {
            this.fsm = fsm;
        }
        /**
         * Specify the end state(s) of a transition function
         * @method to
         * @param ...states {T[]}
         */
        Transitions.prototype.to = function () {
            var states = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                states[_i - 0] = arguments[_i];
            }
            this.toStates = states;
            return this.fsm.addTransitions(this);
        };
        Transitions.prototype.toAny = function (states) {
            var toStates = [];
            for (var s in states) {
                if (states.hasOwnProperty(s)) {
                    toStates.push(states[s]);
                }
            }
            this.toStates = toStates;
            this.fsm.addTransitions(this);
        };
        return Transitions;
    })();
    FSM.Transitions = Transitions;
    /**
     * Internal representation of a transition function
     * @class TransitionFunction<T>
     */
    var TransitionFunction = (function () {
        // public events: {
        //     [trigger: number]: {
        //         callback: Function,
        //         args: any[]
        //     }
        // }[];
        function TransitionFunction(fsm, from, to) {
            this.fsm = fsm;
            this.from = from;
            this.to = to;
        }
        return TransitionFunction;
    })();
    FSM.TransitionFunction = TransitionFunction;
    var TransitionFunctions = (function (_super) {
        __extends(TransitionFunctions, _super);
        function TransitionFunctions(fsm) {
            _super.call(this);
            this.fsm = fsm;
        }
        TransitionFunctions.prototype.on = function (trigger, callback) {
            var _this = this;
            this.forEach(function (t) {
                if (callback)
                    _this.fsm.on(t.to, callback);
                _this.fsm.addEvent(trigger, t.from, t.to);
            });
        };
        return TransitionFunctions;
    })(Array);
    FSM.TransitionFunctions = TransitionFunctions;
    /***
     * A simple finite state machine implemented in TypeScript, the templated argument is meant to be used
     * with an enumeration.
     * @class FiniteStateMachine<T>
     */
    var FiniteStateMachine = (function () {
        /**
         * @constructor
         * @param startState {T} Intial starting state
         */
        function FiniteStateMachine(startState) {
            this._transitionFunctions = [];
            this._onCallbacks = {};
            this._exitCallbacks = {};
            this._enterCallbacks = {};
            this._triggers = {};
            this.currentState = startState;
            this._startState = startState;
        }
        FiniteStateMachine.prototype.addTransitions = function (fcn) {
            var _this = this;
            var newTransitions = new TransitionFunctions(this);
            fcn.fromStates.forEach(function (from) {
                fcn.toStates.forEach(function (to) {
                    // self transitions are invalid and don't add duplicates
                    if (from !== to && !_this._validTransition(from, to)) {
                        newTransitions.push(new TransitionFunction(_this, from, to));
                    }
                });
            });
            newTransitions.forEach(function (t) { return _this._transitionFunctions.push(t); });
            return newTransitions;
        };
        FiniteStateMachine.prototype.addEvent = function (trigger, fromState, toState) {
            var fr = fromState.toString();
            if (!this._triggers[fr])
                this._triggers[fr] = {};
            this._triggers[fr][trigger.toString()] = toState;
        };
        FiniteStateMachine.prototype.trigger = function (trigger) {
            if (typeof trigger === 'undefined')
                return;
            var t = trigger.toString();
            var current = this.currentState.toString();
            if (!this._triggers.hasOwnProperty(current) || !this._triggers[current].hasOwnProperty(t))
                return;
            this.go(this._triggers[current][t]);
        };
        /**
         * Listen for the transition to this state and fire the associated callback
         * @method on
         * @param state {T} State to listen to
         * @param callback {fcn} Callback to fire
         */
        FiniteStateMachine.prototype.on = function (state, callback) {
            var key = state.toString();
            if (!this._onCallbacks[key]) {
                this._onCallbacks[key] = [];
            }
            this._onCallbacks[key].push(callback);
            return this;
        };
        /**
            * Listen for the transition to this state and fire the associated callback, returning
            * false in the callback will block the transition to this state.
            * @method on
            * @param state {T} State to listen to
            * @param callback {fcn} Callback to fire
            */
        FiniteStateMachine.prototype.onEnter = function (state, callback) {
            var key = state.toString();
            if (!this._enterCallbacks[key]) {
                this._enterCallbacks[key] = [];
            }
            this._enterCallbacks[key].push(callback);
            return this;
        };
        /**
            * Listen for the transition to this state and fire the associated callback, returning
            * false in the callback will block the transition from this state.
            * @method on
            * @param state {T} State to listen to
            * @param callback {fcn} Callback to fire
            */
        FiniteStateMachine.prototype.onExit = function (state, callback) {
            var key = state.toString();
            if (!this._exitCallbacks[key]) {
                this._exitCallbacks[key] = [];
            }
            this._exitCallbacks[key].push(callback);
            return this;
        };
        /**
            * Declares the start state(s) of a transition function, must be followed with a '.to(...endStates)'
            * @method from
            * @param ...states {T[]}
            */
        FiniteStateMachine.prototype.from = function () {
            var states = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                states[_i - 0] = arguments[_i];
            }
            var _transition = new Transitions(this);
            _transition.fromStates = states;
            return _transition;
        };
        FiniteStateMachine.prototype.fromAny = function (states) {
            var fromStates = [];
            for (var s in states) {
                if (states.hasOwnProperty(s)) {
                    fromStates.push(states[s]);
                }
            }
            var _transition = new Transitions(this);
            _transition.fromStates = fromStates;
            return _transition;
        };
        FiniteStateMachine.prototype._validTransition = function (from, to) {
            return this._transitionFunctions.some(function (tf) {
                return (tf.from === from && tf.to === to);
            });
        };
        /**
          * Check whether a transition to a new state is valide
          * @method canGo
          * @param state {T}
          */
        FiniteStateMachine.prototype.canGo = function (state) {
            return this.currentState === state || this._validTransition(this.currentState, state);
        };
        /**
          * Transition to another valid state
          * @method go
          * @param state {T}
          */
        FiniteStateMachine.prototype.go = function (state) {
            if (!this.canGo(state)) {
                throw new Error('Error no transition function exists from state ' + this.currentState.toString() + ' to ' + state.toString());
            }
            this._transitionTo(state);
        };
        /**
         * This method is availble for overridding for the sake of extensibility.
         * It is called in the event of a successful transition.
         * @method onTransition
         * @param from {T}
         * @param to {T}
         */
        FiniteStateMachine.prototype.onTransition = function (from, to) {
            // pass, does nothing untill overridden
        };
        /**
         * Reset the finite state machine back to the start state, DO NOT USE THIS AS A SHORTCUT for a transition.
         * This is for starting the fsm from the beginning.
         * @method reset
         */
        FiniteStateMachine.prototype.reset = function () {
            this.currentState = this._startState;
        };
        FiniteStateMachine.prototype._transitionTo = function (state) {
            var _this = this;
            if (!this._exitCallbacks[this.currentState.toString()]) {
                this._exitCallbacks[this.currentState.toString()] = [];
            }
            if (!this._enterCallbacks[state.toString()]) {
                this._enterCallbacks[state.toString()] = [];
            }
            if (!this._onCallbacks[state.toString()]) {
                this._onCallbacks[state.toString()] = [];
            }
            var canExit = this._exitCallbacks[this.currentState.toString()].reduce(function (accum, next) {
                return accum && next.call(_this, state);
            }, true);
            var canEnter = this._enterCallbacks[state.toString()].reduce(function (accum, next) {
                return accum && next.call(_this, _this.currentState);
            }, true);
            if (canExit && canEnter) {
                var old = this.currentState;
                this.currentState = state;
                this._onCallbacks[this.currentState.toString()].forEach(function (fcn) {
                    fcn.call(_this, old, state);
                });
                this.onTransition(old, state);
            }
        };
        return FiniteStateMachine;
    })();
    FSM.FiniteStateMachine = FiniteStateMachine;
})(FSM || (FSM = {}));

var csComp;
(function (csComp) {
    (function (FileType) {
        FileType[FileType["Js"] = 0] = "Js";
        FileType[FileType["Css"] = 1] = "Css";
    })(csComp.FileType || (csComp.FileType = {}));
    var FileType = csComp.FileType;
    var Utils = (function () {
        function Utils() {
        }
        Utils.twoDigitStr = function (v) {
            var s;
            s = v.toString();
            if (s.length === 1) {
                s = '0' + s;
            }
            return (s);
        };
        ;
        /**
        * Load a JavaScript or CSS file dynamically by adding it to the end of the HEAD section in your document.
        * See also: http://www.javascriptkit.com/javatutors/loadjavascriptcss.shtml
        */
        Utils.loadJsCssfile = function (filename, filetype, callback) {
            if (Utils.loadedFiles.indexOf(filename) > 0)
                return;
            Utils.loadedFiles.push(filename);
            switch (filetype) {
                case FileType.Js:
                    var fileRef = document.createElement('script');
                    fileRef.setAttribute("type", "text/javascript");
                    fileRef.setAttribute("src", filename);
                    if (callback) {
                        fileRef.onload = function (evt) {
                            callback(evt);
                        };
                    }
                    document.getElementsByTagName("head")[0].appendChild(fileRef);
                    break;
                case FileType.Css:
                    var linkRef = document.createElement("link");
                    linkRef.setAttribute("rel", "stylesheet");
                    linkRef.setAttribute("type", "text/css");
                    linkRef.setAttribute("href", filename);
                    if (callback) {
                        linkRef.onload = function (evt) {
                            callback(evt);
                        };
                    }
                    document.getElementsByTagName("head")[0].appendChild(linkRef);
                    break;
            }
        };
        Utils.loadedFiles = [];
        return Utils;
    })();
    csComp.Utils = Utils;
})(csComp || (csComp = {}));

var Translations;
(function (Translations) {
    var English = (function () {
        function English() {
        }
        English.locale = {
            CANCEL_BTN: 'Cancel',
            OK_BTN: 'OK',
            FROM: 'from',
            TO: 'to',
            NAVIGATE: 'Start',
            CREATE_SCATTER: 'Create scatter with',
            EXPAND_ALL: 'Expand all',
            COLLAPSE_ALL: 'Collapse all',
            SELECT_ALL: 'Select all',
            DESELECT_ALL: 'Deselect all',
            CHOOSE_DROPDOWN: 'Choose...',
            ENABLE_LOCATION_FILTER: 'Enable location filter',
            DISABLE_LOCATION_FILTER: 'Disable location filter',
            SELECT_A_FEATURE: 'Select a feature',
            SELECT_FEATURE_FOR_WIDGET: 'Please select a feature to show the widget.',
            SELECT_FEATURE_FOR_STYLE: 'Please select a feature to before setting the style.',
            NO_RELATIONS_FOUND: 'No relations can be shown for the selected feature. Either the zoom level is too low, there are too many features in the view or there are no relations defined.',
            BASESTYLES: 'Baselayers',
            MAP: 'Maps',
            MAP_LABEL: 'Map',
            TABLE_LABEL: 'Table',
            LAYERS: 'Layers',
            DIRECTORY: 'Available layers',
            CREATELAYER: 'Create new layer',
            ADDFEATURES: 'Add items',
            ADDTYPE: 'Add new type',
            DONE: 'done',
            FILTERS: 'Filters',
            FILTER_INFO: 'At the moment, no filters have been selected. In order to add a filter, click on an icon or area on the map, and click on the filter icon (<span class="fa fa-filter"></span>) in the right menu. This will create a filter for the selected property.',
            STYLES: 'Styles',
            STYLE_INFO: 'At the moment, no style has been selected. In order to add a style, click on an icon or area on the map, and click on the style icon (<span class="smallStyleIcon"></span>) in the right menu. This will create a filter for the selected property.',
            FEATURES: 'Features',
            LEGEND: 'Legend',
            SEARCH: 'Search',
            HIDE_PANEL: 'Hide this panel',
            EDIT_INDICATORS: 'Edit indicators',
            RELATED_FEATURES: 'Show related features',
            FEATURE_INFO: 'Show information about the selected feature',
            MAP_FEATURES: 'Map features',
            NEARBY_FEATURES: 'Nearby features',
            TOGGLE_MENU: 'Toggle menu visibility',
            DASHBOARD_SELECTION: 'Dashboard selection',
            SETTINGS: 'Settings',
            SPEEDS_TAOUFIK: 'speed colors Taoufik',
            SPEEDS_GOOGLEMAPS: 'speed colors Google Maps',
            VERWARMINGSSYSTEEM: 'Heating system',
            PERCENTAGES_V1: 'percentages v1',
            ORANGE_RED: 'orange - red',
            WHITE_RED: 'white - red',
            RED_WHITE: 'red - white',
            RED_WHITE_BLUE: 'red - white - blue',
            GREEN_RED: 'green - red',
            RED_GREEN: 'red - green',
            BLUE_RED: 'blue - red',
            RED_BLUE: 'red - blue',
            WHITE_BLUE: 'white - blue',
            BLUE_WHITE: 'blue - white',
            WHITE_GREEN: 'white - green',
            GREEN_WHITE: 'green - white',
            WHITE_ORANGE: 'white - orange',
            ORANGE_WHITE: 'orange - white',
            SAVE: 'save',
            CONFIG: 'config',
            EDIT: 'edit',
            APPLY: 'apply',
            REMOVE: 'remove',
            EXPERTMODE: {
                BEGINNER: 'Novice',
                INTERMEDIATE: 'Intermediate',
                EXPERT: 'Expert',
                ADMIN: 'Admin',
                EXPLANATION: 'Select your expertise in order to unlock more functionality.'
            },
            LAYER_SERVICE: {
                RELOAD_PROJECT_TITLE: 'Data is reloaded',
                RELOAD_PROJECT_MSG: 'After switching the language, we need to reload all the map data. Our appologies for the inconvenience.'
            },
            HEATMAP: {
                NAME: 'Heatmaps',
                DESCRIPTION: '<h4>Heatmap</h4><p  style="text-align: left; margin-left:5px;">Heatmap highlights areas on the map that fulfill multiple selected criteria.',
                INFO: 'At the moment, no map layers are loaded that contain a heatmap. Open another map layer to use it.',
                INFO_EXPERT: 'At the moment, no map layers are loaded that contain a heatmap. Open another map layer to use it, or create a new heatmap using the wizard.',
                SHOW_FEATURE_MSG: 'Select a feature on the map to see the heatmap.',
                TOTAL_RESULT: 'Combined result',
                DELETE_MSG: 'Delete "{0}"',
                DELETE_MSG2: 'Are you sure?',
                EDITOR_TITLE: 'Heatmap Editor',
                MAIN_FEATURE: 'Select the main feature',
                PROPERTIES: 'Select the properties',
                INTENSITY_SCALE: 'Intensity scale',
                RESOLUTION: 'Resolution',
                TITLE: 'Title... *',
                TITLE_TAG: 'Title',
                SCALE_MIN_TITLE: '[Min. scale]',
                SCALE_MAX_TITLE: '[Max. scale]',
                MIN_MAX_ZOOM: 'Min./Max. zoom',
                AT_LOCATION_VALUE: '[Weight at location]',
                DISTANCE_MAX_VALUE: '[Ideal distance]',
                LOST_INTEREST_VALUE: '[Lost interest distance]',
                LINEAR_ASC_DESC: 'Linearly increasing, then decreasing function.',
                ADD_HEATMAP: 'Add a new heatmap.',
                DELETE_HEATMAP: 'Delete the heatmap.',
                EDIT_HEATMAP: 'Edit the heatmap.',
                EXPORT_HEATMAP: 'Export the heatmap.'
            },
            MCA: {
                NAME: 'Multi-Criteria Analysis (MCA)',
                DESCRIPTION: '<h4>Multi-Criteria Analysis</h4><p  style="text-align: left; margin-left:5px;">MCA, is a method that combines multiple properties of a feature on the map into a new property. It achieves this by:<ol><li>Scaling each property to a range between 0 (no value) and 1 (maximum value).</li><li>Weighing each property relative to the others, where a weight less than 0 indicates you wish to avoid it, 0 is ignored, and a value greater than 0 is prefered.</li></ol> In fact, it is a kind of linear regression.',
                INFO: 'At the moment, no map layers are loaded that contain a multi-criteria analysis. Open another map layer to see it.',
                INFO_EXPERT: 'At the moment, no map layers are loaded that contain a multi-criteria analysis. Open another map layer to use it, or create a new MCA using the wizard.',
                SHOW_FEATURE_MSG: 'Select a feature on the map to see the effects of the Multi-Criteria Analysis (MCA).',
                TOTAL_RESULT: 'Combined result',
                DELETE_MSG: 'Delete "{0}"',
                DELETE_MSG2: 'Are you sure?',
                HAS_CATEGORY: '  Has category? ',
                HAS_RANK: '  Include rank? ',
                EDITOR_TITLE: 'MCA Editor',
                MAIN_FEATURE: 'Select the main feature',
                PROPERTIES: 'Select the properties',
                INCLUDE_RANK: '  Show rank? ',
                RANK_TITLE: '[Rank title...]',
                TITLE: 'Title... *',
                CATEGORY_MSG: '[Category...]',
                TOGGLE_SPARKLINE: 'Show or hide bar charts and scoring function.',
                SCALE_MIN_TITLE: '[Min. scale]',
                SCALE_MAX_TITLE: '[Max. scale]',
                MIN_VALUE: '[Minimum (\u03BC-2\u03C3)]',
                MAX_VALUE: '[Maximum (\u03BC+2\u03C3)]',
                MIN_CUTOFF_VALUE: '[Ignore when below this value]',
                MAX_CUTOFF_VALUE: '[Ignore when above this value]',
                LINEAR: 'Linearly increasing function between min and max.',
                SIGMOID: 'Tangentially increasing function between min and max',
                GAUSSIAN: 'Normal distribution increasing function between min and max.',
                ADD_MCA: 'Add a new MCA.',
                DELETE_MCA: 'Delete the MCA.',
                EDIT_MCA: 'Edit the MCA.',
                SET_STYLE: 'Set style'
            },
            PROJECTSETTINGS: {
                TITLE: 'Project Settings',
                DESCRIPTION: 'Settings'
            },
            CHOOSE_CATEGORY: 'Choose category...',
            SHOW5: 'Show 5 items',
            SHOW10: 'Show 10 items',
            SHOW15: 'Show 15 items',
            SHOW20: 'Show 20 items',
            SHOW25: 'Show 25 items',
            SHOW30: 'Show 30 items',
            SHOW35: 'Show 35 items',
            SHOW40: 'Show 40 items'
        };
        return English;
    })();
    Translations.English = English;
})(Translations || (Translations = {}));

var Translations;
(function (Translations) {
    var Dutch = (function () {
        function Dutch() {
        }
        Dutch.locale = {
            CANCEL_BTN: 'Annuleren',
            OK_BTN: 'OK',
            FROM: 'van',
            TO: 'tot',
            NAVIGATE: 'Start',
            REMOVE: 'Verwijder',
            CREATE_SCATTER: 'Creeer spreidingsdiagram',
            EXPAND_ALL: 'Alles uitklappen',
            COLLAPSE_ALL: 'Alles inklappen',
            SELECT_ALL: 'Selecteer alles',
            DESELECT_ALL: 'Deselecteer alles',
            ENABLE_LOCATION_FILTER: 'Activeer locatiefilter',
            SELECT_A_FEATURE: 'Selecteer een feature',
            DISABLE_LOCATION_FILTER: 'Deactiveer locatiefilter',
            SELECT_FEATURE_FOR_WIDGET: 'Selecteer een gebied om de widget te tonen.',
            SELECT_FEATURE_FOR_STYLE: 'Selecteer een gebied om de stijl te activeren.',
            NO_RELATIONS_FOUND: 'Geen relaties voor het geselecteerde item gevonden. Ofwel het zoomniveau is te laag, er zijn teveel items zichtbaar of er zijn geen relaties gedefinierd.',
            CHOOSE_DROPDOWN: 'Kies...',
            BASESTYLES: 'Basiskaarten',
            MAP: 'Kaarten',
            MAP_LABEL: 'Kaart',
            TABLE_LABEL: 'Tabel',
            LAYERS: 'Kaartlagen',
            DIRECTORY: 'Beschikbare lagen',
            CREATELAYER: 'Nieuwe laag maken',
            ADDFEATURES: 'Objecten toevoegen',
            ADDTYPE: 'Nieuwe type toevoegen',
            FILTERS: 'Filters',
            FILTER_INFO: 'Momenteel zijn er geen filters geselecteerd. Klik op een icoon of gebied op de kaart, en klik op het filter icoontje (<span class="fa fa-filter"></span>) in het rechter menu om een filter toe te voegen. Dan wordt er een filter aangemaakt voor de geselecteerde eigenschap.',
            STYLES: 'Stijlen',
            STYLE_INFO: 'Momenteel zijn er geen stijlen geselecteerd. Klik op een icoon of gebied op de kaart, en klik op het stijl icoontje (<span class="smallStyleIcon"></span>) in het rechter menu om een stijl toe te voegen. Dan wordt er een stijl aangemaakt voor de geselecteerde eigenschap.',
            FEATURES: 'Features',
            LEGEND: 'Legenda',
            SEARCH: 'Zoeken',
            HIDE_PANEL: 'Verberg dit paneel',
            EDIT_INDICATORS: 'Wijzig indicatoren',
            RELATED_FEATURES: 'Toon gerelateerde features',
            FEATURE_INFO: 'Toon informatie over de geselecteerde feature',
            MAP_FEATURES: 'Kaartfeatures',
            NEARBY_FEATURES: 'Dichtbijgelegen features',
            DASHBOARD_SELECTION: 'Dashboardselectie',
            SETTINGS: 'Instellingen',
            TOGGLE_MENU: 'Wissel de zichtbaarheid van het menu',
            SPEEDS_TAOUFIK: 'snelheden legenda Taoufik',
            SPEEDS_GOOGLEMAPS: 'snelheden legenda Google Maps',
            VERWARMINGSSYSTEEM: 'Verwarmingssysteem',
            PERCENTAGES_V1: 'percentages v1',
            ORANGE_RED: 'oranje - rood',
            WHITE_RED: 'wit - rood',
            RED_WHITE_BLUE: 'rood - wit - blauw',
            RED_WHITE: 'rood - wit',
            GREEN_RED: 'groen - rood',
            RED_GREEN: 'rood - groen',
            BLUE_RED: 'blauw - rood',
            RED_BLUE: 'rood - blauw',
            WHITE_BLUE: 'wit - blauw',
            BLUE_WHITE: 'wit - groen',
            WHITE_GREEN: 'wit - groen',
            GREEN_WHITE: 'groen - wit',
            WHITE_ORANGE: 'wit - oranje',
            ORANGE_WHITE: 'oranje - wit',
            SAVE: 'opslaan',
            APPLY: 'toepassen',
            DONE: 'klaar',
            CONFIG: 'config',
            EDIT: 'aanpassen',
            EXPERTMODE: {
                BEGINNER: 'Beginner',
                INTERMEDIATE: 'Gevorderd',
                EXPERT: 'Expert',
                ADMIN: 'Admin',
                EXPLANATION: 'Selecteer uw expertise om meer functionaliteit te kunnen gebruiken.'
            },
            LAYER_SERVICE: {
                RELOAD_PROJECT_TITLE: 'Data wordt opnieuw geladen',
                RELOAD_PROJECT_MSG: 'Na het wisselen van de taal moet de kaartdata opnieuw ingelezen worden. Excuses voor het ongemak.'
            },
            HEATMAP: {
                NAME: 'Heatmaps',
                DESCRIPTION: '<h4>Toelichting heatmap</h4><div style="text-align: left; margin-left:5px;"><p>Heatmap laat gebieden op de kaart oplichten die voldoen aan bepaalde criteria.',
                INFO: 'Momenteel zijn er geen kaartlagen geopend die heatmaps bevatten.',
                INFO_EXPERT: 'Momenteel zijn er geen kaartlagen geopend die heatmaps bevatten. Open een kaartlaag en maak een nieuwe heatmap aan met behulp van de wizard.',
                SHOW_FEATURE_MSG: 'Selecteer een feature op de kaart om de heatmap resultaten in detail te bekijken.',
                TOTAL_RESULT: 'Gecombineerd resultaat',
                DELETE_MSG: 'Verwijder "{0}"',
                DELETE_MSG2: 'Weet u het zeker?',
                EDITOR_TITLE: 'Heatmap Editor',
                MAIN_FEATURE: 'Selecteer het type feature',
                PROPERTIES: 'Selecteer de eigenschappen',
                RESOLUTION: 'Resolutie',
                INTENSITY_SCALE: 'Intensiteitsschaal',
                TITLE: 'Titel... *',
                TITLE_TAG: 'Titel',
                TOGGLE_SPARKLINE: 'Toon of verberg de histogram en score functie.',
                SCALE_MIN_TITLE: '[Schaal max]',
                SCALE_MAX_TITLE: '[Schaal min]',
                MIN_MAX_ZOOM: 'Min./Max. zoom',
                AT_LOCATION_VALUE: '[Waarde op locatie]',
                DISTANCE_MAX_VALUE: '[Ideale afstand]',
                LOST_INTEREST_VALUE: '[Negeer vanaf afstand]',
                LINEAR_ASC_DESC: 'Linear toenemende, dan afnemende functie.',
                ADD_HEATMAP: 'Maak een nieuwe heatmap.',
                DELETE_HEATMAP: 'Verwijder de heatmap.',
                EDIT_HEATMAP: 'Bewerk de heatmap.',
                EXPORT_HEATMAP: 'Exporteer de heatmap.'
            },
            MCA: {
                NAME: 'Multi-Criteria Analyse (MCA)',
                DESCRIPTION: '<h4>Toelichting MCA</h4><div style="text-align: left; margin-left:5px;"><p>Multi-Criteria Analysis (MCA) is een methode die verschillende eigenschappen van een locatie of gebied op de kaart combineerd tot een nieuwe eigenschap. Dit gaat als volgt: <ol><li>Schaal iedere eigenschap tussen 0 (geen waarde) en 1 (maximum waarde).</li><li>Weeg iedere eigenschap relatief t.o.v. de andere gekozen eigenschappen, waar een gewicht onder 0 betekent dat je de eigenschap wil vermijden, 0 wordt genegeerd, en een waarde groter dan 0 betekent dat je dit wil bereiken.</li></ol>Met andere woorden, het is een vorm van lineare regressie.</p></div>',
                INFO: 'Momenteel zijn er geen kaartlagen geopend die multi-criteria analyses bevatten. Open hiervoor een andere kaartlaag.',
                INFO_EXPERT: 'Momenteel zijn er geen kaartlagen geopend die multi-criteria analyses bevatten. Open een kaartlaag en maak een nieuwe MCA aan met behulp van de wizard.',
                SHOW_FEATURE_MSG: 'Selecteer een feature op de kaart om de Multi-Criteria Analyse (MCA) resultaten in detail te bekijken.',
                TOTAL_RESULT: 'Gecombineerd resultaat',
                DELETE_MSG: 'Verwijder "{0}"',
                DELETE_MSG2: 'Weet u het zeker?',
                HAS_CATEGORY: '  Specificeer categorie? ',
                EDITOR_TITLE: 'MCA Editor',
                MAIN_FEATURE: 'Selecteer het type feature',
                PROPERTIES: 'Selecteer de eigenschappen',
                INCLUDE_RANK: '  Toon een rangorde? ',
                RANK_TITLE: '[Titel voor de rangorde]',
                TITLE: 'Titel... *',
                CATEGORY_MSG: '[Categorie...]',
                TOGGLE_SPARKLINE: 'Toon of verberg de histogram en score functie.',
                SCALE_MIN_TITLE: '[Schaal max]',
                SCALE_MAX_TITLE: '[Schaal min]',
                MIN_VALUE: '[Ondergrens (\u03BC-2\u03C3)]',
                MAX_VALUE: '[Bovengrens (\u03BC+2\u03C3)]',
                MIN_CUTOFF_VALUE: '[Niet meewegen onder]',
                MAX_CUTOFF_VALUE: '[Niet meewegen boven]',
                LINEAR: 'Linear toenemende functie tussen onder- en bovengrens.',
                SIGMOID: 'Tangentieel toenemende functie tussen onder- en bovengrens.',
                GAUSSIAN: 'Normale verdeling tussen onder- en bovengrens.',
                ADD_MCA: 'Maak een nieuwe MCA.',
                DELETE_MCA: 'Verwijder de MCA.',
                EDIT_MCA: 'Bewerk de MCA.',
                SET_STYLE: 'Activeer stijl'
            },
            PROJECTSETTINGS: {
                TITLE: 'Project instellingen',
                DESCRIPTION: 'Instellingen'
            },
            CHOOSE_CATEGORY: 'Kies categorie...',
            SHOW5: 'Toon 5 regels',
            SHOW10: 'Toon 10 regels',
            SHOW15: 'Toon 15 regels',
            SHOW20: 'Toon 20 regels',
            SHOW25: 'Toon 25 regels',
            SHOW30: 'Toon 30 regels',
            SHOW35: 'Toon 35 regels',
            SHOW40: 'Toon 40 regels'
        };
        return Dutch;
    })();
    Translations.Dutch = Dutch;
})(Translations || (Translations = {}));

var Accessibility;
(function (Accessibility) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Accessibility.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Accessibility.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a feature's properties in a panel.
      *
      * @seealso          : http://www.youtube.com/watch?v=gjJ5vLRK8R8&list=UUGD_0i6L48hucTiiyhb5QzQ
      * @seealso          : http://plnkr.co/edit/HyBP9d?p=preview
      */
    Accessibility.myModule.directive('accessibility', ['$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Accessibility/Accessibility.tpl.html',
                replace: true,
                transclude: true,
                controller: Accessibility.AccessibilityCtrl
            };
        }
    ]);
})(Accessibility || (Accessibility = {}));

var Accessibility;
(function (Accessibility) {
    var AccessibilityModel = (function () {
        function AccessibilityModel() {
            this.id = "accessibilityActions";
        }
        AccessibilityModel.prototype.stop = function () { };
        AccessibilityModel.prototype.addFeature = function (feature) { };
        AccessibilityModel.prototype.removeFeature = function (feature) { };
        AccessibilityModel.prototype.selectFeature = function (feature) {
            console.log('accessibility:feature selected');
        };
        AccessibilityModel.prototype.getFeatureActions = function (feature) {
            var accessibilityOption1 = {
                title: "Show accessibility"
            };
            accessibilityOption1.callback = this.showAccessibility;
            var accessibilityOption2 = {
                title: "Remove accessibility"
            };
            accessibilityOption2.callback = this.removeAccessibility;
            var accessibilityOption3 = {
                title: "Plan route from"
            };
            accessibilityOption3.callback = this.planRouteFrom;
            var accessibilityOption4 = {
                title: "Plan route to"
            };
            accessibilityOption4.callback = this.planRouteTo;
            return [accessibilityOption1, accessibilityOption2, accessibilityOption3, accessibilityOption4];
        };
        AccessibilityModel.prototype.getFeatureHoverActions = function (feature) { return []; };
        AccessibilityModel.prototype.deselectFeature = function (feature) { };
        AccessibilityModel.prototype.updateFeature = function (feature) { };
        AccessibilityModel.prototype.showAccessibility = function (feature, layerService) {
            console.log('accessibility:showAccessibility');
            var accessibilityLayer = layerService.findLayer('accessibility');
            if (accessibilityLayer) {
                var urlParams = accessibilityLayer.url.split('&');
                var locationIndex = -1;
                urlParams.some(function (param, index) {
                    if (param.substring(0, 9) === 'fromPlace') {
                        locationIndex = index;
                        return true;
                    }
                    return false;
                });
                if (feature.geometry.type !== 'Point') {
                    console.log('Can only create accessibility layer from a Point');
                    return;
                }
                urlParams[locationIndex] = 'fromPlace=' + feature.geometry.coordinates[1] + '%2C' + feature.geometry.coordinates[0];
                accessibilityLayer.url = urlParams.join('&');
                if (!accessibilityLayer.enabled) {
                    layerService.addLayer(accessibilityLayer);
                    var rpt = csComp.Helpers.createRightPanelTab("rightpanel", "accessibility", accessibilityLayer, "Accessibility options");
                    layerService.$messageBusService.publish("rightpanel", "activate", rpt);
                }
                else {
                    if (accessibilityLayer.layerSource)
                        accessibilityLayer.layerSource.refreshLayer(accessibilityLayer);
                }
            }
        };
        AccessibilityModel.prototype.removeAccessibility = function (feature, layerService) {
            console.log('accessibility:removeAccessibility');
            var accessibilityLayer = layerService.findLayer('accessibility');
            if (accessibilityLayer) {
                var wasRightPanelVisible = layerService.visual.rightPanelVisible;
                if (accessibilityLayer.enabled) {
                    layerService.removeLayer(accessibilityLayer);
                }
                delete accessibilityLayer.data;
                layerService.visual.rightPanelVisible = wasRightPanelVisible;
            }
        };
        AccessibilityModel.planRoute = function (feature, layerService, destinationKey) {
            var routeLayer = layerService.findLayer('tripplanner');
            if (routeLayer) {
                var urlParams = csComp.Helpers.parseUrlParameters(routeLayer.url, '?', '&', '=');
                urlParams[destinationKey] = feature.geometry.coordinates[1] + '%2C' + feature.geometry.coordinates[0];
                routeLayer.url = csComp.Helpers.joinUrlParameters(urlParams, '?', '&', '=');
                if (!routeLayer.enabled) {
                    layerService.addLayer(routeLayer);
                }
                else {
                    if (routeLayer.layerSource)
                        routeLayer.layerSource.refreshLayer(routeLayer);
                }
                var rpt = csComp.Helpers.createRightPanelTab("rightpanel", "tripplanner", routeLayer, "Route planner");
                layerService.$messageBusService.publish("rightpanel", "activate", rpt);
            }
            else {
            }
        };
        AccessibilityModel.prototype.planRouteFrom = function (feature, layerService) {
            console.log('accessibility:planRouteFrom');
            AccessibilityModel.planRoute(feature, layerService, 'fromPlace');
        };
        AccessibilityModel.prototype.planRouteTo = function (feature, layerService) {
            console.log('accessibility:planRouteTo');
            AccessibilityModel.planRoute(feature, layerService, 'toPlace');
        };
        AccessibilityModel.prototype.init = function (layerService) {
            var _this = this;
            console.log('init AccessibilityActionService');
            this.layerService = layerService;
            this.layerService.$messageBusService.serverSubscribe("accessibility", "msg", function (title, mcb) {
                if (mcb["data"] === "restart") {
                    _this.layerService.$messageBusService.notify("restarting server", "restarting", csComp.Services.NotifyLocation.TopRight);
                    location.reload();
                }
                //
                // var layer = this.layerService.findLayer("demo");
                // layer.layerSource.refreshLayer(layer);
                //console.log(title);
            });
        };
        return AccessibilityModel;
    })();
    Accessibility.AccessibilityModel = AccessibilityModel;
    var AccessibilityCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function AccessibilityCtrl($scope, $http, $mapService, $layerService, $messageBusService, $dashboardService) {
            var _this = this;
            this.$scope = $scope;
            this.$http = $http;
            this.$mapService = $mapService;
            this.$layerService = $layerService;
            this.$messageBusService = $messageBusService;
            this.$dashboardService = $dashboardService;
            this.urlKeys = ['arriveBy', 'fromPlace', 'date', 'time', 'mode', 'walkSpeed', 'bikeSpeed',
                'precisionMeters', 'cutoffSec'];
            this.scope = $scope;
            $scope.vm = this;
            this.layer = $scope.$parent["data"];
            this.cutoffTimes = [];
            this.urlParameters = {};
            this.bikeSpeedKm;
            this.walkSpeedKm;
            this.urlKeys.forEach(function (key) { _this.urlParameters[key] = 0; });
            this.transportModes = {};
            this.transportModes["Walking"] = "WALK";
            this.transportModes["Biking"] = "BICYCLE";
            //this.transportModes["Car"] = "CAR";
        }
        AccessibilityCtrl.prototype.refreshAccessibility = function () {
            if (this.$layerService.lastSelectedFeature) {
                var lsf = this.$layerService.lastSelectedFeature;
                if (lsf.geometry && lsf.geometry.type === 'Point') {
                    this.urlParameters['fromPlace'] = lsf.geometry.coordinates[1] + '%2C' + lsf.geometry.coordinates[0];
                }
            }
            this.urlParameters['mode'] = this.transportMode;
            this.urlParameters['time'] = encodeURIComponent(this.time);
            if (this.walkSpeedKm)
                this.urlParameters['walkSpeed'] = csComp.Helpers.GeoExtensions.convertKmToMile(this.walkSpeedKm);
            if (this.bikeSpeedKm)
                this.urlParameters['bikeSpeed'] = csComp.Helpers.GeoExtensions.convertKmToMile(this.bikeSpeedKm);
            var url = this.urlAddress + '?';
            for (var key in this.urlParameters) {
                if (this.urlParameters.hasOwnProperty(key) && key !== 'cutoffSec') {
                    url = url + key + '=' + this.urlParameters[key] + '&';
                }
            }
            this.cutoffTimes.forEach(function (co) {
                url = url + '&cutoffSec=' + (co * 60);
            });
            //url = url.substring(0, url.length - 1);
            console.log(url);
            this.layer.url = url;
            if (!this.layer.enabled) {
                this.$layerService.addLayer(this.layer);
            }
            else {
                if (this.layer.layerSource)
                    this.layer.layerSource.refreshLayer(this.layer);
            }
            this.$layerService.visual.rightPanelVisible = true;
        };
        AccessibilityCtrl.prototype.parseUrl = function () {
            var _this = this;
            this.urlParameters = {};
            this.urlAddress = this.layer.url.split('?')[0];
            var croppedUrl = this.layer.url.split('?')[1]; // Remove the address of the url, keep the parameters
            var splittedUrl = croppedUrl.split('&');
            splittedUrl.forEach(function (param) {
                var keyValue = param.split('=');
                if (keyValue[0] === 'cutoffSec') {
                    _this.cutoffTimes.push((+keyValue[1]) / 60);
                }
                _this.urlParameters[keyValue[0]] = (isNaN(+keyValue[1])) ? keyValue[1] : +keyValue[1];
            });
            var d = new Date(Date.now());
            this.time = ('0' + d.getHours()).slice(-2) + ':' + ('0' + d.getMinutes()).slice(-2);
            this.urlParameters['date'] = (d.getMonth() + 1) + '-' + d.getDate() + '-' + d.getFullYear();
            this.transportMode = this.urlParameters['mode'];
            if (this.urlParameters.hasOwnProperty('walkSpeed'))
                this.walkSpeedKm = +csComp.Helpers.GeoExtensions.convertMileToKm(this.urlParameters['walkSpeed']).toFixed(2);
            if (this.urlParameters.hasOwnProperty('bikeSpeed'))
                this.bikeSpeedKm = +csComp.Helpers.GeoExtensions.convertMileToKm(this.urlParameters['bikeSpeed']).toFixed(2);
            if (this.$scope.$root.$$phase != '$apply' && this.$scope.$root.$$phase != '$digest') {
                this.$scope.$apply();
            }
        };
        AccessibilityCtrl.prototype.addCutoffTime = function () {
            this.cutoffTimes.push(0);
            if (this.$scope.$root.$$phase != '$apply' && this.$scope.$root.$$phase != '$digest') {
                this.$scope.$apply();
            }
        };
        AccessibilityCtrl.prototype.removeCutoffTime = function (index) {
            if (index < this.cutoffTimes.length && index > -1) {
                this.cutoffTimes.splice(index, 1);
            }
            if (this.$scope.$root.$$phase != '$apply' && this.$scope.$root.$$phase != '$digest') {
                this.$scope.$apply();
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        AccessibilityCtrl.$inject = [
            '$scope',
            '$http',
            'mapService',
            'layerService',
            'messageBusService',
            'dashboardService'
        ];
        return AccessibilityCtrl;
    })();
    Accessibility.AccessibilityCtrl = AccessibilityCtrl;
})(Accessibility || (Accessibility = {}));

var BaseMapList;
(function (BaseMapList) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        BaseMapList.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        BaseMapList.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    BaseMapList.myModule.directive('baseMapList', [
        '$window', '$compile',
        function ($window, $compile) {
            return {
                terminal: false,
                restrict: 'E',
                scope: {},
                //template  : html,   // I use gulp automatian to compile the FeatureProperties.tpl.html to a simple TS file, FeatureProperties.tpl.ts, which contains the html as string. The advantage is that you can use HTML intellisence in the html file.
                templateUrl: 'directives/BaseMapList/BaseMapList.tpl.html',
                //compile : el          => {    // I need to explicitly compile it in order to use interpolation like {{xxx}}
                //    var fn                        = $compile(el);
                //    return scope                  => {
                //        fn(scope);
                //    };
                //},
                link: function (scope, element, attrs) {
                    // Deal with resizing the element list
                    scope.onResizeFunction = function () {
                        var filterHeight = 50;
                        var paginationCtrlHeight = 100;
                        var itemHeight = 60;
                        //scope.windowHeight          = $window.innerHeight;
                        //scope.windowWidth           = $window.innerWidth;
                        scope.numberOfItems = Math.floor(($window.innerHeight - filterHeight - paginationCtrlHeight) / itemHeight);
                    };
                    // Call to the function when the page is first loaded
                    scope.onResizeFunction();
                    angular.element($window).bind('resize', function () {
                        scope.onResizeFunction();
                        scope.$apply();
                    });
                },
                replace: true,
                transclude: true,
                controller: BaseMapList.BaseMapListCtrl
            };
        }
    ]);
})(BaseMapList || (BaseMapList = {}));

var BaseMapList;
(function (BaseMapList) {
    var BaseMapListCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function BaseMapListCtrl($scope, $layerService, $mapService, $messageBusService) {
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$mapService = $mapService;
            this.$messageBusService = $messageBusService;
            $scope.vm = this;
        }
        BaseMapListCtrl.prototype.selectBaseLayer = function (key) {
            var layer = this.$layerService.$mapService.getBaselayer(key);
            this.$layerService.activeMapRenderer.changeBaseLayer(layer);
            this.$layerService.$mapService.changeBaseLayer(key);
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        BaseMapListCtrl.$inject = [
            '$scope',
            'layerService',
            'mapService',
            'messageBusService',
        ];
        return BaseMapListCtrl;
    })();
    BaseMapList.BaseMapListCtrl = BaseMapListCtrl;
})(BaseMapList || (BaseMapList = {}));

var Charts;
(function (Charts) {
    'use strict';
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Charts.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Charts.myModule = angular.module(moduleName, []);
    }
    Charts.myModule.directive('barChart', ['$filter',
        function ($filter) {
            return {
                terminal: true,
                restrict: 'EA',
                scope: {
                    data: '=',
                    update: '='
                },
                link: function (scope, element, attrs) {
                    //in D3, any selection[0] contains the group
                    //selection[0][0] is the DOM node
                    //but we won't need that this time
                    var chart = d3.select(element[0]);
                    chart.append("div").attr("class", "chart")
                        .selectAll('div')
                        .data(scope.data).enter().append("div")
                        .transition().ease("elastic")
                        .style("width", function (d) { return d + "%"; })
                        .text(function (d) { return d + "%"; });
                    //to our original directive markup bars-chart
                    //we add a div with out chart stling and bind each
                    //data entry to the chart
                }
            };
        }
    ]);
})(Charts || (Charts = {}));

var Charts;
(function (Charts) {
    'use strict';
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Charts.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Charts.myModule = angular.module(moduleName, []);
    }
    Charts.myModule.directive('bulletChart', ['$filter',
        function ($filter) {
            var demoData = [{
                    title: "Drop outs",
                    subtitle: "%",
                    ranges: [150, 225, 300],
                    measures: [220, 270],
                    markers: [250]
                }];
            function doDraw(scope, element) {
                if (scope.data) {
                    var doBullet = d3.bullet()
                        .width(scope.width)
                        .height(scope.height);
                    //bullet expects de following data
                    /**
                    title :
                    subtitle :

                    ranges : array of context ranges (absolute, not relative)
                    measures : array of values shown (absolute, not relative)
                    markers : (absolute, not relative)
                    */
                    //
                    $(element[0]).empty();
                    var chart = d3.select(element[0]);
                    var parsedData = [];
                    if (scope.data) {
                        parsedData = JSON.parse(scope.data);
                    }
                    ;
                    var svg = chart.append("div").attr("class", "chart")
                        .selectAll('div')
                        .data(parsedData)
                        .enter().append("svg")
                        .attr("class", "bullet")
                        .attr("width", scope.width + 15)
                        .attr("height", +scope.height + 40)
                        .append("g")
                        .attr("transform", "translate(7,20)")
                        .call(doBullet, false);
                    var title = svg.append("g")
                        .style("text-anchor", "begin")
                        .attr("transform", "translate(0,-5)");
                    title.append("text")
                        .attr("class", "title")
                        .text(function (d) { return d.title; });
                    title.append("text")
                        .attr("class", "subtitle")
                        .attr("dy", "1em")
                        .text(function (d) { return d.subtitle; });
                }
                ;
            }
            return {
                terminal: true,
                restrict: 'EA',
                scope: {
                    //data: '=',
                    data: '=',
                    update: '=',
                    width: '=',
                    height: '@',
                    margin: '@'
                },
                link: function (scope, element, attrs) {
                    //in D3, any selection[0] contains the group
                    //selection[0][0] is the DOM node
                    //but we won't need that this time
                    doDraw(scope, element);
                    scope.$watch("data", function () {
                        doDraw(scope, element);
                    });
                    scope.$watch("update", function () {
                        doDraw(scope, element);
                    });
                }
            };
        }
    ]);
})(Charts || (Charts = {}));

var Charts;
(function (Charts) {
    'use strict';
    var ChartHelpers = (function () {
        function ChartHelpers() {
        }
        /**
        * Returns the index and value of the maximum.
        */
        ChartHelpers.max = function (arr) {
            var max = arr[0];
            var maxIndex = 0;
            for (var i = 1; i < arr.length; i++) {
                if (arr[i] > max) {
                    maxIndex = i;
                    max = arr[i];
                }
            }
            return { maxIndex: maxIndex, max: max };
        };
        /**
        * Returns the index and value of the minimum.
        */
        ChartHelpers.min = function (arr) {
            var min = arr[0];
            var minIndex = 0;
            for (var i = 1; i < arr.length; i++) {
                if (arr[i] < min) {
                    minIndex = i;
                    min = arr[i];
                }
            }
            return { minIndex: minIndex, min: min };
        };
        /**
        * Convert a timestamp to string.
        */
        ChartHelpers.timestampToString = function (ts) {
            var date = new Date(ts);
            var dateString = String.format("{0}-{1:00}-{2:00}", date.getFullYear(), date.getUTCMonth() + 1, date.getUTCDate());
            //if (date.getUTCHours() > 0 || date.getUTCMinutes() > 0)
            //    dateString += String.format(" {0:00}:{1:00}", date.getUTCHours(), date.getUTCMinutes());
            return dateString;
        };
        // Easy way to bind multiple functions to window.onresize
        // TODO: give a way to remove a function after its bound, other than removing all of them
        ChartHelpers.windowResize = function (fun) {
            if (fun === undefined)
                return;
            var oldresize = window.onresize;
            window.onresize = function (e) {
                if (typeof oldresize == 'function')
                    oldresize(e);
                fun(e);
            };
        };
        ChartHelpers.initializeMargin = function (scope, attrs) {
            var margin = scope.$eval(attrs.margin) || {
                left: 50,
                top: 50,
                bottom: 50,
                right: 50
            };
            if (typeof margin !== 'object') {
                // we were passed a vanilla int, convert to full margin object
                margin = {
                    left: margin,
                    top: margin,
                    bottom: margin,
                    right: margin
                };
            }
            scope.margin = margin;
        };
        ChartHelpers.getD3Selector = function (attrs, element) {
            if (!attrs.id) {
                //if an id is not supplied, create a random id.
                var dataAttributeChartID;
                if (!attrs['data-chartid']) {
                    dataAttributeChartID = 'chartid' + Math.floor(Math.random() * 1000000001);
                    angular.element(element).attr('data-chartid', dataAttributeChartID);
                }
                else {
                    dataAttributeChartID = attrs['data-chartid'];
                }
                return '[data-chartid=' + dataAttributeChartID + ']';
            }
            else {
                return '#' + attrs.id;
            }
        };
        ChartHelpers.initializeLegendMargin = function (scope, attrs) {
            var margin = (scope.$eval(attrs.legendmargin) || {
                left: 0,
                top: 5,
                bottom: 5,
                right: 0
            });
            if (typeof (margin) !== 'object') {
                // we were passed a vanilla int, convert to full margin object
                margin = {
                    left: margin,
                    top: margin,
                    bottom: margin,
                    right: margin
                };
            }
            scope.legendmargin = margin;
        };
        ChartHelpers.defaultColor = function () {
            var colors = d3.scale.category20().range();
            return function (d, i) { return d.color || colors[i % colors.length]; };
        };
        ChartHelpers.configureLegend = function (chart, scope, attrs) {
            if (chart.legend && attrs.showlegend && (attrs.showlegend === 'true')) {
                ChartHelpers.initializeLegendMargin(scope, attrs);
                chart.legend.margin(scope.legendmargin);
                chart.legend.width(attrs.legendwidth === undefined ? 400 : (+attrs.legendwidth));
                chart.legend.height(attrs.legendheight === undefined ? 20 : (+attrs.legendheight));
                chart.legend.key(attrs.legendkey === undefined ? function (d) {
                    return d.key;
                } : scope.legendkey());
                chart.legend.color(attrs.legendcolor === undefined ? ChartHelpers.defaultColor() : scope.legendcolor());
                chart.legend.align(attrs.legendalign === undefined ? true : (attrs.legendalign === 'true'));
                chart.legend.rightAlign(attrs.legendrightalign === undefined ? true : (attrs.legendrightalign === 'true'));
                chart.legend.updateState(attrs.legendupdatestate === undefined ? true : (attrs.legendupdatestate === 'true'));
                chart.legend.radioButtonMode(attrs.legendradiobuttonmode === undefined ? false : (attrs.legendradiobuttonmode === 'true'));
            }
        };
        ChartHelpers.checkElementID = function (scope, attrs, element, chart, data) {
            //ChartHelpers.configureXaxis(chart, scope, attrs);
            //ChartHelpers.configureX2axis(chart, scope, attrs);
            //ChartHelpers.configureYaxis(chart, scope, attrs);
            //ChartHelpers.configureY1axis(chart, scope, attrs);
            //ChartHelpers.configureY2axis(chart, scope, attrs);
            ChartHelpers.configureLegend(chart, scope, attrs);
            //ChartHelpers.processEvents(chart, scope);
            var d3Select = ChartHelpers.getD3Selector(attrs, element);
            if (angular.isArray(data) && data.length === 0) {
                d3.select(d3Select + ' svg').remove();
            }
            if (d3.select(d3Select + ' svg').empty()) {
                d3.select(d3Select).append('svg');
            }
            d3.select(d3Select + ' svg').attr('viewBox', '0 0 ' + scope.width + ' ' + scope.height).datum(data).transition().duration(attrs.transitionduration === undefined ? 250 : +attrs.transitionduration).call(chart);
        };
        ChartHelpers.updateDimensions = function (scope, attrs, element, chart) {
            if (chart) {
                chart.width(scope.width).height(scope.height);
                var d3Select = ChartHelpers.getD3Selector(attrs, element);
                d3.select(d3Select + ' svg').attr('viewBox', '0 0 ' + scope.width + ' ' + scope.height);
                ChartHelpers.windowResize(chart);
                scope.chart.update();
            }
        };
        return ChartHelpers;
    })();
    Charts.ChartHelpers = ChartHelpers;
})(Charts || (Charts = {}));

var Charts;
(function (Charts) {
    'use strict';
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Charts.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Charts.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to create a sparkline chart.
      *
      * @seealso: http://odiseo.net/angularjs/proper-use-of-d3-js-with-angular-directives
      * @seealso: http://cmaurer.github.io/angularjs-nvd3-directives/sparkline.chart.html
      * @seealso: http://www.tnoda.com/blog/2013-12-19
      */
    Charts.myModule
        .directive('circularChart', [
        function () {
            return {
                terminal: true,
                restrict: 'EA',
                scope: {
                    value: '=',
                    max: '=',
                    title: '=',
                    update: '=',
                    valueString: '=',
                    color: '=',
                    valueClass: '@',
                    titleClass: '@',
                    animationDuration: '@',
                    width: '@',
                    height: '@',
                    margin: '@'
                },
                //controller: [
                //    '$scope',
                //    '$element',
                //    '$attrs',
                //    function ($scope, $element, $attrs) {
                //        $scope.d3Call    = function (data, chart) {
                //            ChartHelpers.checkElementID($scope, $attrs, $element, chart, data);
                //        };
                //    }
                //],
                link: function (scope, element, attrs) {
                    var doDraw = (function () {
                        if (scope.value != null && scope.max != null) {
                            var margin = scope.margin || { top: 15, right: 5, bottom: 0, left: 10 };
                            var width = scope.width || 100;
                            var height = scope.height || 70;
                            var c = scope.color || "purple";
                            var animationDuration = scope.animationDuration || 0;
                            var cursorTextHeight = 12; // + (showAxis ? 5 : 0); // leave room for the cursor text (timestamp | measurement)
                            $(element[0]).empty();
                            var dataset = {
                                hddrives: [scope.value, scope.max - scope.value],
                            };
                            var width = scope.width, height = scope.height, radius = Math.min(width, height) / 2;
                            var color = d3.scale.ordinal()
                                .range([c, "lightgray"]);
                            var pie = d3.layout.pie()
                                .sort(null);
                            var arc = d3.svg.arc()
                                .innerRadius(radius - 100)
                                .outerRadius(radius - 80);
                            var svg = d3.select(element[0]).append("svg")
                                .attr("width", width)
                                .attr("height", height)
                                .append("g")
                                .attr("transform", "translate(" + width / 3 + "," + height / 3 + ")");
                            var path = svg.selectAll("path")
                                .data(pie(dataset.hddrives))
                                .enter().append("path")
                                .attr("class", "arc")
                                .attr("fill", function (d, i) { return color(i); })
                                .transition().delay(function (d, i) { return i * animationDuration; }).duration(animationDuration)
                                .attrTween("d", function (d) {
                                var i = d3.interpolate(d.startAngle + 0.1, d.endAngle);
                                return function (t) {
                                    d.endAngle = i(t);
                                    return arc(d);
                                };
                            });
                            svg.append("text")
                                .attr("dy", "-0.25em")
                                .style("text-anchor", "middle")
                                .attr("class", scope.valueClass)
                                .text(function (d) { return scope.valueString; });
                            svg.append("text")
                                .attr("dy", "1em")
                                .style("text-anchor", "middle")
                                .attr("class", scope.titleClass)
                                .text(function (d) { return scope.title; });
                        }
                    });
                    doDraw();
                    scope.$watch("value", function () {
                        doDraw();
                    });
                    scope.$watch("color", function () {
                        doDraw();
                    });
                    scope.$watch("update", function () {
                        doDraw();
                    });
                    //scope.closed = true;
                }
            };
        }]);
})(Charts || (Charts = {}));

var Charts;
(function (Charts) {
    'use strict';
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Charts.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Charts.myModule = angular.module(moduleName, []);
    }
    Charts.myModule.directive('singlevalueChart', ['$filter',
        function ($filter) {
            return {
                terminal: true,
                restrict: 'EA',
                scope: {
                    data: '=',
                },
                link: function (scope, element, attrs) {
                    //in D3, any selection[0] contains the group
                    //selection[0][0] is the DOM node
                    //but we won't need that this time
                    var chart = d3.select(element[0]);
                    chart.append("div").attr("class", "chart")
                        .selectAll('div')
                        .data(scope.value).enter().append("div")
                        .transition().ease("elastic")
                        .style("width", function (d) { return d + "%"; })
                        .text(function (d) { return d + "%"; });
                    //to our original directive markup bars-chart
                    //we add a div with out chart stling and bind each
                    //data entry to the chart
                }
            };
        }
    ]);
})(Charts || (Charts = {}));

var Charts;
(function (Charts) {
    'use strict';
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Charts.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Charts.myModule = angular.module(moduleName, []);
    }
    Charts.myModule
        .directive('sparklineChart', ['$filter',
        function ($filter) {
            return {
                terminal: true,
                restrict: 'EA',
                scope: {
                    timestamps: '=',
                    sensor: '=',
                    property: '=',
                    update: '=',
                    focusTime: '=',
                    showaxis: '=',
                    closed: '=',
                    width: '@',
                    height: '@',
                    margin: '@'
                },
                // controller: [
                //    '$scope',
                //    '$element',
                //    '$attrs',
                //
                //    function ($scope, $element, $attrs, messageBusService) {
                //
                //    }
                // ],
                link: function (scope, element, attrs) {
                    var doDraw = (function () {
                        if (scope.timestamps != null && scope.sensor != null && scope.timestamps.length > 0) {
                            var margin = scope.margin || { top: 15, right: 5, bottom: 0, left: 10 };
                            var width = scope.width || 100;
                            var height = scope.height || 70;
                            console.log('heigth:' + height);
                            var showAxis = typeof scope.showaxis !== 'undefined' && scope.showaxis;
                            var closed = typeof scope.closed !== 'undefined' && scope.closed;
                            var cursorTextHeight = 12; // + (showAxis ? 5 : 0); // leave room for the cursor text (timestamp | measurement)
                            $(element[0]).empty();
                            var chart = d3.select(element[0])
                                .append('svg:svg')
                                .attr('width', width)
                                .attr('height', height);
                            var marginAxis = showAxis
                                ? { top: 0, right: 0, bottom: 20, left: 10 }
                                : { top: 0, right: 0, bottom: 0, left: 0 };
                            var x = d3.scale.linear().range([margin.left + marginAxis.left, width - margin.left - margin.right - marginAxis.left - marginAxis.right]);
                            var y = d3.scale.linear().range([height - margin.bottom - marginAxis.bottom, margin.top + marginAxis.top + cursorTextHeight]);
                            var bisect = d3.bisector(function (d) { return d.time; }).left;
                            var line = d3.svg.line()
                                .interpolate((closed) ? "linear-closed" : "cardinal")
                                .x(function (d) { return x(d.time); })
                                .y(function (d) { return y(d.measurement); });
                            var data = [];
                            //data.push({time:scope.timestamps[0],measurement:0});
                            for (var i = 0; i < scope.timestamps.length; i++) {
                                var m = scope.property ? scope.property : 'value';
                                var me = $.isArray(scope.sensor[i]) ? scope.sensor[i][m] : scope.sensor[i];
                                data.push({ time: scope.timestamps[i], measurement: me });
                            }
                            //data.push({time:scope.timestamps[scope.timestamps.length-1],measurement:0});
                            x.domain(d3.extent(data, function (d) { return d.time; }));
                            y.domain(d3.extent(data, function (d) { return d.measurement; }));
                            var s = [];
                            if (closed && data.length > 0)
                                s.push({ time: data[0].time, measurement: 0 });
                            data.forEach(function (d) { return s.push(d); });
                            if (closed && data.length > 0)
                                s.push({ time: data[data.length - 1].time, measurement: 0 });
                            var path = chart.append("svg:path")
                                .attr("d", line(s))
                                .attr('class', 'sparkline-path')
                                .style('fill', (closed) ? 'steelblue' : 'none');
                            // draw a circle around the max and min value
                            var measurements = data.map(function (d) { return d.measurement; });
                            var min = Charts.ChartHelpers.min(measurements);
                            var max = Charts.ChartHelpers.max(measurements);
                            chart.append('circle')
                                .attr('class', 'sparkcircle-max')
                                .attr('cx', x(data[max.maxIndex].time))
                                .attr('cy', y(max.max))
                                .attr('r', 4);
                            chart.append('circle')
                                .attr('class', 'sparkcircle-min')
                                .attr('cx', x(data[min.minIndex].time))
                                .attr('cy', y(min.min))
                                .attr('r', 4);
                            if (showAxis) {
                                //var xAxis = d3.svg.axis()
                                //    .scale(x)
                                //    .orient("bottom")
                                //    .ticks(d3.time.months, 2);  //Set rough # of ticks
                                //chart.append("g")
                                //    .attr("class", "sparkline-axis")
                                //    .attr("transform", "translate(0," + (height - margin.bottom - marginAxis.bottom) + ")")
                                //    .call(xAxis);
                                var strokeLength = 6;
                                // Draw min/max at x and y axis
                                var xbor = d3.min(x.range()), //margin.left + marginAxis.left,
                                xmin = xbor - strokeLength, xmax = d3.max(x.range()), // width - margin.right - marginAxis.right,
                                ybor = d3.max(y.range()), //height - margin.bottom - marginAxis.bottom,
                                ymin = d3.min(y.range()), //margin.top + marginAxis.top,
                                ymax = ybor + strokeLength;
                                // y-axis, max
                                chart.append('line')
                                    .attr("x1", xmin)
                                    .attr("y1", ymin)
                                    .attr("x2", xbor)
                                    .attr("y2", ymin)
                                    .attr("stroke", "black");
                                chart.append("text")
                                    .attr("x", xmin - 2)
                                    .attr("y", ymin)
                                    .attr("dy", ".35em")
                                    .style("text-anchor", "end")
                                    .text();
                                // y-axis, min
                                chart.append('line')
                                    .attr("x1", xmin)
                                    .attr("y1", ybor)
                                    .attr("x2", xbor)
                                    .attr("y2", ybor)
                                    .attr("stroke", "black");
                                chart.append("text")
                                    .attr("x", xmin - 2)
                                    .attr("y", ybor)
                                    .attr("dy", ".35em")
                                    .style("text-anchor", "end")
                                    .text(d3.min(y.domain()));
                                // x-axis, min
                                chart.append('line')
                                    .attr("x1", xbor)
                                    .attr("y1", ymax)
                                    .attr("x2", xbor)
                                    .attr("y2", ybor)
                                    .attr("stroke", "black");
                                chart.append("text")
                                    .attr("x", xbor)
                                    .attr("y", ymax + 9)
                                    .attr("dy", ".35em")
                                    .style("text-anchor", "start")
                                    .text(Charts.ChartHelpers.timestampToString(d3.min(x.domain())));
                                // x-axis, max
                                chart.append('line')
                                    .attr("x1", xmax)
                                    .attr("y1", ymax)
                                    .attr("x2", xmax)
                                    .attr("y2", ybor)
                                    .attr("stroke", "black");
                                chart.append("text")
                                    .attr("x", xmax)
                                    .attr("y", ymax + 9)
                                    .attr("dy", ".35em")
                                    .style("text-anchor", "end")
                                    .text(Charts.ChartHelpers.timestampToString(d3.max(x.domain())));
                            }
                            // draw a line at the current cursor position
                            var cursor = chart.append("line")
                                .attr("x1", 0)
                                .attr("y1", 0)
                                .attr("x2", 0)
                                .attr("y2", 0)
                                .attr("opacity", 0)
                                .attr("stroke", "black");
                            var timestampText = chart.append("text")
                                .attr("x", 0)
                                .attr("y", 0)
                                .attr("dy", ".35em")
                                .attr("opacity", 0)
                                .style("text-anchor", "end")
                                .text("");
                            var measurementText = chart.append("text")
                                .attr("x", 0)
                                .attr("y", 0)
                                .attr("dy", ".35em")
                                .attr("opacity", 0)
                                .text("");
                            var pathEl = path.node();
                            var pathLength = pathEl.getTotalLength();
                            chart
                                .on("mouseout", function () {
                                cursor.attr("opacity", 0);
                                timestampText.attr("opacity", 0);
                                measurementText.attr("opacity", 0);
                            })
                                .on("mousemove", function () {
                                var offsetLeft = element[0].getBoundingClientRect().left;
                                var xpos = d3.event.clientX - offsetLeft;
                                var beginning = xpos, end = pathLength, target;
                                while (true) {
                                    target = Math.floor((beginning + end) / 2);
                                    var pos = pathEl.getPointAtLength(target);
                                    if ((target === end || target === beginning) && pos.x !== xpos) {
                                        break;
                                    }
                                    if (pos.x > xpos)
                                        end = target;
                                    else if (pos.x < xpos)
                                        beginning = target;
                                    else
                                        break; //position found
                                }
                                // using the x scale, in this case a d3 time scale
                                // use the .invert() function to interpolate a date along the scale
                                // given the x-coordinates of the mouse
                                var t0 = x.invert(d3.mouse(this)[0]);
                                // using the interpolated date, find an index in the sorted data
                                // this would be the index suitable for insertion
                                var i = bisect(data, t0, 1);
                                if (0 < i && i < data.length) {
                                    // now that we know where in the data the interpolated date would "fit"
                                    // between two values, pull them both back as temporaries
                                    var d0 = data[i - 1];
                                    var d1 = data[i];
                                    // now, examine which of the two dates we are "closer" to
                                    // to do this, compare the delta values
                                    var d = t0 - d0.time > d1.time - t0 ? d1 : d0;
                                }
                                else if (i <= 0)
                                    d = data[0];
                                else
                                    d = data[data.length - 1];
                                xpos = x(d.time);
                                // draw
                                cursor
                                    .attr("x1", xpos)
                                    .attr("y1", 0)
                                    .attr("x2", xpos)
                                    .attr("y2", d3.max(y.range()) + (strokeLength || 0))
                                    .attr("opacity", 1);
                                timestampText
                                    .attr("x", xpos - 6)
                                    .attr("y", 4)
                                    .attr("dy", ".35em")
                                    .attr("opacity", 1)
                                    .text((d === data[0]) ? '' : Charts.ChartHelpers.timestampToString(d.time)); //Don't show timestamp for the first measurement, as it does not fit. Other option is to print it underneath the measurement value.
                                measurementText
                                    .attr("x", xpos + 6)
                                    .attr("y", 4)
                                    .attr("dy", ".35em")
                                    .attr("opacity", 1)
                                    .text(d.measurement);
                            });
                        }
                    });
                    doDraw();
                    scope.$watchCollection("sensor", function () { doDraw(); });
                    scope.$watch("update", function () {
                        doDraw();
                    });
                    //scope.closed = true;
                }
            };
        }]);
})(Charts || (Charts = {}));

var Directives;
(function (Directives) {
    var Clock;
    (function (Clock) {
        /**
         * Config
         */
        var moduleName = 'csComp';
        try {
            Clock.myModule = angular.module(moduleName);
        }
        catch (err) {
            // named module does not exist, so create one
            Clock.myModule = angular.module(moduleName, []);
        }
        /**
          * Directive to show the time.
          */
        Clock.myModule.directive('clock', ['dateFilter', function (dateFilter) {
                return {
                    restrict: 'E',
                    scope: {
                        time: '@',
                        format: '@'
                    },
                    link: function (scope, element, attrs) {
                        function updateTime() {
                            element.html(dateFilter(scope.time, scope.format));
                        }
                        scope.$watch('time', function (value) {
                            updateTime();
                        });
                    }
                };
            }]);
    })(Clock = Directives.Clock || (Directives.Clock = {}));
})(Directives || (Directives = {}));

var Helpers;
(function (Helpers) {
    var ContextMenu;
    (function (ContextMenu) {
        /**
         * Config
         */
        var moduleName = 'csComp';
        try {
            ContextMenu.myModule = angular.module(moduleName);
        }
        catch (err) {
            // named module does not exist, so create one
            ContextMenu.myModule = angular.module(moduleName, []);
        }
        /**
          * Directive to resize an element by settings its width or height,
          * for example to make sure that the scrollbar appears.
          * Typical usage:
          * <div style="overflow-y: auto; overflow-x: hidden" resize resize-x="20" resize-y="250">...</div>
          * Load the directive in your module, e.g.
          * angular.module('myWebApp', ['csWeb.resize'])
          */
        ContextMenu.myModule.directive('contextMenu', function ($parse) {
            var renderContextMenu = function ($scope, event, options) {
                if (!$) {
                    var $ = angular.element;
                }
                $(event.currentTarget).addClass('context');
                var $contextMenu = $('<div>');
                $contextMenu.addClass('dropdown clearfix');
                var $ul = $('<ul>');
                $ul.addClass('dropdown-menu');
                $ul.attr({ 'role': 'menu' });
                $ul.css({
                    display: 'block',
                    position: 'absolute',
                    left: event.pageX + 'px',
                    top: event.pageY + 'px'
                });
                angular.forEach(options, function (item, i) {
                    var $li = $('<li>');
                    if (item === null) {
                        $li.addClass('divider');
                    }
                    else {
                        var $a = $('<a>');
                        $a.attr({ tabindex: '-1', href: '#' });
                        $a.text(typeof item[0] == 'string' ? item[0] : item[0].call($scope, $scope));
                        $li.append($a);
                        $li.on('click', function ($event) {
                            $event.preventDefault();
                            $scope.$apply(function () {
                                $(event.currentTarget).removeClass('context');
                                $contextMenu.remove();
                                item[1].call($scope, $scope);
                            });
                        });
                    }
                    $ul.append($li);
                });
                $contextMenu.append($ul);
                var height = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight);
                $contextMenu.css({
                    width: '100%',
                    height: height + 'px',
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    zIndex: 9999
                });
                $(document).find('body').append($contextMenu);
                $contextMenu.on("mousedown", function (e) {
                    if ($(e.target).hasClass('dropdown')) {
                        $(event.currentTarget).removeClass('context');
                        $contextMenu.remove();
                    }
                }).on('contextmenu', function (event) {
                    $(event.currentTarget).removeClass('context');
                    event.preventDefault();
                    $contextMenu.remove();
                });
            };
            return function ($scope, element, attrs) {
                element.on('contextmenu', function (event) {
                    $scope.$apply(function () {
                        event.preventDefault();
                        var options = $scope.$eval(attrs.contextMenu);
                        if (options instanceof Array) {
                            renderContextMenu($scope, event, options);
                        }
                        else {
                            throw '"' + attrs.contextMenu + '" not an array';
                        }
                    });
                });
            };
        });
    })(ContextMenu = Helpers.ContextMenu || (Helpers.ContextMenu = {}));
})(Helpers || (Helpers = {}));

var DataTable;
(function (DataTable) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        DataTable.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        DataTable.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a feature's properties in a panel.
      *
      * @seealso : http://www.youtube.com/watch?v=gjJ5vLRK8R8&list=UUGD_0i6L48hucTiiyhb5QzQ
      * @seealso : http://plnkr.co/edit/HyBP9d?p=preview
      */
    DataTable.myModule.directive('datatable', ['$compile',
        function ($compile) {
            return {
                terminal: false,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/DataTable/DataTable.tpl.html',
                replace: true,
                transclude: true,
                controller: DataTable.DataTableCtrl
            };
        }
    ]);
})(DataTable || (DataTable = {}));

var DataTable;
(function (DataTable) {
    /**
     * Represents a field in the table.
     * The value is the actual displayValue shown, the type is the propertyType type (e.g. number or text, useful when aligning the data), and the header is used for sorting.
     */
    var TableField = (function () {
        function TableField(displayValue, originalValue, type, header) {
            this.displayValue = displayValue;
            this.originalValue = originalValue;
            this.type = type;
            this.header = header;
        }
        return TableField;
    })();
    DataTable.TableField = TableField;
    var DataTableCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function DataTableCtrl($scope, $http, $sce, $translate, $timeout, $layerService, $localStorageService, $messageBusService) {
            var _this = this;
            this.$scope = $scope;
            this.$http = $http;
            this.$sce = $sce;
            this.$translate = $translate;
            this.$timeout = $timeout;
            this.$layerService = $layerService;
            this.$localStorageService = $localStorageService;
            this.$messageBusService = $messageBusService;
            this.mapLabel = "map";
            this.numberOfItems = 10;
            this.layerOptions = [];
            this.propertyTypes = [];
            this.headers = [];
            this.rows = [];
            // 'vm' stands for 'view model'. We're adding a reference to the controller to the scope
            // for its methods to be accessible from view / HTML
            $scope.vm = this;
            if (this.layerOptions && this.layerOptions.length > 0) {
                $translate('MAP_FEATURES').then(function (translation) {
                    _this.layerOptions[0].title = translation;
                });
            }
            this.bindToStorage('vm.numberOfItems', 10);
            this.numberOfItems = $localStorageService.get('vm.numberOfItems');
            this.bindToStorage('vm.selectedLayerId', this.mapLabel);
            if (this.$layerService.project == null || this.$layerService.project.groups == null)
                return;
            this.updateLayerOptions();
            this.loadLayer();
            this.selectAllBool = false;
            $translate('SELECT_ALL').then(function (translation) {
                _this.selectAllText = translation;
            });
            $messageBusService.publish('timeline', 'isEnabled', 'false');
        }
        /**
         * Add a label to local storage and bind it to the scope.
         */
        DataTableCtrl.prototype.bindToStorage = function (label, defaultValue) {
            if (this.$localStorageService.get(label) === null)
                this.$localStorageService.set(label, defaultValue); // You first need to set the key
            this.$localStorageService.bind(this.$scope, label);
        };
        /**
         * Create a list of layer options and select the one used previously.
         */
        DataTableCtrl.prototype.updateLayerOptions = function () {
            var _this = this;
            var chooseLayerOption = {
                "group": '',
                "id": this.mapLabel,
                "title": '' //this.$translate("CHOOSE_CATEGORY")//this.mapFeatureTitle
            };
            this.layerOptions.push(chooseLayerOption);
            this.$translate("CHOOSE_CATEGORY").then(function (translation) {
                chooseLayerOption.title = translation;
            });
            if (this.$layerService.project == null || this.$layerService.project.groups == null)
                return;
            this.$layerService.project.groups.forEach(function (group) {
                group.layers.forEach(function (layer) {
                    _this.layerOptions.push({
                        "group": group.title,
                        "id": layer.id,
                        "title": layer.title
                    });
                });
            });
            for (var layerKey in this.$layerService.loadedLayers) {
                if (this.selectedLayerId == null) {
                    return;
                }
                var layer = this.$layerService.loadedLayers[layerKey];
                if (layer.enabled) {
                    this.selectedLayerId = layer.id;
                }
            }
            ;
            //this.selectedLayerId =  //this.$localStorageService.get('vm.selectedLayerId');
        };
        DataTableCtrl.prototype.loadLayer = function () {
            var _this = this;
            if (!this.selectedLayerId || this.selectedLayerId === this.mapLabel)
                return this.loadMapLayers();
            var selectedLayer = this.findLayerById(this.selectedLayerId);
            if (selectedLayer == null)
                return this.loadMapLayers();
            async.series([
                function (callback) {
                    if (selectedLayer.typeUrl != null) {
                        _this.$layerService.loadTypeResources(selectedLayer.typeUrl, true, function () {
                            callback();
                        });
                    }
                    else {
                        callback();
                    }
                },
                function (callback) {
                    _this.$http.get(selectedLayer.url).
                        success(function (data) {
                        _this.dataset = data;
                        if (data.featureTypes == null)
                            data.featureTypes = {};
                        if (data.features) {
                            data.features.forEach(function (f) {
                                if (f.properties.hasOwnProperty('FeatureTypeId')) {
                                    f.featureTypeName = f.properties['FeatureTypeId'];
                                }
                                else if (data.featureTypes.hasOwnProperty('Default')) {
                                    f.featureTypeName = 'Default';
                                }
                                else if (selectedLayer.defaultFeatureType != null && selectedLayer.defaultFeatureType != "") {
                                    f.featureTypeName = selectedLayer.defaultFeatureType;
                                }
                                if (!(f.featureTypeName in data.featureTypes))
                                    data.featureTypes[f.featureTypeName] = _this.$layerService.getFeatureType(f);
                            });
                            _this.updatepropertyType(data);
                        }
                        callback();
                    }).
                        error(function (data, status, headers, config) {
                        _this.$messageBusService.notify("ERROR opening " + selectedLayer.title, "Could not get the data.");
                        callback();
                    });
                }
            ]);
        };
        /**
         * Load the features as visible on the map.
         */
        DataTableCtrl.prototype.loadMapLayers = function () {
            var _this = this;
            this.selectedLayerId = this.mapLabel;
            var data = {
                type: '',
                features: [],
                featureTypes: {}
            };
            // If we are filtering, load the filter results
            this.$layerService.project.groups.forEach(function (group) {
                if (group.filterResult != null)
                    group.filterResult.forEach(function (f) { return data.features.push(f); });
            });
            // Otherwise, take all loaded features
            if (data.features.length === 0)
                data.features = this.$layerService.project.features;
            data.features.forEach(function (f) {
                if (!(f.featureTypeName in data.featureTypes))
                    data.featureTypes[f.featureTypeName] = _this.$layerService.getFeatureType(f);
            });
            this.dataset = data;
            this.updatepropertyType(data);
        };
        DataTableCtrl.prototype.updatepropertyType = function (data) {
            var _this = this;
            this.propertyTypes = [];
            this.headers = [];
            this.rows = [];
            var titles = [];
            var mis = [];
            // Push the Name, so it always appears on top.
            /* rely on namelabel to determine the first property
            mis.push({
                label: "Name",
                visibleInCallOut: true,
                title: "Naam",
                type: "text",
                filterType: "text",
                isSearchable: true
            });
            */
            var featureType;
            for (var key in data.featureTypes) {
                featureType = data.featureTypes[key];
                if (featureType.propertyTypeData != null) {
                    featureType.propertyTypeData.forEach(function (ptd) {
                        if (featureType.style.nameLabel == ptd.label) {
                            mis.splice(0, 0, ptd);
                        }
                        else {
                            mis.push(ptd);
                        }
                    });
                }
                if (featureType.propertyTypeKeys != null) {
                    var keys = featureType.propertyTypeKeys.split(';');
                    keys.forEach(function (k) {
                        var propertyType = null;
                        if (k in _this.$layerService.propertyTypeData)
                            propertyType = _this.$layerService.propertyTypeData[k];
                        else if (featureType.propertyTypeData != null) {
                            var result = $.grep(featureType.propertyTypeData, function (e) { return e.label === k; });
                            //if (result.length >= 1) mis.push(result[0]);
                            if (result.length >= 1)
                                propertyType = result[0];
                        }
                        if (propertyType != null) {
                            if (featureType.style.nameLabel == propertyType.label) {
                                mis.splice(0, 0, propertyType);
                            }
                            else {
                                mis.push(propertyType);
                            }
                        }
                    });
                }
                else if (featureType.propertyTypeData != null) {
                    featureType.propertyTypeData.forEach(function (mi) {
                        //mis.push(mi)
                        if (featureType.style.nameLabel == mi.label) {
                            mis.splice(0, 0, mi);
                        }
                        else {
                            mis.push(mi);
                        }
                        /*
                        var existingMis = mis.filter(existingMi=>existingMi.title == mi.title);
                        if (existingMis.length > 0) {
                          mis.splice(mis.indexOf(existingMis[0]),1,mi);
                        } else {
                          mis.push(mi);
                        }
                        */
                    });
                }
                mis.forEach(function (mi) {
                    if ((mi.visibleInCallOut || mi.label === "Name") && titles.indexOf(mi.title) < 0) {
                        titles.push(mi.title);
                        _this.propertyTypes.push(mi);
                    }
                });
            }
            // Add lat-lon coordinates for point features
            this.propertyTypes.push(csComp.Helpers.GeoExtensions.createPropertyType('Lat'));
            this.propertyTypes.push(csComp.Helpers.GeoExtensions.createPropertyType('Lon'));
            // Select the first couple of headers
            var nmbrOfDefaultSelectedHeaders = 3;
            for (var i = 0; i < nmbrOfDefaultSelectedHeaders; i++) {
                this.headers.push(titles[i]);
            }
            this.rows = this.getRows();
        };
        DataTableCtrl.prototype.toggleSelection = function (propertyTypeTitle) {
            var idx = this.headers.indexOf(propertyTypeTitle);
            // is currently selected
            if (idx > -1) {
                this.headers.splice(idx, 1);
            }
            else {
                this.headers.push(propertyTypeTitle);
            }
            this.rows = this.getRows();
        };
        DataTableCtrl.prototype.findLayerById = function (id) {
            for (var i = 0; i < this.$layerService.project.groups.length; i++) {
                var group = this.$layerService.project.groups[i];
                for (var j = 0; j < group.layers.length; j++) {
                    var layer = group.layers[j];
                    if (layer.id != id)
                        continue;
                    return layer;
                }
            }
            return null;
        };
        /**
         * Returns the data rows that are relevant for the current selection.
         */
        DataTableCtrl.prototype.getRows = function () {
            var _this = this;
            var meta = [this.headers.length];
            this.propertyTypes.forEach(function (mi) {
                // Keep headers and mi in the right order
                var index = _this.headers.indexOf(mi.title);
                if (index >= 0)
                    meta[index] = mi;
            });
            var props = [];
            var displayValue;
            if (this.dataset && this.dataset.features) {
                this.dataset.features.forEach(function (f) {
                    var row = [];
                    meta.forEach(function (mi) {
                        if (mi.label === 'Lat') {
                            (f.geometry.type === 'Point') ? displayValue = f.geometry.coordinates[1] : displayValue = '';
                            text = displayValue;
                        }
                        else if (mi.label === 'Lon') {
                            (f.geometry.type === 'Point') ? displayValue = f.geometry.coordinates[0] : displayValue = '';
                            text = displayValue;
                        }
                        else {
                            var text = f.properties[mi.label];
                            displayValue = csComp.Helpers.convertPropertyInfo(mi, text);
                        }
                        //if (!text)
                        //    text = ' ';
                        //else if (!$.isNumeric(text))
                        //    text = text.replace(/&amp;/g, '&');
                        //switch (mi.type) {
                        //    case "bbcode":
                        //        displayValue = XBBCODE.process({ text: text }).html;
                        //        break;
                        //    case "number":
                        //        if (!$.isNumeric(text)) displayValue ='??';
                        //        else if (!mi.stringFormat)
                        //            displayValue = text.toString();
                        //        else
                        //            displayValue = String.format(mi.stringFormat, parseFloat(text));
                        //        break;
                        //    default:
                        //        displayValue = text;
                        //        break;
                        //}
                        row.push(new TableField(displayValue, text, mi.type, mi.title));
                    });
                    props.push(row);
                });
            }
            return props;
        };
        /**
         * Generate a font awesome class based on the order.
         */
        DataTableCtrl.prototype.sortOrderClass = function (headerIndex, reverseOrder) {
            var t;
            if (reverseOrder != null && headerIndex == this.sortingColumn) {
                t = ('fa fa-sort-' + ((reverseOrder) ? 'desc' : 'asc'));
            }
            else {
                t = 'fa fa-sort';
            }
            return t;
        };
        /**
         * Order the rows based on the header index and the order.
         */
        DataTableCtrl.prototype.orderBy = function (headerIndex, reverseOrder) {
            this.sortingColumn = headerIndex;
            this.rows = this.rows.sort(function (a, b) {
                var order; // Original sort order
                if (a[headerIndex].type == 'number')
                    order = a[headerIndex].originalValue > b[headerIndex].originalValue;
                else
                    order = a[headerIndex].originalValue.toLowerCase() > b[headerIndex].originalValue.toLowerCase();
                if (order == reverseOrder)
                    return 1;
                else
                    return -1;
            });
        };
        DataTableCtrl.prototype.downloadGeoJson = function () {
            var _this = this;
            var geoJsonString = '{"type": "FeatureCollection",' +
                '"featureTypes": ' +
                JSON.stringify(this.dataset.featureTypes, function (key, val) { return (key === '$$hashKey') ? undefined : val; });
            //geoJsonString += ', "features" : [';
            geoJsonString += ', "features": [';
            this.dataset.features.forEach(function (f) {
                var cleanFeature = new csComp.Services.Feature();
                cleanFeature.type = f.type;
                cleanFeature.properties = f.properties;
                cleanFeature.geometry = f.geometry;
                geoJsonString += JSON.stringify(cleanFeature) + ',';
            });
            geoJsonString = geoJsonString.substring(0, geoJsonString.length - 1) + ']}';
            var filename = this.mapLabel;
            if (this.selectedLayerId !== this.mapLabel) {
                var layer = this.findLayerById(this.selectedLayerId);
                if (layer)
                    filename = layer.title.replace(' ', '_');
            }
            this.$timeout(function () {
                var data = _this.$layerService.project.serialize();
                //console.log(data);
                console.log("Save settings: ");
                csComp.Helpers.saveData(geoJsonString, filename, "json");
            }, 0);
        };
        DataTableCtrl.prototype.downloadCsv = function () {
            var _this = this;
            var csvRows = [];
            csvRows.push(this.headers.join(';'));
            for (var i = 0; i < this.rows.length; i++) {
                csvRows.push(this.rows[i].map(function (f) { return f.originalValue; }).join(';'));
            }
            var csvString = csvRows.join('\r\n');
            var filename = this.mapLabel;
            if (this.selectedLayerId !== this.mapLabel) {
                var layer = this.findLayerById(this.selectedLayerId);
                if (layer)
                    filename = layer.title.replace(' ', '_');
            }
            //this.saveData(csvString, filename + '.csv');
            this.$timeout(function () {
                var data = _this.$layerService.project.serialize();
                //console.log(data);
                console.log("Save settings: ");
                csComp.Helpers.saveData(csvString, filename, "csv");
            }, 0);
        };
        // private saveData(csvData: string, filename: string) {
        //     if (navigator.msSaveBlob) {
        //         // IE 10+
        //         var link: any = document.createElement('a');
        //         link.addEventListener("click", event => {
        //             var blob = new Blob([csvData], {"type": "text/csv;charset=utf-8;"});
        //             navigator.msSaveBlob(blob, filename);
        //         }, false);
        //         document.body.appendChild(link);
        //         link.click();
        //         document.body.removeChild(link);
        //     } else if (!csComp.Helpers.supportsDataUri()) {
        //         // Older versions of IE: show the data in a new window
        //         var popup = window.open('', 'csv', '');
        //         popup.document.body.innerHTML = '<pre>' + csvData + '</pre>';
        //     } else {
        //         // Support for browsers that support the data uri.
        //         var a: any = document.createElement('a');
        //         document.body.appendChild(a);
        //         a.href = 'data:text/csv;charset=utf-8,' + encodeURI(csvData);
        //         a.target = '_blank';
        //         a.download = filename;
        //         a.click();
        //         document.body.removeChild(a);
        //     }
        // }
        DataTableCtrl.prototype.selectAll = function () {
            var _this = this;
            if (this.selectAllBool) {
                this.$translate('SELECT_ALL').then(function (translation) {
                    _this.selectAllText = translation;
                });
                this.propertyTypes.forEach(function (mi) {
                    var idx = _this.headers.indexOf(mi.title);
                    if (idx > -1) {
                        _this.headers.splice(idx, 1);
                    }
                });
                this.rows = this.getRows();
            }
            else {
                this.$translate('DESELECT_ALL').then(function (translation) {
                    _this.selectAllText = translation;
                });
                this.propertyTypes.forEach(function (mi) {
                    if (_this.headers.indexOf(mi.title) <= -1) {
                        _this.headers.push(mi.title);
                    }
                });
                this.rows = this.getRows();
            }
            this.selectAllBool = !this.selectAllBool;
        };
        /**
         * Convert to trusted html string.
         */
        DataTableCtrl.prototype.toTrusted = function (html) {
            try {
                if (html === undefined || html === null)
                    return this.$sce.trustAsHtml(html);
                return this.$sce.trustAsHtml(html.toString());
            }
            catch (e) {
                console.log(e + ': ' + html);
                return '';
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        DataTableCtrl.$inject = [
            '$scope',
            '$http',
            '$sce',
            '$translate',
            '$timeout',
            'layerService',
            'localStorageService',
            'messageBusService'
        ];
        return DataTableCtrl;
    })();
    DataTable.DataTableCtrl = DataTableCtrl;
})(DataTable || (DataTable = {}));

var ExpertMode;
(function (ExpertMode) {
    /**
  * Config
  */
    var moduleName = 'csComp';
    try {
        ExpertMode.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        ExpertMode.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to set the expert mode, so we can determine what the user should see (degree of difficulty).
      * The expert mode can either be set manually, e.g. using this directive, or by setting the expertMode property in the
      * project.json file. In neither are set, we assume that we are dealing with an expert, so all features should be enabled.
      *
      * Precedence:
      * - when a declaration is absent, assume Expert.
      * - when the mode is set in local storage, take that value.
      * - when the mode is set in the project.json file, take that value.
      *
      * As we want the expertMode to be always available, we have added it to the MapService service.
      */
    ExpertMode.myModule
        .directive('expertMode', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/ExpertMode/ExpertMode.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    return function (scope) {
                        fn(scope);
                    };
                },
                //link: function (scope, element, attrs) {
                //     // Since we are wrapping the rating directive in this directive, I couldn't use transclude,
                //     // so I copy the existing attributes manually.
                //     var attributeString = '';
                //     for (var key in attrs) {
                //         if (key.substr(0, 1) !== '$' && attrs.hasOwnProperty(key)) attributeString += key + '="' + attrs[key] + '" ';
                //     }
                //     var html = '<rating ng-model="expertMode" '
                //         + attributeString
                //         + 'tooltip-html-unsafe="{{\'EXPERTMODE.EXPLANATION\' | translate}}" tooltip-placement="bottom" tooltip-trigger="mouseenter" tooltip-append-to-body="false"'
                //         + 'max="3"></rating>';
                //     var e = $compile(html)(scope);
                //     element.replaceWith(e);
                // },
                replace: true,
                transclude: true,
                controller: ExpertMode.ExpertModeCtrl
            };
        }
    ]);
})(ExpertMode || (ExpertMode = {}));

var ExpertMode;
(function (ExpertMode) {
    var Expertise = csComp.Services.Expertise;
    var ExpertModeCtrl = (function () {
        function ExpertModeCtrl($scope, $localStorageService, $layerService, $mapService, $messageBus) {
            var _this = this;
            this.$scope = $scope;
            this.$localStorageService = $localStorageService;
            this.$layerService = $layerService;
            this.$mapService = $mapService;
            this.$messageBus = $messageBus;
            $scope.vm = this;
            $scope.expertMode = $mapService.expertMode;
            $messageBus.subscribe('expertMode', function (title, mode) {
                if (title !== 'newExpertise')
                    return;
                $scope.expertMode = mode;
            });
            $scope.$watch('expertMode', function () {
                _this.setExpertMode($scope.expertMode);
            });
        }
        /**
        * Get the CSS class to render the mode.
        */
        ExpertModeCtrl.prototype.getCssClass = function () {
            switch (this.$mapService.expertMode) {
                case Expertise.Beginner:
                    return 'beginnerUserIcon';
                    break;
                case Expertise.Intermediate:
                    return 'intermediateUserIcon';
                    break;
                case Expertise.Expert:
                    return 'expertUserIcon';
                    break;
                case Expertise.Admin:
                    return 'adminExpertUserIcon';
                    break;
            }
        };
        /**
        * Set the expert mode: although we assume that each directive is responsible for managing it by listening
        * to the expertMode.newExpertise message, we already set some common options here.
        * This is to reduce the dependency on this directive.
        */
        ExpertModeCtrl.prototype.setExpertMode = function (expertMode) {
            this.$messageBus.publish('expertMode', 'newExpertise', expertMode);
        };
        ExpertModeCtrl.$inject = [
            '$scope',
            'localStorageService',
            'layerService',
            'mapService',
            'messageBusService'
        ];
        return ExpertModeCtrl;
    })();
    ExpertMode.ExpertModeCtrl = ExpertModeCtrl;
})(ExpertMode || (ExpertMode = {}));

var FeatureList;
(function (FeatureList) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        FeatureList.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        FeatureList.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    FeatureList.myModule.directive('featureList', [
        '$window', '$compile',
        function ($window, $compile) {
            return {
                terminal: false,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/FeatureList/FeatureList.tpl.html',
                //compile             : el          => {    // I need to explicitly compile it in order to use interpolation like {{xxx}}
                //    var fn                        = $compile(el);
                //    return scope                  => {
                //        fn(scope);
                //    };
                //},
                // Directives that want to modify the DOM typically use the link option.link takes a function with the following signature, function link(scope, element, attrs) { ... } where:
                // scope is an Angular scope object.
                // element is the jqLite - wrapped element that this directive matches.
                // attrs is a hash object with key - value pairs of normalized attribute names and their corresponding attribute values.
                link: function (scope, element, attrs) {
                    // Deal with resizing the element list
                    scope.onResizeFunction = function () {
                        var filterHeight = 50;
                        var paginationCtrlHeight = 100;
                        var itemHeight = 60;
                        //scope.windowHeight          = $window.innerHeight;
                        //scope.windowWidth           = $window.innerWidth;
                        scope.numberOfItems = Math.floor(($window.innerHeight - filterHeight - paginationCtrlHeight) / itemHeight);
                    };
                    // Call to the function when the page is first loaded
                    scope.onResizeFunction();
                    angular.element($window).bind('resize', function () {
                        scope.onResizeFunction();
                        scope.$apply();
                    });
                },
                replace: true,
                transclude: true,
                controller: FeatureList.FeatureListCtrl
            };
        }
    ]).directive('bsPopover', function () {
        return function (scope, element, attrs) {
            element.find("a[rel=popover]").popover({ placement: 'right', html: 'true' });
        };
    });
})(FeatureList || (FeatureList = {}));

var FeatureList;
(function (FeatureList) {
    var FeatureListCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function FeatureListCtrl($scope, $layerService, $mapService) {
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$mapService = $mapService;
            $scope.vm = this;
            $scope.numberOfItems = 10; // This is being reset in the directive upon receiving a resize.
        }
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        FeatureListCtrl.$inject = [
            '$scope',
            'layerService',
            'mapService'
        ];
        return FeatureListCtrl;
    })();
    FeatureList.FeatureListCtrl = FeatureListCtrl;
})(FeatureList || (FeatureList = {}));

var FeatureProps;
(function (FeatureProps) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        FeatureProps.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        FeatureProps.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a feature's properties in a panel.
      *
      * @seealso          : http://www.youtube.com/watch?v=gjJ5vLRK8R8&list=UUGD_0i6L48hucTiiyhb5QzQ
      * @seealso          : http://plnkr.co/edit/HyBP9d?p=preview
      */
    FeatureProps.myModule.directive('featureprops', ['$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/FeatureProps/FeatureProps.tpl.html',
                replace: true,
                transclude: true,
                controller: FeatureProps.FeaturePropsCtrl
            };
        }
    ]);
})(FeatureProps || (FeatureProps = {}));

var FeatureProps;
(function (FeatureProps) {
    var FeaturePropsOptions = (function () {
        function FeaturePropsOptions(position) {
            this.position = position;
            this.closeButton = true;
            this.autoPan = true;
        }
        return FeaturePropsOptions;
    })();
    var CallOutProperty = (function () {
        function CallOutProperty(key, value, property, canFilter, canStyle, feature, isFilter, isSensor, description, propertyType, timestamps, sensor) {
            this.key = key;
            this.value = value;
            this.property = property;
            this.canFilter = canFilter;
            this.canStyle = canStyle;
            this.feature = feature;
            this.isFilter = isFilter;
            this.isSensor = isSensor;
            this.description = description;
            this.propertyType = propertyType;
            this.timestamps = timestamps;
            this.sensor = sensor;
            this.cors = {};
        }
        return CallOutProperty;
    })();
    FeatureProps.CallOutProperty = CallOutProperty;
    var CallOutSection = (function () {
        function CallOutSection(sectionIcon) {
            this.propertyTypes = {};
            this.properties = [];
            this.sectionIcon = sectionIcon;
        }
        CallOutSection.prototype.showSectionIcon = function () { return !csComp.StringExt.isNullOrEmpty(this.sectionIcon); };
        CallOutSection.prototype.addProperty = function (key, value, property, canFilter, canStyle, feature, isFilter, description, propertyType) {
            var isSensor = feature.sensors && feature.sensors.hasOwnProperty(property);
            if (isSensor)
                this.properties.push(new CallOutProperty(key, value, property, canFilter, canStyle, feature, isFilter, isSensor, description ? description : null, propertyType, feature.timestamps, feature.sensors[property]));
            else
                this.properties.push(new CallOutProperty(key, value, property, canFilter, canStyle, feature, isFilter, isSensor, description ? description : null, propertyType));
        };
        CallOutSection.prototype.hasProperties = function () {
            return this.properties != null && this.properties.length > 0;
        };
        return CallOutSection;
    })();
    FeatureProps.CallOutSection = CallOutSection;
    var CallOut = (function () {
        function CallOut(type, feature, propertyTypeData, layerservice, mapservice) {
            var _this = this;
            this.type = type;
            this.feature = feature;
            this.propertyTypeData = propertyTypeData;
            this.layerservice = layerservice;
            this.mapservice = mapservice;
            this.sections = {};
            this.sectionKeys = [];
            this.hasInfoSection = false;
            //if (type == null) this.createDefaultType();
            this.setTitle();
            this.setIcon(feature);
            var infoCallOutSection = new CallOutSection('fa-info');
            var searchCallOutSection = new CallOutSection('fa-filter');
            var hierarchyCallOutSection = new CallOutSection('fa-link');
            var displayValue;
            if (type != null) {
                var propertyTypes = csComp.Helpers.getPropertyTypes(type, propertyTypeData);
                if (propertyTypes.length === 0) {
                    for (var pt in layerservice.propertyTypeData)
                        propertyTypes.push(layerservice.propertyTypeData[pt]);
                }
                ;
                //
                if (type.showAllProperties || this.mapservice.isAdminExpert) {
                    var missing = csComp.Helpers.getMissingPropertyTypes(feature);
                    missing.forEach(function (pt) {
                        if (!propertyTypes.some((function (p) { return p.label === pt.label; }))) {
                            propertyTypes.push(pt);
                        }
                    });
                }
                propertyTypes.forEach(function (mi) {
                    if (feature.properties.hasOwnProperty(mi.label) && mi.visibleInCallOut) {
                        var callOutSection = _this.getOrCreateCallOutSection(mi.section) || infoCallOutSection;
                        if (callOutSection.propertyTypes.hasOwnProperty(mi.label))
                            return; // Prevent duplicate properties in the same  section
                        callOutSection.propertyTypes[mi.label] = mi;
                        var text = feature.properties[mi.label];
                        if (mi.type === "hierarchy") {
                            var count = _this.calculateHierarchyValue(mi, feature, propertyTypeData, layerservice);
                            text = count + ";" + feature.properties[mi.calculation];
                        }
                        displayValue = csComp.Helpers.convertPropertyInfo(mi, text);
                        // Skip empty, non-editable values
                        if (!mi.canEdit && csComp.StringExt.isNullOrEmpty(displayValue))
                            return;
                        var canFilter = (mi.type === "number" || mi.type === "text" || mi.type === "options" || mi.type === "date" || mi.type === 'boolean');
                        var canStyle = (mi.type === "number" || mi.type === "options" || mi.type === "color");
                        if (mi.filterType != null)
                            canFilter = mi.filterType.toLowerCase() != "none";
                        if (mi.visibleInCallOut) {
                            callOutSection.addProperty(mi.title, displayValue, mi.label, canFilter, canStyle, feature, false, mi.description, mi);
                        }
                        if (mi.type === "hierarchy") {
                            hierarchyCallOutSection.addProperty(mi.title, displayValue, mi.label, canFilter, canStyle, feature, false, mi.description, mi);
                        }
                        searchCallOutSection.addProperty(mi.title, displayValue, mi.label, canFilter, canStyle, feature, false, mi.description);
                    }
                });
            }
            if (infoCallOutSection.properties.length > 0) {
                this.hasInfoSection = true;
                this.sections['Aaa Info'] = infoCallOutSection; // The AAA is added as the sections are sorted alphabetically (not anymore in angular 1.4!!!)
                this.sectionKeys.push('Aaa Info');
            }
            else {
                this.hasInfoSection = false;
            }
            if (hierarchyCallOutSection.properties.length > 0) {
                this.sections['hierarchy'] = hierarchyCallOutSection;
                this.sectionKeys.push('hierarchy');
            }
            //if (searchCallOutSection.properties.length > 0) {this.sections['zzz Search'] = searchCallOutSection; this.sectionKeys.push('zzz Search');}
            this.sectionKeys = this.sectionKeys.sort();
        }
        CallOut.prototype.calculateHierarchyValue = function (mi, feature, propertyTypeData, layerservice) {
            var countResults = [];
            var result = -1;
            var propertyTypes = csComp.Helpers.getPropertyTypes(feature.fType, propertyTypeData);
            for (var p in propertyTypes) {
                var pt = propertyTypes[p];
                if (pt.type === "relation" && mi.targetrelation === pt.label) {
                    countResults[pt.label] = pt.count;
                    if (mi.calculation === "count") {
                        result = pt.count;
                    }
                }
            }
            if (mi.calculation === "ratio") {
                var featureName = feature.properties[mi.subject];
                layerservice.project.features.forEach(function (f) {
                    if (f.properties.hasOwnProperty(mi.target) && f.properties[mi.target] === featureName) {
                        if (f.properties.hasOwnProperty(mi.targetproperty)) {
                            result = +f.properties[mi.targetproperty] / countResults[mi.targetrelation];
                        }
                    }
                });
            }
            return result;
        };
        CallOut.prototype.sectionCount = function () {
            return this.sectionKeys.length;
        };
        CallOut.prototype.firstSection = function () {
            var first = this.sections[this.sectionKeys[0]];
            return first;
        };
        CallOut.prototype.lastSection = function () {
            var last = this.sections[this.sectionKeys[this.sectionKeys.length - 1]];
            return last;
        };
        CallOut.prototype.getOrCreateCallOutSection = function (sectionTitle) {
            if (!sectionTitle) {
                return null;
            }
            if (sectionTitle in this.sections)
                return this.sections[sectionTitle];
            this.sections[sectionTitle] = new CallOutSection();
            this.sectionKeys.push(sectionTitle);
            return this.sections[sectionTitle];
        };
        /**
         * Set the title of the callout to the title of the feature.
         */
        CallOut.prototype.setTitle = function () {
            this.title = csComp.Helpers.featureTitle(this.type, this.feature);
        };
        CallOut.prototype.setIcon = function (feature) {
            this.icon = (this.type == null || this.type.style == null || !this.type.style.hasOwnProperty('iconUri') || this.type.style.iconUri.toLowerCase().indexOf('_media') >= 0)
                ? ''
                : this.type.style.iconUri.indexOf('{') >= 0
                    ? csComp.Helpers.convertStringFormat(feature, this.type.style.iconUri)
                    : this.type.style.iconUri;
        };
        return CallOut;
    })();
    FeatureProps.CallOut = CallOut;
    var FeaturePropsCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function FeaturePropsCtrl($scope, $location, $sce, $mapService, $layerService, $messageBusService, $translate) {
            var _this = this;
            this.$scope = $scope;
            this.$location = $location;
            this.$sce = $sce;
            this.$mapService = $mapService;
            this.$layerService = $layerService;
            this.$messageBusService = $messageBusService;
            this.$translate = $translate;
            this.stats = [];
            this.updateAllStatsDelay = _.debounce(this.updateAllStats, 500);
            this.updateStatsDelay = function (prop) { _.debounce(_this.getPropStats, 500, true); };
            /**
             * Callback function
             * @see {http://stackoverflow.com/questions/12756423/is-there-an-alias-for-this-in-typescript}
             * @see {http://stackoverflow.com/questions/20627138/typescript-this-scoping-issue-when-called-in-jquery-callback}
             * @todo {notice the strange syntax using a fat arrow =>, which is to preserve the this reference in a callback!}
             */
            this.sidebarMessageReceived = function (title) {
                //console.log("sidebarMessageReceived");
                switch (title) {
                    case "toggle":
                        _this.$scope.showMenu = !_this.$scope.showMenu;
                        break;
                    case "show":
                        _this.$scope.showMenu = true;
                        break;
                    case "hide":
                        _this.$scope.showMenu = false;
                        break;
                    default:
                }
                // NOTE EV: You need to call apply only when an event is received outside the angular scope.
                // However, make sure you are not calling this inside an angular apply cycle, as it will generate an error.
                if (_this.$scope.$root.$$phase != '$apply' && _this.$scope.$root.$$phase != '$digest') {
                    _this.$scope.$apply();
                }
            };
            this.featureMessageReceived = function (title, feature) {
                switch (title) {
                    case "onFeatureDeselect":
                        if (_this.$layerService.selectedFeatures.length === 0) {
                            _this.$layerService.visual.rightPanelVisible = false;
                        }
                        else {
                            _this.updateAllStats();
                        }
                        break;
                    case "onFeatureSelect":
                        _this.displayFeature(_this.$layerService.lastSelectedFeature);
                        _this.$scope.feature = _this.$layerService.lastSelectedFeature;
                        _this.$layerService.visual.rightPanelVisible = true;
                        _this.updateAllStats();
                        break;
                    case "onRelationsUpdated":
                        _this.setShowSimpleTimeline();
                        _this.displayFeature(feature);
                        _this.updateHierarchyLinks(feature);
                        _this.$scope.feature = feature;
                        _this.$scope.autocollapse(true);
                        break;
                    case "onFeatureUpdated":
                        _this.displayFeature(_this.$layerService.lastSelectedFeature);
                        _this.$scope.feature = _this.$layerService.lastSelectedFeature;
                        break;
                    default:
                }
                if (_this.$scope.$root.$$phase != '$apply' && _this.$scope.$root.$$phase != '$digest') {
                    _this.$scope.$apply();
                }
            };
            this.timestamps = new Array();
            this.setDropdownTitle();
            this.scope = $scope;
            $scope.vm = this;
            $scope.showMenu = false;
            $scope.featureTabActivated = function (sectionTitle, section) {
                $messageBusService.publish('FeatureTab', 'activated', { sectionTitle: sectionTitle, section: section });
            };
            //$messageBusService.subscribe("sidebar", this.sidebarMessageReceived);
            console.log('init featurepropsctrl');
            $messageBusService.subscribe("feature", this.featureMessageReceived);
            var widthOfList = function () {
                var itemsWidth = 0;
                $('#featureTabs>li').each(function () {
                    var itemWidth = $(this).outerWidth();
                    itemsWidth += itemWidth;
                });
                return itemsWidth;
            };
            $scope.autocollapse = function (initializeTabPosition) {
                if (initializeTabPosition === void 0) { initializeTabPosition = false; }
                var tabs = $('#featureTabs');
                if (tabs.outerWidth() < widthOfList() || parseFloat(tabs.css('margin-left')) < 0) {
                    $('#leftArr').show();
                    $('#rightArr').show();
                    if (initializeTabPosition) {
                        tabs.animate({ 'margin-left': '20px' }, 'slow');
                    }
                }
                else {
                    $('#leftArr').hide();
                    $('#rightArr').hide();
                    if (initializeTabPosition) {
                        tabs.animate({ 'margin-left': '0px' }, 'slow');
                    }
                }
            };
            $scope.autocollapse(true); // when document first loads
            $scope.tabs = $('#featureTabs');
            $scope.tabScrollDelta = $scope.tabs.outerWidth();
            this.displayFeature(this.$layerService.lastSelectedFeature);
            this.$scope.feature = this.$layerService.lastSelectedFeature;
            this.$messageBusService.subscribe("timeline", function (action, value) {
                if (action === "updateFeatures" && _this.$scope.callOut) {
                    _this.updateAllStatsDelay();
                }
            });
        }
        FeaturePropsCtrl.prototype.updateAllStats = function () {
            var _this = this;
            if (!this.$scope.callOut)
                return;
            for (var s in this.$scope.callOut.sections) {
                var section = this.$scope.callOut.sections[s];
                section.properties.forEach(function (prop) {
                    if (prop.showMore) {
                        _this.updateStatsDelay(prop);
                    }
                });
            }
        };
        FeaturePropsCtrl.prototype.selectProperty = function (prop, $event) {
            this.lastSelectedProperty = prop;
            $event.stopPropagation();
        };
        FeaturePropsCtrl.prototype.saveFeature = function () {
            this.$layerService.unlockFeature(this.$scope.feature);
            this.$layerService.saveFeature(this.$scope.feature, true);
            this.$layerService.updateFeature(this.$scope.feature);
            this.displayFeature(this.$layerService.lastSelectedFeature);
        };
        FeaturePropsCtrl.prototype.startEditFeature = function () {
            this.$scope.feature.gui["editMode"] = true;
            this.$layerService.updateFeature(this.$scope.feature);
        };
        FeaturePropsCtrl.prototype.editFeature = function () {
            var rpt = csComp.Helpers.createRightPanelTab("featuretype", "featuretype", this.$layerService.lastSelectedFeature, "Edit group");
            this.$messageBusService.publish("rightpanel", "activate", rpt);
            this.$layerService.updateFeature(this.$layerService.lastSelectedFeature);
        };
        FeaturePropsCtrl.prototype.setFilter = function (item, $event) {
            this.$layerService.setPropertyFilter(item);
            $event.stopPropagation();
        };
        FeaturePropsCtrl.prototype.toTrusted = function (html) {
            try {
                if (html === undefined || html === null)
                    return this.$sce.trustAsHtml(html);
                return this.$sce.trustAsHtml(html.toString());
            }
            catch (e) {
                console.log(e + ': ' + html);
                return '';
            }
        };
        FeaturePropsCtrl.prototype.openLayer = function (property) {
            if (property.feature != null && property.feature.properties.hasOwnProperty(property.propertyType.label)) {
                var link = property.feature.properties[property.propertyType.label];
                alert(link);
            }
        };
        FeaturePropsCtrl.prototype.setCorrelation = function (item, $event) {
            $event.stopPropagation();
            var values = this.$layerService.getPropertyValues(item.feature.layer, item.property);
            for (var s in this.$scope.callOut.sections) {
                var sec = this.$scope.callOut.sections[s];
                sec.properties.forEach(function (p) {
                    if (p.property != item.property) {
                        var c = vg.util.cor(values, item.property, p.property);
                        p.cors[item.property] = { property: item.property, value: c };
                    }
                });
            }
        };
        FeaturePropsCtrl.prototype.getPropStats = function (item) {
            if (item.showMore) {
                console.log('stats: calc stats for ' + item.property);
                if (this.stats.indexOf(item.property) === -1)
                    this.stats.push(item.property);
                var values = this.$layerService.getPropertyValues(item.feature.layer, item.property);
                var d = item.property;
                var res = vg.util.summary(values, [item.property]);
                item.stats = res[0];
                item.stats.sum = item.stats.count * item.stats.mean;
            }
            else {
                if (this.stats.indexOf(item.property) >= 0)
                    this.stats = this.stats.filter(function (s) { return s != item.property; });
            }
        };
        FeaturePropsCtrl.prototype.displayFeature = function (feature) {
            var _this = this;
            if (!feature)
                return;
            this.featureType = feature.fType;
            this.featureType.id;
            // If we are dealing with a sensor, make sure that the feature's timestamps are valid so we can add it to a chart
            if (typeof feature.sensors !== 'undefined' && typeof feature.timestamps === 'undefined')
                feature.timestamps = this.$layerService.findLayer(feature.layerId).timestamps;
            this.$scope.callOut = new CallOut(this.featureType, feature, this.$layerService.propertyTypeData, this.$layerService, this.$mapService);
            if (this.stats.length > 0) {
                for (var s in this.$scope.callOut.sections) {
                    var sec = this.$scope.callOut.sections[s];
                    sec.properties.forEach(function (p) {
                        p.showMore = _this.stats.indexOf(p.property) >= 0;
                        _this.getPropStats(p);
                    });
                }
            }
        };
        FeaturePropsCtrl.prototype.removeFeature = function () {
            this.$layerService.removeFeature(this.$scope.feature, true);
        };
        FeaturePropsCtrl.prototype.updateHierarchyLinks = function (feature) {
            var _this = this;
            if (!feature)
                return;
            // Add properties defined inside of layers to the project-wide properties.
            this.$layerService.project.groups.forEach(function (group) {
                group.layers.forEach(function (l) {
                    if (l.type == "hierarchy" && l.enabled) {
                        if ((l.data) && (l.data).features) {
                            (l.data).features[0].fType.propertyTypeData.forEach(function (pt) {
                                if (pt.type == "hierarchy") {
                                    if (pt.targetlayer == feature.layerId) {
                                        var featureType = _this.$layerService.getFeatureType(feature);
                                        var propertyTypes = csComp.Helpers.getPropertyTypes(feature.fType, _this.$layerService.propertyTypeData);
                                        var found = false;
                                        propertyTypes.forEach(function (p) {
                                            if (p.label === pt.label) {
                                                found = true;
                                            }
                                        });
                                        if (!found)
                                            featureType.propertyTypeData.push(pt);
                                    }
                                }
                            });
                        }
                    }
                });
            });
            //csComp.Helpers.getPropertyTypes
        };
        FeaturePropsCtrl.prototype.showSensorData = function (property) {
            console.log(property);
        };
        FeaturePropsCtrl.prototype.setShowSimpleTimeline = function () {
            if (this.$mapService.timelineVisible
                || typeof this.$layerService.lastSelectedFeature === 'undefined'
                || this.$layerService.lastSelectedFeature == null) {
                this.showSimpleTimeline = false;
                return;
            }
            var feature = this.$layerService.lastSelectedFeature;
            this.showSimpleTimeline = (typeof feature.sensors !== 'undefined' && feature.sensors !== null);
            if (this.showSimpleTimeline)
                this.setTimestamps();
        };
        FeaturePropsCtrl.prototype.setTimestamps = function () {
            var feature = this.$layerService.lastSelectedFeature;
            var layer = this.$layerService.findLayer(feature.layerId);
            if ((typeof layer.timestamps === 'undefined' || layer.timestamps == null) &&
                (typeof feature.timestamps === 'undefined' || feature.timestamps == null))
                return [];
            var time = this.timestamps = new Array();
            (layer.timestamps || feature.timestamps).forEach(function (ts) {
                var date = new Date(ts);
                var dateString = String.format("{0}-{1:00}-{2:00}", date.getFullYear(), date.getUTCMonth() + 1, date.getUTCDate());
                if (date.getUTCHours() > 0 || date.getUTCMinutes() > 0)
                    dateString += String.format(" {0:00}:{1:00}", date.getUTCHours(), date.getUTCMinutes());
                time.push({ title: dateString, timestamp: ts });
            });
            // Set focus time
            var focus = this.$layerService.project.timeLine.focus;
            if (focus > time[time.length - 1].timestamp) {
                this.focusTime = time[time.length - 1].title;
                this.setTime(time[time.length - 1]);
            }
            else if (focus < time[0].timestamp) {
                this.focusTime = time[0].title;
                this.setTime(time[0]);
            }
            else {
                for (var i = 1; i < time.length; i++) {
                    if (focus > time[i].timestamp)
                        continue;
                    this.focusTime = time[i].title;
                    this.setTime(time[i]);
                    break;
                }
            }
            return time;
        };
        FeaturePropsCtrl.prototype.zoomToDate = function (date) {
            var d = new Date(date.toString());
            this.$layerService.project.timeLine.isLive = false;
            this.$layerService.project.timeLine.setFocus(d);
            this.$messageBusService.publish("timeline", "setFocus", d);
        };
        FeaturePropsCtrl.prototype.setTime = function (time) {
            this.focusTime = time.title;
            this.$layerService.project.timeLine.setFocus(new Date(time.timestamp));
            this.$messageBusService.publish("timeline", "focusChange", time.timestamp);
        };
        FeaturePropsCtrl.prototype.getFormattedDate = function (fp, pt) {
            if (!fp)
                return;
            var format;
            if (pt && pt.hasOwnProperty('stringFormat')) {
                format = pt.stringFormat;
            }
            else {
                format = 'DD MMMM YYYY';
            }
            if (moment(fp).format(format) === 'Invalid date') {
                return moment(fp, 'YYYYMMDD').format(format);
            }
            else {
                return moment(fp).format(format);
            }
        };
        //When a feature has multiple sections, a dropdown list is created with the title defined in the language entry "CHOOSE_DROPDOWN" (e.g. "Choose..." or "Data...")
        FeaturePropsCtrl.prototype.setDropdownTitle = function () {
            var _this = this;
            this.$translate("CHOOSE_DROPDOWN").then(function (translation) {
                if (typeof translation === 'string' && translation.length > 0) {
                    _this.defaultDropdownTitle = translation;
                }
                else {
                    _this.defaultDropdownTitle = '...';
                }
            });
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        FeaturePropsCtrl.$inject = [
            '$scope',
            '$location',
            '$sce',
            'mapService',
            'layerService',
            'messageBusService',
            '$translate'
        ];
        return FeaturePropsCtrl;
    })();
    FeatureProps.FeaturePropsCtrl = FeaturePropsCtrl;
})(FeatureProps || (FeatureProps = {}));

var FeatureRelations;
(function (FeatureRelations) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        FeatureRelations.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        FeatureRelations.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a feature's relations in a panel.
      *
      * @seealso          : http://www.youtube.com/watch?v=gjJ5vLRK8R8&list=UUGD_0i6L48hucTiiyhb5QzQ
      * @seealso          : http://plnkr.co/edit/HyBP9d?p=preview
      */
    FeatureRelations.myModule.directive('featurerelations', ['$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/FeatureRelations/FeatureRelations.tpl.html',
                replace: true,
                transclude: true,
                controller: FeatureRelations.FeatureRelationsCtrl
            };
        }
    ]);
})(FeatureRelations || (FeatureRelations = {}));

var FeatureRelations;
(function (FeatureRelations) {
    var FeaturePropsOptions = (function () {
        function FeaturePropsOptions(position) {
            this.position = position;
            this.closeButton = true;
            this.autoPan = true;
        }
        return FeaturePropsOptions;
    })();
    var RelationGroup = (function () {
        function RelationGroup() {
            this.relations = [];
        }
        return RelationGroup;
    })();
    FeatureRelations.RelationGroup = RelationGroup;
    var Relation = (function () {
        function Relation() {
        }
        return Relation;
    })();
    FeatureRelations.Relation = Relation;
    var FeatureRelationsCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function FeatureRelationsCtrl($scope, $location, $sce, $mapService, $layerService, $messageBusService, $translate) {
            var _this = this;
            this.$scope = $scope;
            this.$location = $location;
            this.$sce = $sce;
            this.$mapService = $mapService;
            this.$layerService = $layerService;
            this.$messageBusService = $messageBusService;
            this.$translate = $translate;
            this.relations = [];
            /**
                     * Callback function
                     * @see {http://stackoverflow.com/questions/12756423/is-there-an-alias-for-this-in-typescript}
                     * @see {http://stackoverflow.com/questions/20627138/typescript-this-scoping-issue-when-called-in-jquery-callback}
                     * @todo {notice the strange syntax using a fat arrow =>, which is to preserve the this reference in a callback!}
                     */
            this.sidebarMessageReceived = function (title) {
                switch (title) {
                    case "toggle":
                        _this.$scope.showMenu = !_this.$scope.showMenu;
                        break;
                    case "show":
                        _this.$scope.showMenu = true;
                        break;
                    case "hide":
                        _this.$scope.showMenu = false;
                        break;
                    default:
                }
                // NOTE EV: You need to call apply only when an event is received outside the angular scope.
                // However, make sure you are not calling this inside an angular apply cycle, as it will generate an error.
                if (_this.$scope.$root.$$phase != '$apply' && _this.$scope.$root.$$phase != '$digest') {
                    _this.$scope.$apply();
                }
            };
            this.featureMessageReceived = function (title, feature) {
                //console.log("FPC: featureMessageReceived");
                switch (title) {
                    case "onFeatureSelect":
                        _this.initRelations();
                        _this.$messageBusService.publish('feature', 'onRelationsUpdated', feature);
                        break;
                    default:
                }
                if (_this.$scope.$root.$$phase != '$apply' && _this.$scope.$root.$$phase != '$digest') {
                    _this.$scope.$apply();
                }
            };
            this.scope = $scope;
            $scope.vm = this;
            $scope.showMenu = false;
            //$messageBusService.subscribe("sidebar", this.sidebarMessageReceived);
            //$messageBusService.subscribe("feature", this.featureMessageReceived);
            this.initRelations();
        }
        FeatureRelationsCtrl.prototype.selectRelation = function (relation) {
            this.$layerService.selectFeature(relation.target);
            this.$mapService.zoomTo(relation.target);
        };
        // Create a relation to the nearest 10 features that are within the extent
        FeatureRelationsCtrl.prototype.createNearbyRelation = function (f) {
            var rgr = new RelationGroup();
            var mapZoom = this.$layerService.activeMapRenderer.getZoom();
            if (mapZoom < 11)
                return rgr; //Disable when zoom level is too low
            this.$translate('NEARBY_FEATURES').then(function (translation) {
                rgr.title = translation;
            });
            rgr.id = csComp.Helpers.getGuid();
            rgr.relations = [];
            var mapBounds = this.$mapService.map.getBounds();
            var tooManyFeatures = false;
            this.$layerService.project.features.every(function (feature) {
                if (feature.id != f.id) {
                    if ((feature.geometry.type == 'Point' && mapBounds.contains(new L.LatLng(feature.geometry.coordinates[1], feature.geometry.coordinates[0])))
                        || (feature.geometry.type == 'Polygon' && mapBounds.contains(new L.LatLng(feature.geometry.coordinates[0][0][1], feature.geometry.coordinates[0][0][0])))) {
                        var rl = new Relation();
                        rl.subject = f;
                        rl.target = feature;
                        rl.title = csComp.Helpers.featureTitle(feature.fType, feature);
                        rl.icon = (feature.fType == null || feature.fType.style == null || !feature.fType.style.hasOwnProperty('iconUri') || feature.fType.style.iconUri.toLowerCase().indexOf('_media') >= 0) ? '' : csComp.Helpers.convertStringFormat(feature, feature.fType.style.iconUri);
                        rgr.relations.push(rl);
                    }
                }
                if (rgr.relations.length > 40) {
                    tooManyFeatures = true;
                    return false; // break out of the some-loop when too many features are nearby
                }
                else {
                    return true;
                }
            });
            if (tooManyFeatures) {
                rgr.relations.length = 0;
                return rgr;
            }
            var fLoc;
            if (f.geometry.type == 'Point') {
                fLoc = new L.LatLng(f.geometry.coordinates[1], f.geometry.coordinates[0]);
            }
            else if (f.geometry.type == 'Polygon') {
                fLoc = new L.LatLng(f.geometry.coordinates[0][0][1], f.geometry.coordinates[0][0][0]); //TODO: Get center point of polygon, instead of its first point.
            }
            if (fLoc) {
                rgr.relations.sort(function (rl1, rl2) {
                    var loc1;
                    var loc2;
                    if (rl1.target.geometry.type == 'Point')
                        loc1 = new L.LatLng(rl1.target.geometry.coordinates[1], rl1.target.geometry.coordinates[0]);
                    if (rl1.target.geometry.type == 'Polygon')
                        loc1 = new L.LatLng(rl1.target.geometry.coordinates[0][0][1], rl1.target.geometry.coordinates[0][0][0]);
                    if (rl2.target.geometry.type == 'Point')
                        loc2 = new L.LatLng(rl2.target.geometry.coordinates[1], rl2.target.geometry.coordinates[0]);
                    if (rl2.target.geometry.type == 'Polygon')
                        loc2 = new L.LatLng(rl2.target.geometry.coordinates[0][0][1], rl2.target.geometry.coordinates[0][0][0]);
                    if (loc1 && loc2) {
                        return (fLoc.distanceTo(loc1) - fLoc.distanceTo(loc2));
                    }
                    else {
                        return;
                    }
                });
            }
            if (rgr.relations.length > 10) {
                rgr.relations.splice(10);
            }
            return rgr;
        };
        FeatureRelationsCtrl.prototype.initRelations = function () {
            this.relations = [];
            var f = this.$layerService.lastSelectedFeature;
            if (f.fType == null)
                return;
            this.$scope.title = csComp.Helpers.featureTitle(f.fType, f);
            if (f.fType == null || f.fType.style == null || !f.fType.style.hasOwnProperty('iconUri') || f.fType.style.iconUri.toLowerCase().indexOf('_media') >= 0) {
                this.$scope.icon = '';
            }
            else {
                this.$scope.icon = csComp.Helpers.convertStringFormat(f, f.fType.style.iconUri);
            }
            var propertyTypes = csComp.Helpers.getPropertyTypes(f.fType, this.$layerService.propertyTypeData);
            for (var p in propertyTypes) {
                var pt = propertyTypes[p];
                if (pt.type == "relation") {
                    var rg = new RelationGroup();
                    rg.title = pt.title;
                    rg.id = csComp.Helpers.getGuid();
                    rg.relations = [];
                    if (pt.target) {
                        this.$layerService.project.features.forEach(function (feature) {
                            if (f.properties.hasOwnProperty(pt.subject) && feature.properties.hasOwnProperty(pt.target)
                                && feature.properties[pt.target] == f.properties[pt.subject] && f.id !== feature.id) {
                                var rel = new Relation();
                                rel.subject = f;
                                rel.target = feature;
                                rel.title = csComp.Helpers.featureTitle(feature.fType, feature);
                                rel.icon = (feature.fType == null || feature.fType.style == null || !feature.fType.style.hasOwnProperty('iconUri') || feature.fType.style.iconUri.toLowerCase().indexOf('_media') >= 0) ? '' : feature.fType.style.iconUri;
                                rg.relations.push(rel);
                            }
                        });
                        if (rg.relations.length > 0) {
                            pt.count = 0;
                            rg.relations.forEach(function (rl) {
                                if (rl.target.fType.name === f.fType.name)
                                    pt.count += 1;
                            });
                        }
                    }
                    if (rg.relations.length > 0)
                        this.relations.push(rg);
                }
            }
            var nearbyRelGroup = this.createNearbyRelation(f);
            if (nearbyRelGroup.relations.length > 0)
                this.relations.push(nearbyRelGroup);
            this.showRelations = this.relations.length > 0;
            if (this.showRelations) {
                $("#linkedData").show();
            }
            else {
                $("#linkedData").hide();
            }
        };
        FeatureRelationsCtrl.prototype.getRelations = function () {
            return this.relations;
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        FeatureRelationsCtrl.$inject = [
            '$scope',
            '$location',
            '$sce',
            'mapService',
            'layerService',
            'messageBusService',
            '$translate'
        ];
        return FeatureRelationsCtrl;
    })();
    FeatureRelations.FeatureRelationsCtrl = FeatureRelationsCtrl;
})(FeatureRelations || (FeatureRelations = {}));

var FilterList;
(function (FilterList) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        FilterList.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        FilterList.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    FilterList.myModule.directive('filterList', [
        '$window', '$compile',
        function ($window, $compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/FilterList/FilterList.tpl.html',
                link: function (scope, element, attrs) {
                    // Deal with resizing the element list
                    scope.onResizeFunction = function () {
                        var filterHeight = 50;
                        var paginationCtrlHeight = 100;
                        var itemHeight = 60;
                        //scope.windowHeight          = $window.innerHeight;
                        //scope.windowWidth           = $window.innerWidth;
                        scope.numberOfItems = Math.floor(($window.innerHeight - filterHeight - paginationCtrlHeight) / itemHeight);
                    };
                    // Call to the function when the page is first loaded
                    scope.onResizeFunction();
                    angular.element($window).bind('resize', function () {
                        scope.onResizeFunction();
                        scope.$apply();
                    });
                },
                replace: false,
                transclude: false,
                controller: FilterList.FilterListCtrl
            };
        }
    ]).directive('bsPopover', function () {
        return function (scope, element, attrs) {
            element.find("a[rel=popover]").popover({ placement: 'right', html: 'true' });
        };
    });
})(FilterList || (FilterList = {}));

var FilterList;
(function (FilterList) {
    var FilterListCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function FilterListCtrl($scope, $layerService, $messageBus) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            $scope.vm = this;
            this.noFilters = true;
            this.locationFilterActive = false;
            this.$messageBus.subscribe("filters", function (action) {
                console.log('update filters');
                _this.noFilters = true;
                _this.locationFilterActive = false;
                _this.$layerService.project.groups.forEach(function (g) {
                    if (g.filters.length > 0 && _this.noFilters)
                        _this.noFilters = false;
                    g.filters.forEach(function (f) {
                        if (f.filterType === 'location' && _this.locationFilterActive === false)
                            _this.locationFilterActive = true;
                    });
                });
            });
        }
        FilterListCtrl.prototype.setLocationFilter = function (group) {
            if (!this.locationFilterActive) {
                this.$layerService.setLocationFilter(group);
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        FilterListCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService'
        ];
        return FilterListCtrl;
    })();
    FilterList.FilterListCtrl = FilterListCtrl;
})(FilterList || (FilterList = {}));

var Heatmap;
(function (Heatmap) {
    'use strict';
    /**
     * Config
     */
    var moduleName = 'csComp';
    try {
        Heatmap.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Heatmap.myModule = angular.module(moduleName, []);
    }
    /**
     * Directive to display a heatmap control.
     */
    Heatmap.myModule
        .directive('heatmap', [
        '$window', '$compile',
        function ($window, $compile, $templateCache) {
            return {
                terminal: true,
                restrict: 'EA',
                scope: {},
                templateUrl: 'directives/Heatmap/Heatmap.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    return function (scope) {
                        fn(scope);
                    };
                },
                replace: true,
                transclude: true,
                controller: Heatmap.HeatmapCtrl
            };
        }
    ]);
})(Heatmap || (Heatmap = {}));

var Heatmap;
(function (Heatmap) {
    'use strict';
    var HeatmapCtrl = (function () {
        function HeatmapCtrl($scope, $modal, $translate, $timeout, $localStorageService, $layerService, $mapService, messageBusService) {
            var _this = this;
            this.$scope = $scope;
            this.$modal = $modal;
            this.$translate = $translate;
            this.$timeout = $timeout;
            this.$localStorageService = $localStorageService;
            this.$layerService = $layerService;
            this.$mapService = $mapService;
            this.messageBusService = messageBusService;
            this.heatmap = L.geoJson([]);
            this.heatmapModels = [];
            this.expertMode = true;
            this.moveListenerInitialized = false;
            this.projLayer = new csComp.Services.ProjectLayer();
            $scope.vm = this;
            messageBusService.subscribe('layer', function (title, layer) {
                switch (title) {
                    case 'deactivate':
                        /* For an explanation to the removing of layers, see the bottom of this file */
                        if (layer.type && layer.type === "heatmap" && layer.id === _this.projLayer.id && layer != _this.projLayer) {
                            _this.$layerService.removeLayer(_this.projLayer);
                            delete (_this.heatmapModel);
                            _this.initializeHeatmap();
                        }
                        break;
                    case 'activated':
                        if (layer.type && layer.type === "heatmap")
                            _this.updateAvailableHeatmaps();
                        if (layer.type && layer.type === "geojson") {
                            // When the final, required feature layer is loaded, update the heatmap
                            if (_this.heatmapModel && _this.heatmapModel.heatmapSettings.referenceList.length > 0) {
                                if (layer.reference && layer.reference == _this.heatmapModel.heatmapSettings.referenceList[_this.heatmapModel.heatmapSettings.referenceList.length - 1]) {
                                    _this.updateHeatmap();
                                }
                            }
                        }
                        //this.updateHeatmap();
                        break;
                }
            });
            messageBusService.subscribe('project', function (title) {
                switch (title) {
                    case 'loaded':
                        _this.expertMode = $layerService.project != null
                            && $layerService.project.hasOwnProperty('userPrivileges')
                            && $layerService.project.userPrivileges.hasOwnProperty('heatmap')
                            && $layerService.project.userPrivileges.heatmap.hasOwnProperty('expertMode')
                            && $layerService.project.userPrivileges.heatmap.expertMode;
                        _this.updateAvailableHeatmaps();
                        _this.initializeHeatmap();
                        break;
                }
            });
            /*messageBusService.subscribe('feature', this.featureMessageReceived);*/
            $translate('HEATMAP.DELETE_MSG').then(function (translation) {
                HeatmapCtrl.confirmationMsg1 = translation;
            });
            $translate('HEATMAP.DELETE_MSG2').then(function (translation) {
                HeatmapCtrl.confirmationMsg2 = translation;
            });
        }
        HeatmapCtrl.prototype.updateAvailableHeatmaps = function () {
            var _this = this;
            if (!this.heatmapModel) {
                this.heatmapModels = [];
                if (this.$layerService.project.groups) {
                    this.$layerService.project.groups.forEach(function (group) {
                        group.layers.forEach(function (layer) {
                            if (layer.type === "heatmap") {
                                var hm = new Heatmap.HeatmapModel(layer.title);
                                hm.deserialize(layer);
                                _this.heatmapModels.push(hm);
                                if (layer.enabled)
                                    _this.heatmapModel = hm;
                            }
                        });
                    });
                }
            }
            else {
                for (var index = 0; index < this.heatmapModels.length; index++) {
                    if (this.heatmapModel.id == this.heatmapModels[index].id) {
                        this.heatmapModels.splice(index, 1);
                        break;
                    }
                }
                this.heatmapModels.push(this.heatmapModel);
            }
        };
        HeatmapCtrl.prototype.createHeatmap = function () {
            this.heatmapModel = new Heatmap.HeatmapModel('Heatmap');
            if (this.projLayer.data)
                this.$layerService.removeLayer(this.projLayer);
            //Create projectlayer for the heatmap
            this.projLayer.type = "heatmap";
            this.projLayer.renderType = "heatmap";
            this.projLayer.enabled = true;
            this.projLayer.group = new csComp.Services.ProjectGroup();
            this.projLayer.group.oneLayerActive = true;
            this.projLayer.group.layers = [];
            this.projLayer.group.filters = [];
            this.projLayer.group.styles = [];
            this.projLayer.group.markers = [];
            this.projLayer.heatmapSettings = new Heatmap.HeatmapSettings();
            this.projLayer.heatmapItems = [];
            this.projLayer.id = csComp.Helpers.getGuid();
            this.projLayer.quickRefresh = false;
            this.heatmap = L.geoJson([]);
            this.showHeatmapEditor(this.heatmapModel);
            //this.$layerService.addLayer(this.projLayer);
        };
        HeatmapCtrl.prototype.editHeatmap = function (heatmap) {
            this.showHeatmapEditor(heatmap);
        };
        HeatmapCtrl.prototype.exportHeatmap = function (heatmap) {
            var _this = this;
            /* Add active feature layer reference to the referencelist (TODO: find reference layer through enabled features) */
            this.heatmapModel.heatmapSettings.referenceList = [];
            this.heatmapModel.heatmapItems.forEach(function (hi) {
                if (hi.isSelected) {
                    _this.$layerService.project.groups.forEach(function (group) {
                        if (group.title == "Features") {
                            group.layers.forEach(function (l) {
                                if (l.enabled) {
                                    _this.heatmapModel.heatmapSettings.addReference(l.reference);
                                }
                            });
                        }
                    });
                }
            });
            /* Print the heatmap settings to the console in json format */
            console.log("\n-----------------\n" + "Exported heatmap starts here: \n");
            console.log(heatmap.serialize());
            console.log("\n-----------------\n" + "Exported heatmap ends here. \n");
            this.messageBusService.notify('Heatmap exported successfully', 'Your heatmap was exported to the console successfully.', csComp.Services.NotifyLocation.TopLeft);
        };
        HeatmapCtrl.prototype.removeHeatmap = function (heatmap) {
            var _this = this;
            if (!heatmap)
                return;
            var title = String.format(HeatmapCtrl.confirmationMsg1, heatmap.title);
            this.messageBusService.confirm(title, HeatmapCtrl.confirmationMsg2, function (result) {
                if (!result)
                    return;
                _this.$timeout(function () {
                    _this.deleteHeatmap(heatmap);
                    _this.updateAvailableHeatmaps();
                    //if (this.heatmap) this.updateHeatmap();
                    //if (this.heatmap) this.$mapService.map.removeLayer(this.heatmap);
                }, 0);
            });
            this.scopeApply();
        };
        HeatmapCtrl.prototype.deleteHeatmap = function (heatmap) {
            var _this = this;
            if (!heatmap)
                return;
            var index = this.heatmapModels.indexOf(heatmap);
            if (index >= 0)
                this.heatmapModels.splice(index, 1);
            this.$layerService.removeLayer(this.projLayer);
            // If the current heatmaplayer was a projectlayer, disable that one too
            if (this.$layerService.project.groups) {
                this.$layerService.project.groups.forEach(function (group) {
                    group.layers.forEach(function (layer) {
                        if (layer.type === "heatmap" && layer.id === _this.projLayer.id) {
                            _this.$layerService.removeLayer(layer);
                        }
                    });
                });
            }
            delete (this.heatmapModel);
            delete (this.projLayer);
            this.projLayer = new csComp.Services.ProjectLayer();
            this.initializeHeatmap();
        };
        /**
         * Show the heat map editor in a modal.
         */
        HeatmapCtrl.prototype.showHeatmapEditor = function (heatmap) {
            var _this = this;
            var modalInstance = this.$modal.open({
                templateUrl: 'directives/Heatmap/HeatmapEditorView.tpl.html',
                controller: Heatmap.HeatmapEditorCtrl,
                resolve: {
                    heatmap: function () { return heatmap; }
                }
            });
            modalInstance.result.then(function (heatmap) {
                _this.heatmapModel = heatmap;
                var i = _this.heatmapModels.indexOf(heatmap);
                if (i >= 0)
                    _this.heatmapModels.splice(i, 1);
                _this.heatmapModels.push(heatmap);
                _this.updateHeatmap();
                console.log('Updated heatmap');
            }, function () {
                console.log('Modal dismissed at: ' + new Date());
                delete (_this.heatmapModel);
            });
        };
        HeatmapCtrl.prototype.scopeApply = function () {
            if (this.$scope.$root.$$phase !== '$apply' && this.$scope.$root.$$phase !== '$digest') {
                this.$scope.$apply();
            }
        };
        HeatmapCtrl.prototype.getVotingClass = function (hi) {
            if (hi == null || this.heatmapModel == null || hi.userWeight === 0 || hi.userWeight < -5 || hi.userWeight > 5)
                return 'disabledHeatmap';
            return hi.userWeight > 0 ? 'prefer' : 'avoid';
        };
        HeatmapCtrl.prototype.weightUpdated = function () {
            if (!this.heatmapModel)
                return;
            this.heatmapModel.updateWeights();
            this.projLayer.quickRefresh = true;
            this.$layerService.addLayer(this.projLayer);
        };
        HeatmapCtrl.prototype.intensityScaleUpdated = function () {
            if (!this.heatmapModel)
                return;
            //this.heatmapModel.updateWeights();
            //this.updateHeatmap();
            this.updateHeatmapWithoutRerendering();
        };
        HeatmapCtrl.prototype.resolutionUpdated = function () {
            if (!this.heatmapModel)
                return;
            this.updateHeatmap();
        };
        HeatmapCtrl.prototype.updateHeatmapWithoutRerendering = function () {
            this.projLayer.quickRefresh = true;
            this.$layerService.addLayer(this.projLayer);
        };
        /**
         * Update the available pre-set heatmaps.
         */
        HeatmapCtrl.prototype.updateHeatmap = function () {
            var _this = this;
            if (this.heatmapModel) {
                // If the current heatmapmodel comes from a projectlayer, disable that layer
                if (this.$layerService.project.groups) {
                    this.$layerService.project.groups.forEach(function (group) {
                        group.layers.forEach(function (layer) {
                            if (layer.type === "heatmap" && layer.id === _this.heatmapModel.id && layer.mapLayer) {
                                _this.$layerService.map.map.removeLayer(layer.mapLayer);
                                layer.enabled = true;
                            }
                        });
                    });
                }
                this.projLayer.quickRefresh = false;
                this.projLayer.heatmapItems = this.heatmapModel.heatmapItems;
                this.projLayer.heatmapSettings = this.heatmapModel.heatmapSettings;
                this.projLayer.id = this.heatmapModel.id;
                var currentZoom = this.$mapService.getMap().getZoom();
                if (currentZoom < this.heatmapModel.heatmapSettings.minZoom || currentZoom > this.heatmapModel.heatmapSettings.maxZoom) {
                    console.log("Heatmap is not supported for the current zoom level.");
                    this.$layerService.loadRequiredLayers(this.projLayer); // Make sure to load the required layers even if heatmap is not yet being drawn
                    return;
                }
                else {
                }
                this.$layerService.removeLayer(this.projLayer);
                this.$layerService.addLayer(this.projLayer);
            }
        };
        ///**
        //* Add a heatmap layer to the map.
        //*/
        HeatmapCtrl.prototype.initializeHeatmap = function () {
            var _this = this;
            this.projLayer.type = "heatmap";
            this.projLayer.renderType = "heatmap";
            this.projLayer.enabled = false;
            this.projLayer.group = new csComp.Services.ProjectGroup();
            this.projLayer.group.oneLayerActive = true;
            this.projLayer.group.layers = [];
            this.projLayer.group.filters = [];
            this.projLayer.group.styles = [];
            this.projLayer.group.markers = [];
            this.projLayer.mapLayer = new L.LayerGroup();
            this.projLayer.heatmapSettings = new Heatmap.HeatmapSettings();
            this.projLayer.heatmapItems = [];
            this.projLayer.data = JSON;
            this.projLayer.id = "";
            this.projLayer.quickRefresh = false;
            if (!this.moveListenerInitialized) {
                this.$layerService.map.map.addEventListener('moveend', function (event) {
                    _this.updateHeatmap();
                });
                this.moveListenerInitialized = true;
            }
        };
        HeatmapCtrl.$inject = [
            '$scope',
            '$modal',
            '$translate',
            '$timeout',
            'localStorageService',
            'layerService',
            'mapService',
            'messageBusService'
        ];
        return HeatmapCtrl;
    })();
    Heatmap.HeatmapCtrl = HeatmapCtrl;
})(Heatmap || (Heatmap = {}));
/* Heatmap layers:
 * ---------------
 * Two layers are used for the heatmaps, which are both very similar but different in an important way. The difference
 * lies in the fact that one layer comes directly from the project.json file. This layer is parsed and added to the layerservice
 * directly when it is enabled in the 'Layers' panel. The second layer is 'this.projLayer', which looks almost identical to
 * the parsed projectLayer, but it is generated programmatically. When a new heatmap is created, or a predefined heatmap is edited,
 * this.projLayer will be added to the layerservice. Very importantly, the MoveListener is connected to this.projLayer. That means
 * that every time the map is moved, 'this.projLayer' will contain the current heatmap, even when it was added from project.json.
 * Therefore, when one layer is being disabled, it needs to be checked whether the other layer is present in the layerservice,
 * and if so, it should be removed too.
 */

var Heatmap;
(function (Heatmap) {
    'use strict';
    var HeatmapEditorCtrl = (function () {
        function HeatmapEditorCtrl($scope, $modalInstance, $layerService, $translate, messageBusService, heatmap) {
            var _this = this;
            this.$scope = $scope;
            this.$modalInstance = $modalInstance;
            this.$layerService = $layerService;
            this.$translate = $translate;
            this.messageBusService = messageBusService;
            this.heatmap = heatmap;
            this.scoringFunctions = [];
            $scope.vm = this;
            this.scoringFunctions.push(new Heatmap.ScoringFunction(Heatmap.ScoringFunctionType.LinearAscendingDescending));
            $translate('HEATMAP.LINEAR_ASC_DESC').then(function (translation) {
                _this.scoringFunctions[0].title = translation;
            });
            this.dataset = csComp.Helpers.loadMapLayers($layerService);
            if (!heatmap)
                heatmap = new Heatmap.HeatmapModel('Heatmap');
            for (var k in this.dataset.featureTypes) {
                if (this.dataset.featureTypes.hasOwnProperty(k)) {
                    var ft = this.dataset.featureTypes[k];
                    heatmap.addHeatmapItem(new Heatmap.HeatmapItem(ft.name, ft));
                    var propertyTypeData;
                    if (!ft.propertyTypeData)
                        continue;
                    ft.propertyTypeData.forEach(function (pt) {
                        if (pt.type == 'options') {
                            var i = 0;
                            pt.options.forEach(function (o) {
                                var hi = new Heatmap.HeatmapItem(o, ft);
                                hi.propertyLabel = pt.label;
                                hi.propertyTitle = pt.title;
                                hi.optionIndex = i++;
                                heatmap.addHeatmapItem(hi);
                            });
                        }
                    });
                }
            }
        }
        HeatmapEditorCtrl.prototype.save = function () {
            this.$modalInstance.close(this.heatmap);
        };
        HeatmapEditorCtrl.prototype.cancel = function () {
            this.$modalInstance.dismiss('cancel');
        };
        HeatmapEditorCtrl.prototype.toggleItemDetails = function (index) {
            this.showItem = this.showItem == index ? -1 : index;
            console.log("Toggle item");
        };
        HeatmapEditorCtrl.$inject = [
            '$scope',
            '$modalInstance',
            'layerService',
            '$translate',
            'messageBusService',
            'heatmap'
        ];
        return HeatmapEditorCtrl;
    })();
    Heatmap.HeatmapEditorCtrl = HeatmapEditorCtrl;
})(Heatmap || (Heatmap = {}));

var Heatmap;
(function (Heatmap) {
    var HeatmapItem = (function () {
        function HeatmapItem(title, featureType, weight, userWeight, isSelected, idealityMeasure, propertyTitle, propertyLabel, optionIndex) {
            if (weight === void 0) { weight = 0; }
            if (userWeight === void 0) { userWeight = 1; }
            if (isSelected === void 0) { isSelected = false; }
            if (idealityMeasure === void 0) { idealityMeasure = new Heatmap.IdealityMeasure(); }
            this.title = title;
            this.featureType = featureType;
            this.weight = weight;
            this.userWeight = userWeight;
            this.isSelected = isSelected;
            this.idealityMeasure = idealityMeasure;
            this.propertyTitle = propertyTitle;
            this.propertyLabel = propertyLabel;
            this.optionIndex = optionIndex;
            this.heatspots = [];
            // TODO Needs improvement based on actual location
            this.setScale(52);
        }
        /**
         * Returns an object which contains all the data that must be serialized.
         */
        HeatmapItem.serializeableData = function (i) {
            return {
                title: i.title,
                featureType: i.featureType,
                propertyTitle: i.propertyTitle,
                propertyLabel: i.propertyLabel,
                optionIndex: i.optionIndex,
                userWeight: i.userWeight,
                weight: i.weight,
                idealityMeasure: i.idealityMeasure,
                isSelected: i.isSelected
            };
        };
        HeatmapItem.prototype.calculateHeatspots = function (feature, cellWidth, cellHeight, horizCells, vertCells, mapBounds, paddingRatio) {
            // right type?
            if (!this.isSelected || this.featureType.name.replace('_Default', '') !== feature.fType.name)
                return null;
            if (this.heatspots.length === 0)
                this.calculateHeatspot(cellWidth, cellHeight);
            // create heatspot solely based on feature type?
            if (!this.propertyLabel) {
                return this.pinHeatspotToGrid(feature, horizCells, vertCells, mapBounds, paddingRatio);
            }
            // create heatspot based on the preferred option?
            if (feature.properties.hasOwnProperty(this.propertyLabel)
                && feature.properties[this.propertyLabel] === this.optionIndex) {
                return this.pinHeatspotToGrid(feature, horizCells, vertCells, mapBounds, paddingRatio);
            }
            return null;
        };
        /**
        * Calculate the intensity around the location.
        * NOTE We are performing a relative computation around location (0,0) in a rectangular grid.
        */
        HeatmapItem.prototype.calculateHeatspot = function (cellWidth, cellHeight) {
            var maxRadius = this.idealityMeasure.lostInterestDistance;
            var horizCells = Math.floor(maxRadius / cellWidth);
            var vertCells = Math.floor(maxRadius / cellHeight);
            var sCellSize = cellWidth * cellHeight;
            var arrayLength = horizCells * vertCells;
            this.heatspots = new Array(arrayLength);
            this.heatspots.push(new Heatmap.Heatspot(0, 0, this.idealityMeasure.atLocation));
            for (var i = -vertCells; i <= vertCells; i++) {
                for (var j = -horizCells; j <= horizCells; j++) {
                    var radius = Math.sqrt(i * i * sCellSize + j * j * sCellSize);
                    var intensity = this.idealityMeasure.computeIdealityAtDistance(radius);
                    if (!(i == 0 && j == 0) && intensity != 0) {
                        this.heatspots.push(new Heatmap.Heatspot(i, j, intensity));
                    }
                }
            }
            //var latRadius = radius * HeatmapItem.meterToLatDegree;
            //var lonRadius = radius * HeatmapItem.meterToLonDegree;
            //for (var lat = -latRadius; lat < latRadius; lat += deltaLatDegree) {
            //    for (var lon = -lonRadius; lat < lonRadius; lat += deltaLonDegree) {
            //        // TODO Compute radius
            //        var intensity = this.idealityMeasure.computeIdealityAtDistance(radius);
            //        this.heatspots.push(new Heatspot(lat, lon, this.weight * intensity.ideality));
            //    }
            //}
            //var count = 0;
            //while (count++ < 200) {
            //    var radius    = Math.random() * this.idealityMeasure.lostInterestDistance;
            //    var latRadius = radius * HeatmapItem.meterToLatDegree;
            //    var lonRadius = radius * HeatmapItem.meterToLonDegree;
            //    var angleRad  = Math.random() * HeatmapItem.twoPi;
            //    var lat       = Math.sin(angleRad) * latRadius;
            //    var lon       = Math.cos(angleRad) * lonRadius;
            //    var intensity = this.idealityMeasure.computeIdealityAtDistance(radius);
            //    this.heatspots.push(new Heatspot(lat, lon, this.weight * intensity.ideality, intensity.radius));
            //}
            //var twoPi: number = Math.PI * 2;
            //var lat = 0,
            //    lon = 0;
            //// add start point
            //this.heatspots.push(new Heatspot(lat, lon, this.weight * this.idealityMeasure.atLocation));
            //// halfway between start and ideal location
            //var stepSize  = Math.PI / 2;
            //var radius    = this.idealityMeasure.idealDistance / 2;
            //var latRadius = radius * HeatmapItem.meterToLatDegree;
            //var lonRadius = radius * HeatmapItem.meterToLonDegree;
            //var itensity  = 0.5 * this.weight;
            //for (var i = Math.PI / 4; i < twoPi; i += stepSize) {
            //    lat = Math.sin(i) * latRadius;
            //    lon = Math.cos(i) * lonRadius;
            //    this.heatspots.push(new Heatspot(lat, lon, itensity));
            //}
            //// At ideal distance
            //stepSize /= 2;
            //radius = this.idealityMeasure.idealDistance;
            //latRadius = radius * HeatmapItem.meterToLatDegree;
            //lonRadius = radius * HeatmapItem.meterToLonDegree;
            //itensity = this.weight;
            //for (var i = 0; i < twoPi; i += stepSize) {
            //    lat = Math.sin(i) * latRadius;
            //    lon = Math.cos(i) * lonRadius;
            //    this.heatspots.push(new Heatspot(lat, lon, itensity));
            //}
            //// At ring halfway between ideal distance and no interest
            //stepSize /= 2;
            //radius   += (this.idealityMeasure.lostInterestDistance - this.idealityMeasure.idealDistance) / 2;
            //latRadius = radius * HeatmapItem.meterToLatDegree;
            //lonRadius = radius * HeatmapItem.meterToLonDegree;
            //itensity = this.weight / 2;
            //for (var i = Math.PI / 8; i < twoPi; i += stepSize) {
            //    lat = Math.sin(i) * latRadius;
            //    lon = Math.cos(i) * lonRadius;
            //    this.heatspots.push(new Heatspot(lat, lon, itensity));
            //}
        };
        /**
        * Translate the heatspot (at (0,0)) to the actual location.
        */
        HeatmapItem.prototype.pinHeatspotToGrid = function (feature, horizCells, vertCells, mapBounds, paddingRatio) {
            if (feature.geometry.type !== 'Point')
                return null;
            var latlong = new L.LatLng(feature.geometry.coordinates[1], feature.geometry.coordinates[0]);
            //TODO add a padding that takes the current zoom into account
            var paddedBounds = mapBounds.pad(paddingRatio);
            if (!paddedBounds.contains(latlong))
                return null; //Only draw features that are visible in the map
            var actualHeatspots = [];
            //Find the indices of the feature in the grid
            var hCell = Math.floor(((latlong.lng - mapBounds.getNorthWest().lng) / (mapBounds.getNorthEast().lng - mapBounds.getNorthWest().lng)) * horizCells);
            var vCell = Math.floor(((latlong.lat - mapBounds.getSouthWest().lat) / (mapBounds.getNorthWest().lat - mapBounds.getSouthWest().lat)) * vertCells);
            this.heatspots.forEach(function (hs) {
                actualHeatspots.push(hs.AddLocation(hCell, vCell, feature.properties['Name'])); // + ': ' + hs.intensity.toFixed(3)));
            });
            return actualHeatspots;
        };
        /**
        * Set the scale to convert a 1x1 meter grid cell to the appropriate number of degrees
        * in vertical and horizontal direction.
        */
        HeatmapItem.prototype.setScale = function (latitude) {
            var latlonlen = csComp.Helpers.GeoExtensions.convertDegreesToMeters(latitude);
            HeatmapItem.meterToLatDegree = 1 / latlonlen.latitudeLength;
            HeatmapItem.meterToLonDegree = 1 / latlonlen.longitudeLength;
        };
        HeatmapItem.prototype.select = function () {
            this.reset();
            this.isSelected = !this.isSelected;
            if (!this.isSelected) {
                this.idealityMeasure = null;
            }
            else {
                switch (this.featureType.style.drawingMode.toLowerCase()) {
                    case 'point':
                    case 'image':
                        this.idealityMeasure = new Heatmap.IdealityMeasure();
                        break;
                    default:
                        //this.idealityMeasure = 1;
                        break;
                }
            }
        };
        HeatmapItem.prototype.reset = function () {
            this.heatspots = [];
        };
        HeatmapItem.prototype.toString = function () {
            return this.propertyTitle
                ? this.propertyTitle + '.' + this.title + ' (' + this.featureType.name + ')'
                : this.title;
        };
        HeatmapItem.twoPi = Math.PI * 2;
        return HeatmapItem;
    })();
    Heatmap.HeatmapItem = HeatmapItem;
})(Heatmap || (Heatmap = {}));

var Heatmap;
(function (Heatmap) {
    var HeatmapModel = (function () {
        function HeatmapModel(title) {
            this.title = title;
            this.heatmapItems = [];
            this.id = "";
            this.horizCells = 0;
            this.vertCells = 0;
            this.cellWidth = 0;
            this.cellHeight = 0;
            this.dLat = 0;
            this.dLng = 0;
            this.title = title;
            this.heatmapSettings = new Heatmap.HeatmapSettings();
        }
        /**
         * Calculate the heatmap.
         */
        HeatmapModel.prototype.calculate = function (layerService, mapService, heatmap) {
            var _this = this;
            var time = new Date().getTime();
            console.log('Calculating heatmap');
            var mapBounds = mapService.map.getBounds();
            var NW = mapBounds.getNorthWest();
            var NE = mapBounds.getNorthEast();
            this.SW = mapBounds.getSouthWest();
            var width = NW.distanceTo(NE); //Width of the map as it is currently visible on the screen, including padding
            var height = NW.distanceTo(this.SW); //Height ...
            var heatspots = [];
            // Iterate over all applicable features on the map and find the one with the largest interest distance.
            var dataset = csComp.Helpers.loadMapLayers(layerService);
            var maxInterestDistance = 0;
            //heatmap.clearData();
            dataset.features.forEach(function (f) {
                _this.heatmapItems.forEach(function (hi) {
                    if (hi.idealityMeasure.lostInterestDistance > maxInterestDistance) {
                        maxInterestDistance = hi.idealityMeasure.lostInterestDistance;
                    }
                });
            });
            var widthPaddingRatio = (width + 2 * maxInterestDistance) / width;
            var heigthPaddingRatio = (height + 2 * maxInterestDistance) / height;
            var paddingRatio = Math.max(widthPaddingRatio, heigthPaddingRatio);
            //Calculate a grid based on the maximum number of cells and the map ratio.
            var mapRatio = width / height;
            var maxCellCount;
            switch (this.heatmapSettings.resolution) {
                case 1:
                    maxCellCount = 1000;
                    break;
                case 2:
                    maxCellCount = 4000;
                    break;
                case 3:
                    maxCellCount = 7000;
                    break;
                default:
                    maxCellCount = 4000;
                    break;
            }
            this.horizCells = Math.floor(Math.sqrt(maxCellCount * mapRatio));
            this.vertCells = Math.floor(this.horizCells / mapRatio);
            this.cellWidth = width / this.horizCells;
            this.cellHeight = height / this.vertCells;
            this.dLat = (NE.lat - this.SW.lat) / this.vertCells;
            this.dLng = (NE.lng - this.SW.lng) / this.horizCells;
            var count = 0;
            //var turfgrid = turf.squareGrid([SW.lng, SW.lat, NE.lng, NE.lat], cellWidth / 1000, 'kilometers');
            this.intensityGrid = [];
            this.contributorGrid = [];
            for (var i = 0; i < this.horizCells; i++) {
                this.intensityGrid[i] = [];
                this.contributorGrid[i] = [];
                for (var j = 0; j < this.vertCells; j++) {
                    this.intensityGrid[i][j] = {};
                    this.contributorGrid[i][j] = {};
                }
            }
            // Iterate over all applicable features on the map and create a intensity "stamp" for each feature
            dataset.features.forEach(function (f) {
                _this.heatmapItems.forEach(function (hi) {
                    var heatspot = hi.calculateHeatspots(f, _this.cellWidth, _this.cellHeight, _this.horizCells, _this.vertCells, mapBounds, paddingRatio);
                    if (heatspot) {
                        //heatspots = heatspots.concat(heatspot);
                        //console.log('Created ' + heatspot.length + ' heatspots');
                        heatspot.forEach(function (hs) {
                            //heatmap.addDataPoint(hs.i, hs.j, hs.intensity);
                            if (hs.intensity != 0 &&
                                hs.i >= 0 && hs.i < _this.horizCells && hs.j >= 0 && hs.j < _this.vertCells) {
                                (_this.intensityGrid[hs.i][hs.j].hasOwnProperty(hi.toString())) ? _this.intensityGrid[hs.i][hs.j][hi.toString()] += hs.intensity : _this.intensityGrid[hs.i][hs.j][hi.toString()] = hs.intensity;
                                _this.contributorGrid[hs.i][hs.j][hs.contributor] = hs.intensity;
                                count = count + 1;
                            }
                        });
                    }
                });
            });
            var time2 = new Date().getTime();
            console.log('Created ' + count + ' heatspots in ' + (time2 - time).toFixed(1) + ' ms');
            this.drawIntensityGrid(heatmap);
            var time3 = new Date().getTime();
            console.log('Calculated ' + (i * j) + ' cells in ' + (time3 - time).toFixed(1) + ' ms');
        };
        HeatmapModel.prototype.drawIntensityGrid = function (heatmap) {
            var weightedIntensityScale = ((this.heatmapSettings.intensityScale / 3) * (this.heatmapSettings.intensityScale / 3)); // Convert intensityscale from [1,...,5] to ~[0.1, 0.5, 1, 2, 3]
            heatmap.clearLayers();
            var hiWeights = {};
            this.heatmapItems.forEach(function (hi) {
                hiWeights[hi.toString()] = hi.weight;
            });
            //Draw the intensityGrid
            for (var i = 0; i < this.horizCells; i++) {
                for (var j = 0; j < this.vertCells; j++) {
                    var totalIntensity = 0;
                    for (var hiTitle in this.intensityGrid[i][j]) {
                        if (this.intensityGrid[i][j].hasOwnProperty(hiTitle)) {
                            totalIntensity += (hiWeights[hiTitle] * this.intensityGrid[i][j][hiTitle]);
                        }
                    }
                    if (totalIntensity != 0) {
                        var polyCoord = [[this.SW.lng + this.dLng * i, this.SW.lat + this.dLat * j],
                            [this.SW.lng + this.dLng * (i + 1), this.SW.lat + this.dLat * j],
                            [this.SW.lng + this.dLng * (i + 1), this.SW.lat + this.dLat * (j + 1)],
                            [this.SW.lng + this.dLng * i, this.SW.lat + this.dLat * (j + 1)]];
                        var feature = {
                            "type": "Feature",
                            "geometry": {
                                "type": "Polygon",
                                "coordinates": [polyCoord]
                            },
                            "properties": {
                                "Name": "Heatmap cell (" + i.toString() + ", " + j.toString() + ")",
                                "gridX": i,
                                "gridY": j,
                                "totalIntensity": (totalIntensity * weightedIntensityScale).toFixed(3),
                                "contributors": JSON.stringify(this.contributorGrid[i][j], function (key, intensity) {
                                    return intensity.toFixed ? Number(intensity.toFixed(3)) : intensity;
                                }),
                                "intensities": JSON.stringify(this.intensityGrid[i][j])
                            }
                        };
                        heatmap.addData(feature);
                    }
                }
            }
        };
        /**
         * Update the weights of all heatmap items.
         */
        HeatmapModel.prototype.updateWeights = function () {
            var totalUserWeight = 0;
            this.heatmapItems.forEach(function (hi) {
                if (hi.isSelected)
                    totalUserWeight += Math.abs(hi.userWeight);
            });
            this.heatmapItems.forEach(function (hi) {
                if (hi.isSelected) {
                    if (totalUserWeight != 0) {
                        hi.weight = hi.userWeight / totalUserWeight;
                    }
                    else {
                        hi.weight = 0;
                    }
                }
            });
        };
        /**
        * Add a heatmap item to the list of items only in case we don't have it yet.
        */
        HeatmapModel.prototype.addHeatmapItem = function (heatmapItem) {
            var ft = heatmapItem.featureType;
            var title = heatmapItem.title;
            for (var i = 0; i < this.heatmapItems.length; i++) {
                var hi = this.heatmapItems[i];
                if (hi.featureType.name === ft.name && hi.title === title)
                    return;
            }
            this.heatmapItems.push(heatmapItem);
        };
        HeatmapModel.prototype.deserialize = function (layer) {
            var _this = this;
            this.id = layer.id;
            var hs = layer.heatmapSettings;
            this.heatmapSettings = new Heatmap.HeatmapSettings(hs.referenceList, hs.minZoom, hs.maxZoom, hs.intensityScale, hs.resolution);
            this.heatmapItems = [];
            var heatmapitems = layer.heatmapItems;
            heatmapitems.forEach(function (hi_info) {
                var im = new Heatmap.IdealityMeasure(hi_info.idealityMeasure.idealDistance, hi_info.idealityMeasure.atLocation, hi_info.idealityMeasure.lostInterestDistance);
                if (hi_info.propertyTitle) {
                    var hi = new Heatmap.HeatmapItem(hi_info.title, hi_info.featureType, hi_info.weight, hi_info.userWeight, hi_info.isSelected, im, hi_info.propertyTitle, hi_info.propertyLabel, hi_info.optionIndex);
                }
                else {
                    var hi = new Heatmap.HeatmapItem(hi_info.title, hi_info.featureType, hi_info.weight, hi_info.userWeight, hi_info.isSelected, im);
                }
                _this.addHeatmapItem(hi);
            });
        };
        HeatmapModel.prototype.serialize = function () {
            var minimizedHeatmapItems = [];
            this.heatmapItems.forEach(function (hi) {
                if (hi.isSelected) {
                    hi.reset();
                    if (hi.propertyTitle) {
                        var hi_new = new Heatmap.HeatmapItem(hi.title, { name: hi.featureType.name }, hi.weight, hi.userWeight, hi.isSelected, hi.idealityMeasure, hi.propertyTitle, hi.propertyLabel, hi.optionIndex);
                    }
                    else {
                        var hi_new = new Heatmap.HeatmapItem(hi.title, { name: hi.featureType.name }, hi.weight, hi.userWeight, hi.isSelected, hi.idealityMeasure);
                    }
                    minimizedHeatmapItems.push(hi_new);
                }
            });
            var output = "{\"id\": \"ID\",\n" +
                "\"reference\": \"REFERENCE\",\n" +
                "\"languages\": {\n" +
                "\"nl\": {\"title\": ";
            output += JSON.stringify(this.title);
            output += ",\n\"description\": \"BESCHRIJVING\"\n},\n" +
                "\"en\": {\"title\": ";
            output += JSON.stringify(this.title);
            output += ",\n\"description\": \"DESCRIPTION\"\n}\n" +
                "},\n" +
                "\"description\": \"DESCRIPTION\",\n";
            output += "\"type\":\"Heatmap\"";
            output += ",\n\"heatmapSettings\":" + JSON.stringify(this.heatmapSettings, null, ' ');
            output += ",\n\"heatmapItems\":";
            output += JSON.stringify(minimizedHeatmapItems, null, ' ');
            output += ",\n\"enabled\":";
            output += JSON.stringify(false);
            output += ",\n\"opacity\":";
            output += JSON.stringify(100);
            output += "\n}";
            return output;
        };
        return HeatmapModel;
    })();
    Heatmap.HeatmapModel = HeatmapModel;
})(Heatmap || (Heatmap = {}));

var Heatmap;
(function (Heatmap) {
    var HeatmapSettings = (function () {
        function HeatmapSettings(referenceList, minZoom, maxZoom, intensityScale, resolution) {
            if (referenceList === void 0) { referenceList = []; }
            if (minZoom === void 0) { minZoom = 10; }
            if (maxZoom === void 0) { maxZoom = 15; }
            if (intensityScale === void 0) { intensityScale = 3; }
            if (resolution === void 0) { resolution = 2; }
            this.referenceList = referenceList;
            this.minZoom = minZoom;
            this.maxZoom = maxZoom;
            this.intensityScale = intensityScale;
            this.resolution = resolution;
        }
        HeatmapSettings.prototype.addReference = function (reference) {
            // Add unique reference layers only
            if (this.referenceList.indexOf(reference) < 0) {
                this.referenceList.push(reference);
            }
        };
        return HeatmapSettings;
    })();
    Heatmap.HeatmapSettings = HeatmapSettings;
})(Heatmap || (Heatmap = {}));

var Heatmap;
(function (Heatmap) {
    /**
     * A heat spot represents a point on the map with a certain intensity.
     */
    var Heatspot = (function () {
        function Heatspot(i, j, intensity, contributor) {
            this.i = i;
            this.j = j;
            this.intensity = intensity;
            this.contributor = contributor;
        }
        Heatspot.prototype.AddLocation = function (i, j, contributor) {
            return new Heatspot(this.i + i, this.j + j, this.intensity, contributor);
        };
        return Heatspot;
    })();
    Heatmap.Heatspot = Heatspot;
})(Heatmap || (Heatmap = {}));

var Heatmap;
(function (Heatmap) {
    (function (ScoringFunctionType) {
        ScoringFunctionType[ScoringFunctionType["LinearAscendingDescending"] = 0] = "LinearAscendingDescending";
    })(Heatmap.ScoringFunctionType || (Heatmap.ScoringFunctionType = {}));
    var ScoringFunctionType = Heatmap.ScoringFunctionType;
    var ScoringFunction = (function () {
        function ScoringFunction(scoringFunctionType) {
            if (typeof scoringFunctionType != 'undefined' && scoringFunctionType != null)
                this.type = scoringFunctionType;
            this.title = ScoringFunctionType[scoringFunctionType].toString();
        }
        Object.defineProperty(ScoringFunction.prototype, "cssClass", {
            get: function () {
                return ScoringFunctionType[this.type].toLowerCase();
            },
            enumerable: true,
            configurable: true
        });
        return ScoringFunction;
    })();
    Heatmap.ScoringFunction = ScoringFunction;
    var ScoringFunctions = (function () {
        function ScoringFunctions() {
        }
        return ScoringFunctions;
    })();
    Heatmap.ScoringFunctions = ScoringFunctions;
    var IdealityMeasure = (function () {
        function IdealityMeasure(idealDistance, atLocation, lostInterestDistance) {
            if (idealDistance === void 0) { idealDistance = 500; }
            if (atLocation === void 0) { atLocation = 0.1; }
            if (lostInterestDistance === void 0) { lostInterestDistance = 2000; }
            this.idealDistance = idealDistance;
            this.atLocation = atLocation;
            this.lostInterestDistance = lostInterestDistance;
        }
        IdealityMeasure.prototype.computeIdealityAtDistance = function (distance) {
            var intensity = 0;
            if (distance < this.idealDistance) {
                if (this.atLocation >= 1) {
                    intensity = 1;
                }
                else {
                    intensity = (this.atLocation + (1 - this.atLocation) * distance / this.idealDistance);
                }
            }
            else if (distance < this.lostInterestDistance) {
                intensity = (1 - (distance - this.idealDistance) / (this.lostInterestDistance - this.idealDistance));
            }
            return intensity;
        };
        return IdealityMeasure;
    })();
    Heatmap.IdealityMeasure = IdealityMeasure;
})(Heatmap || (Heatmap = {}));

var KanbanBoard;
(function (KanbanBoard) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        KanbanBoard.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        KanbanBoard.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    KanbanBoard.myModule.directive('kanbanboardEdit', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/KanbanBoard/KanbanBoard-edit.tpl.html',
                replace: true,
                transclude: true,
                controller: KanbanBoardEditCtrl
            };
        }
    ]);
    var KanbanBoardEditCtrl = (function () {
        function KanbanBoardEditCtrl($scope, $timeout, $compile, $layerService, $templateCache, $messageBus, $mapService, $dashboardService) {
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$compile = $compile;
            this.$layerService = $layerService;
            this.$templateCache = $templateCache;
            this.$messageBus = $messageBus;
            this.$mapService = $mapService;
            this.$dashboardService = $dashboardService;
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = par.data;
            this.propertyTypes = [];
            var p;
            $scope.data = this.widget.data;
            this.allLayers = $layerService.allLayers();
            if ($scope.data && $scope.data.columns && $scope.data.columns.length > 0)
                $scope.selectedColumn = $scope.data.columns[0];
            console.log($scope.data);
        }
        KanbanBoardEditCtrl.prototype.selectColumn = function () {
            console.log(this.$scope.selectedColumn);
        };
        KanbanBoardEditCtrl.prototype.selectLayer = function () {
            console.log(this.layer);
            this.$messageBus.publish("typesource", "", "");
        };
        //
        // //** select a typesResource collection from the dropdown */
        KanbanBoardEditCtrl.prototype.colorUpdated = function (c, i) {
            i.color = c;
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        KanbanBoardEditCtrl.$inject = [
            '$scope',
            '$timeout',
            '$compile',
            'layerService',
            '$templateCache',
            'messageBusService',
            'mapService', 'dashboardService'
        ];
        return KanbanBoardEditCtrl;
    })();
    KanbanBoard.KanbanBoardEditCtrl = KanbanBoardEditCtrl;
})(KanbanBoard || (KanbanBoard = {}));

var KanbanColumn;
(function (KanbanColumn) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        KanbanColumn.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        KanbanColumn.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    KanbanColumn.myModule.directive('kanbanboard', [
        function () {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/KanbanBoard/KanbanBoard.tpl.html',
                replace: false,
                transclude: false,
                controller: KanbanColumn.KanbanBoardCtrl
            };
        }
    ]);
})(KanbanColumn || (KanbanColumn = {}));

var KanbanColumn;
(function (KanbanColumn) {
    var KanbanConfig = (function () {
        function KanbanConfig() {
        }
        return KanbanConfig;
    })();
    KanbanColumn.KanbanConfig = KanbanConfig;
    var KanbanBoardCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function KanbanBoardCtrl($scope, $layerService, $messageBus) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.feeds = [];
            this.featureTypes = {};
            $scope.vm = this;
            var par = $scope.$parent;
            this.kanban = par.widget.data;
            if (!this.kanban.hasOwnProperty('canAdd'))
                this.kanban.canAdd = true;
            this.$messageBus.subscribe("typesource", function (s) {
                _this.initLayer();
            });
            this.initLayer();
        }
        KanbanBoardCtrl.prototype.addFeature = function (key) {
            var f = new csComp.Services.Feature();
            f.properties = {};
            var ft = this.featureTypes[key];
            if (ft.properties) {
                for (var k in ft.properties) {
                    f.properties[k] = JSON.parse(JSON.stringify(ft.properties[k]));
                }
            }
            f.properties["date"] = new Date();
            f.properties["updated"] = new Date();
            f.properties["featureTypeId"] = key;
            if (!f.properties.hasOwnProperty('Name'))
                f.properties['Name'] = ft.name;
            this.layer.data.features.push(f);
            this.$layerService.initFeature(f, this.layer);
            this.$layerService.editFeature(f);
        };
        KanbanBoardCtrl.prototype.initLayer = function () {
            console.log('kanban:loaded project');
            if (this.kanban && this.kanban.columns && this.kanban.columns.length > 0) {
                var layerId = this.kanban.columns[0].filters.layerId;
                this.layer = this.$layerService.findLayer(layerId);
                if (this.layer) {
                    if (this.layer.typeUrl && this.$layerService.typesResources.hasOwnProperty(this.layer.typeUrl)) {
                        if (this.kanban.featureTypesToAdd) {
                            this.featureTypes = {};
                            for (var ft in this.$layerService.typesResources[this.layer.typeUrl].featureTypes) {
                                if (this.kanban.featureTypesToAdd.indexOf(ft) > -1)
                                    this.featureTypes[ft] = this.$layerService.typesResources[this.layer.typeUrl].featureTypes[ft];
                            }
                        }
                        else {
                            this.featureTypes = this.$layerService.typesResources[this.layer.typeUrl].featureTypes;
                        }
                        console.log('feature types');
                    }
                }
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        KanbanBoardCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService'
        ];
        return KanbanBoardCtrl;
    })();
    KanbanColumn.KanbanBoardCtrl = KanbanBoardCtrl;
})(KanbanColumn || (KanbanColumn = {}));

var KanbanColumn;
(function (KanbanColumn) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        KanbanColumn.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        KanbanColumn.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    KanbanColumn.myModule.directive('kanbanColumn', [
        '$window', '$compile',
        function ($window, $compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {
                    column: '='
                },
                templateUrl: 'directives/KanbanBoard/KanbanColumn.tpl.html',
                replace: false,
                transclude: false,
                controller: KanbanColumn.KanbanColumnCtrl
            };
        }
    ]);
})(KanbanColumn || (KanbanColumn = {}));

var KanbanColumn;
(function (KanbanColumn) {
    var ColumnFilter = (function () {
        function ColumnFilter() {
        }
        return ColumnFilter;
    })();
    KanbanColumn.ColumnFilter = ColumnFilter;
    var Column = (function () {
        function Column() {
        }
        return Column;
    })();
    KanbanColumn.Column = Column;
    var KanbanColumnCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function KanbanColumnCtrl($scope, $layerService, $messageBus, mapService) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.mapService = mapService;
            this.sortOptions = [];
            $scope.vm = this;
            //var par = <any>$scope.$parent;
            //this.kanban = par.widget.data;
            this.column = $scope.column;
            $scope.fields = this.column.fields;
            if ($scope.fields.hasOwnProperty('prio'))
                this.sortOptions = this.sortOptions.concat(['High priority', 'Low Priority']);
            if ($scope.fields.hasOwnProperty('date'))
                this.sortOptions = this.sortOptions.concat(['New', 'Old']);
            if ($scope.fields.hasOwnProperty('updated'))
                this.sortOptions = this.sortOptions.concat(['Updated']);
            this.sortOptions = this.sortOptions.concat(['Title']);
            // check if layers should be enabled
            this.initLayers();
            if (!this.column.hasOwnProperty('canShare'))
                this.column.canShare = true;
            if (this.column.orderBy)
                this.setOrder(this.column.orderBy);
            else
                this.setOrder(this.sortOptions[0]);
            $scope.columnFilter = function (feature) {
                var result = true;
                if (!$scope.column)
                    return false;
                // Check that the layerId is applicable.
                if (result && _this.column.filters.layerId !== feature.layerId)
                    return false;
                // Role filter: is a simple AND filter.
                if (_this.column.filters.roles && _this.column.filters.roles.length > 0 && feature.properties.hasOwnProperty('roles')) {
                    _this.column.filters.roles.forEach(function (r) {
                        if (!_.contains(feature.properties['roles'], r))
                            result = false;
                    });
                }
                // Tag filter: complex filter, combines AND (nothing or +), OR (-), and NOT (~) operations. Based on first character:
                if (result && _this.column.filters.tags && _this.column.filters.tags.length > 0 && _this.column.filters.tags.length > 0) {
                    if (!feature.properties.hasOwnProperty('tags'))
                        return false;
                    var tags = feature.properties['tags'];
                    var or = false;
                    _this.column.filters.tags.some(function (tag) {
                        switch (tag[0]) {
                            case '!':
                            case '~':
                                var t = tag.substr(1, tag.length - 1);
                                if (_.contains(tags, t))
                                    result = false;
                                break;
                            case '-':
                                or = true;
                                break;
                            default:
                                if (!_.contains(tags, tag))
                                    result = false;
                                break;
                        }
                        return !result;
                    });
                    // Add the OR features: if any of the OR tags are true, the result is true
                    if (result && or) {
                        or = false;
                        // Only check if there are OR tags (or === true), and we are still showing this item (result === true).
                        _this.column.filters.tags.some(function (tag) {
                            switch (tag[0]) {
                                case '-':
                                    var t = tag.substr(1, tag.length - 1);
                                    if (_.contains(tags, t))
                                        or = true;
                                    break;
                                default:
                                    break;
                            }
                            return or;
                        });
                    }
                    else {
                        or = true;
                    }
                    result = result && or;
                }
                return result;
            };
            setInterval(function () { _this.updateTime(); }, 1000);
        }
        KanbanColumnCtrl.prototype.getClass = function (feature) {
            if (typeof feature.properties === 'undefined')
                return "";
            if (!feature.properties.hasOwnProperty("question"))
                return "";
            return (feature.properties.hasOwnProperty("answered") && feature.properties["answered"] === true)
                ? "isAnsweredQuestion"
                : "isQuestion";
        };
        KanbanColumnCtrl.prototype.clickPrio = function ($event) {
            // var dropdown: any = $($event.target, "> ul");
            // dropdown.css('top', angular.element($event.target).prop('offsetLeft') + "px");
            // dropdown.css('left', angular.element($event.target).prop('offsetTop') + "px");
        };
        KanbanColumnCtrl.prototype.createForm = function (feature) {
            var _this = this;
            if (feature.gui["questions"]) {
                delete feature.gui["questions"];
                this.$layerService.unlockFeature(feature);
            }
            else if (this.$layerService.lockFeature(feature)) {
                feature.gui["questions"] = [];
                feature.properties[this.column.fields['question']].forEach(function (s) {
                    var pt = _this.$layerService.getPropertyType(feature, s);
                    feature.gui["questions"].push({ property: s, ptype: pt });
                });
            }
        };
        KanbanColumnCtrl.prototype.sendForm = function (feature) {
            feature.properties["answered"] = true;
            delete feature.gui["questions"];
            this.$layerService.unlockFeature(feature);
            this.$layerService.saveFeature(feature, true);
        };
        KanbanColumnCtrl.prototype.saveCategory = function (feature, property, value) {
            feature.properties["answered"] = true;
            feature.properties[property] = value;
            delete feature.gui["questions"];
            this.$layerService.unlockFeature(feature);
            this.$layerService.saveFeature(feature, true);
        };
        KanbanColumnCtrl.prototype.updateTime = function () {
            this.$layerService.project.features.forEach(function (feature) {
                if (feature.properties.hasOwnProperty('date')) {
                    var d = feature.properties['date'];
                    if (!feature.hasOwnProperty('gui'))
                        feature.gui = new Object;
                    feature.gui['relativeTime'] = moment(d).fromNow();
                }
                return "";
            });
        };
        KanbanColumnCtrl.prototype.toggleRole = function (feature, role) {
            if (!feature.properties.hasOwnProperty('roles'))
                feature.properties['roles'] = [];
            if (feature.properties['roles'].indexOf(role) === -1) {
                feature.properties['roles'].push(role);
            }
            else {
                feature.properties['roles'] = feature.properties['roles'].filter(function (s) { return s != role; });
            }
            this.$layerService.saveFeature(feature, true);
        };
        KanbanColumnCtrl.prototype.logFilter = function (feature) {
        };
        KanbanColumnCtrl.prototype.startAction = function (action, feature) {
            this.$messageBus.publish("kanbanaction", action, feature);
        };
        KanbanColumnCtrl.prototype.getPrioColor = function (feature) {
            var colors = ["white", "black", "red", "orange", "blue", "green"];
            if (feature.properties.hasOwnProperty(this.column.fields['prio']))
                return {
                    "background-color": colors[parseInt(feature.properties[this.column.fields['prio']])]
                };
            return { "background-color": "white" };
        };
        KanbanColumnCtrl.prototype.setOrder = function (order) {
            this.$scope.columnOrderTitle = order;
            this.column.orderBy = order;
            switch (order) {
                case 'High priority':
                    this.$scope.columnOrderBy = "properties." + this.$scope.fields['prio'];
                    break;
                case 'Low Priority':
                    this.$scope.columnOrderBy = "-properties." + this.$scope.fields['prio'];
                    break;
                case 'New':
                    this.$scope.columnOrderBy = "-properties." + this.$scope.fields['date'];
                    break;
                case 'Old':
                    this.$scope.columnOrderBy = "properties." + this.$scope.fields['date'];
                    break;
                case 'Updated':
                    this.$scope.columnOrderBy = "-properties." + this.$scope.fields['updated'];
                    break;
                case 'Title':
                    this.$scope.columnOrderBy = "properties." + this.$scope.fields['title'];
                    break;
            }
        };
        KanbanColumnCtrl.prototype.updateFeature = function (feature) {
            this.$layerService.saveFeature(feature, true);
        };
        KanbanColumnCtrl.prototype.selectFeature = function (feature) {
            this.$messageBus.publish('kanban', 'onItemSelect', feature);
            if (feature.properties.hasOwnProperty(this.column.fields['question'])) {
                this.createForm(feature);
            }
            else {
                this.$layerService.selectFeature(feature);
            }
        };
        KanbanColumnCtrl.prototype.editFeature = function (feature) {
            this.$layerService.editFeature(feature);
        };
        KanbanColumnCtrl.prototype.searchFeature = function (feature) {
            this.mapService.zoomTo(feature, 15);
            //this.$mapService.
            //this.$layerService.selectFeature(feature);
        };
        /** make sure all layers/feeds are loaded
        we only use the first one for now
         */
        KanbanColumnCtrl.prototype.initLayers = function () {
            var c = this.$scope.column;
            var lid = c.filters.layerId;
            this.layer = this.$layerService.findLayer(lid);
            if (this.layer) {
                this.$layerService.addLayer(this.layer, function (t) {
                });
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        KanbanColumnCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService',
            'mapService'
        ];
        return KanbanColumnCtrl;
    })();
    KanbanColumn.KanbanColumnCtrl = KanbanColumnCtrl;
})(KanbanColumn || (KanbanColumn = {}));

var LanguageSwitch;
(function (LanguageSwitch) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        LanguageSwitch.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        LanguageSwitch.myModule = angular.module(moduleName, []);
    }
    LanguageSwitch.myModule.directive('languageSwitch', ['$compile', function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/LanguageSwitch/LanguageSwitch.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    return function (scope) {
                        fn(scope);
                    };
                },
                replace: true,
                transclude: true,
                controller: LanguageSwitch.LanguageSwitchCtrl
            };
        }
    ])
        .provider('$languages', function () {
        this.languages = [];
        this.$get = function () {
            return this.languages;
        };
        this.setLanguages = function (languages) {
            this.languages = languages;
        };
    });
})(LanguageSwitch || (LanguageSwitch = {}));

var LanguageSwitch;
(function (LanguageSwitch) {
    var LanguageSwitchCtrl = (function () {
        function LanguageSwitchCtrl($scope, $translate, $languages, $layerService, $messageBus) {
            this.$scope = $scope;
            this.$translate = $translate;
            this.$languages = $languages;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            $scope.vm = this;
            var prefLanguageIndex = 0;
            for (var i = 0; i < $languages.length; i++) {
                if ($languages[i].key === $translate.preferredLanguage()) {
                    prefLanguageIndex = i;
                    break;
                }
            }
            this.language = $languages[prefLanguageIndex];
        }
        LanguageSwitchCtrl.prototype.switchLanguage = function (language) {
            this.language = language;
            this.$translate.use(language.key);
            this.$messageBus.publish('language', 'newLanguage', language.key);
        };
        LanguageSwitchCtrl.$inject = [
            '$scope',
            '$translate',
            '$languages',
            'layerService',
            'messageBusService'
        ];
        return LanguageSwitchCtrl;
    })();
    LanguageSwitch.LanguageSwitchCtrl = LanguageSwitchCtrl;
})(LanguageSwitch || (LanguageSwitch = {}));

var LayersDirective;
(function (LayersDirective) {
    'use strict';
    var AddLayerCtrl = (function () {
        function AddLayerCtrl($scope, $http, $modalInstance, layerService, translate, messageBusService) {
            var _this = this;
            this.$scope = $scope;
            this.$http = $http;
            this.$modalInstance = $modalInstance;
            this.layerService = layerService;
            this.translate = translate;
            this.messageBusService = messageBusService;
            $scope.vm = this;
            this.project = this.layerService.project;
            if (this.project.layerDirectory) {
                $http.get(this.project.layerDirectory)
                    .success(function (result) {
                    _this.layers = result;
                })
                    .error(function () { console.log('AddLayerCtrl: error calling $http'); });
            }
        }
        AddLayerCtrl.prototype.addGroup = function () {
            var _this = this;
            if (!this.layerService.project.groups.some(function (g) { return g.title == _this.groupTitle; })) {
                var gr = new csComp.Services.ProjectGroup();
                gr.title = this.groupTitle;
                gr.description = this.groupDescription;
                this.layerService.project.groups.push(gr);
                this.layerService.initGroup(gr);
                this.done();
            }
        };
        AddLayerCtrl.prototype.selectProjectLayer = function (layer) {
            this.selectedLayer = layer;
        };
        AddLayerCtrl.prototype.addProjectLayer = function () {
            var group = this.layerService.findGroupById(this.layerGroup);
            if (group) {
                this.layerService.initLayer(group, this.selectedLayer);
                group.layers.push(this.selectedLayer);
            }
            this.done();
        };
        AddLayerCtrl.prototype.addLayer = function () {
            var group = this.layerService.findGroupById(this.layerGroup);
            if (group) {
                var l = new csComp.Services.ProjectLayer();
                l.title = this.layerTitle;
                this.layerService.initLayer(group, l);
                group.layers.push(l);
                var rpt = csComp.Helpers.createRightPanelTab("edit", "layeredit", l, "Edit layer");
                this.messageBusService.publish("rightpanel", "activate", rpt);
            }
            this.done();
        };
        AddLayerCtrl.prototype.done = function () {
            this.$modalInstance.close("done");
        };
        AddLayerCtrl.prototype.cancel = function () {
            console.log('cancel');
            this.$modalInstance.dismiss('cancel');
        };
        AddLayerCtrl.$inject = [
            '$scope',
            '$http',
            '$modalInstance',
            'layerService',
            '$translate',
            'messageBusService'
        ];
        return AddLayerCtrl;
    })();
    LayersDirective.AddLayerCtrl = AddLayerCtrl;
})(LayersDirective || (LayersDirective = {}));

var LayersDirective;
(function (LayersDirective) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        LayersDirective.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        LayersDirective.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    LayersDirective.myModule.directive('layersDirective', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/LayersList/LayersDirective.tpl.html',
                replace: true,
                transclude: true,
                controller: LayersDirective.LayersDirectiveCtrl
            };
        }
    ]);
})(LayersDirective || (LayersDirective = {}));

var LayersDirective;
(function (LayersDirective) {
    var LayersDirectiveCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function LayersDirectiveCtrl($scope, $layerService, $messageBusService, $mapService, $dashboardService, $modal, $http) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBusService = $messageBusService;
            this.$mapService = $mapService;
            this.$dashboardService = $dashboardService;
            this.$modal = $modal;
            this.$http = $http;
            this.state = "layers";
            this.updateLayerOpacity = _.debounce(function (layer) {
                console.log('update opacity');
                if (!layer)
                    return;
                if (layer.renderType && layer.renderType.toLowerCase() === 'gridlayer') {
                    _this.$layerService.updateCanvasOverlay(layer);
                }
                else {
                    _this.$layerService.updateLayerFeatures(layer);
                }
            }, 500);
            $scope.vm = this;
            $scope.options = (function (layer) {
                if (!layer.enabled)
                    return null;
                if (layer.layerSource) {
                    return layer.layerSource.layerMenuOptions(layer);
                }
            });
            this.allCollapsed = false;
            this.$messageBusService.subscribe('project', function (title, project) {
                if (title !== 'loaded' || !project)
                    return;
                if (project.hasOwnProperty('collapseAllLayers') && project.collapseAllLayers === true) {
                    _this.allCollapsed = true;
                }
                else {
                    _this.allCollapsed = false;
                }
            });
        }
        LayersDirectiveCtrl.prototype.editGroup = function (group) {
            var rpt = csComp.Helpers.createRightPanelTab('edit', 'groupedit', group, 'Edit group', 'Edit group');
            this.$messageBusService.publish('rightpanel', 'activate', rpt);
        };
        LayersDirectiveCtrl.prototype.editLayer = function (layer) {
            var rpt = csComp.Helpers.createRightPanelTab('edit', 'layeredit', layer, 'Edit layer', 'Edit layer');
            this.$messageBusService.publish('rightpanel', 'activate', rpt);
        };
        LayersDirectiveCtrl.prototype.createType = function () {
            if (this.layer.typeUrl) {
                if (this.$layerService.typesResources.hasOwnProperty(this.layer.typeUrl)) {
                    var tr = this.$layerService.typesResources[this.layer.typeUrl];
                    var st = {
                        drawingMode: 'point',
                        fillColor: 'red'
                    };
                    var nt = {
                        id: 'test', name: 'test', style: st
                    };
                    var id = nt.id;
                    tr.featureTypes[id] = nt;
                    console.log(tr);
                }
            }
        };
        LayersDirectiveCtrl.prototype.initGroups = function () {
            var _this = this;
            this.groups = [];
            if (this.$layerService.project.groups)
                this.$layerService.project.groups.forEach(function (g) { return _this.groups.push(g); });
            var g = new csComp.Services.ProjectGroup;
            g.id = "<new>";
            g.title = "<new group>";
            this.groups.push(g);
        };
        LayersDirectiveCtrl.prototype.initDrag = function (key, layer) {
            var _this = this;
            var transformProp;
            var startx, starty;
            var i = interact('#layerfeaturetype-' + key)
                .draggable({
                max: Infinity,
                onstart: function (event) {
                    startx = 0;
                    starty = 0;
                    event.interaction.x = parseInt(event.target.getAttribute('data-x'), 10) || 0;
                    event.interaction.y = parseInt(event.target.getAttribute('data-y'), 10) || 0;
                },
                onmove: function (event) {
                    event.interaction.x += event.dx;
                    event.interaction.y += event.dy;
                    event.target.style.left = event.interaction.x + 'px';
                    event.target.style.top = event.interaction.y + 'px';
                },
                onend: function (event) {
                    setTimeout(function () {
                        var x = event.clientX;
                        var y = event.clientY;
                        var pos = _this.$layerService.activeMapRenderer.getLatLon(x, y - 50);
                        console.log(pos);
                        var f = new csComp.Services.Feature();
                        f.layerId = layer.id;
                        f.geometry = {
                            type: 'Point', coordinates: [pos.lon, pos.lat]
                        };
                        //f.
                        f.properties = { "featureTypeId": key, "Name": key };
                        layer.data.features.push(f);
                        _this.$layerService.initFeature(f, layer);
                        _this.$layerService.activeMapRenderer.addFeature(f);
                        _this.$layerService.saveFeature(f);
                    }, 100);
                    //this.$dashboardService.mainDashboard.widgets.push(widget);
                    event.target.setAttribute('data-x', 0);
                    event.target.setAttribute('data-y', 0);
                    event.target.style.left = '0px';
                    event.target.style.top = '0px';
                    console.log(key);
                }
            });
        };
        LayersDirectiveCtrl.prototype.selectProjectLayer = function (layer) {
            this.selectedLayer = layer;
        };
        LayersDirectiveCtrl.prototype.exitDirectory = function () {
            this.selectedLayer = null;
            this.layerTitle = "";
            this.state = 'layers';
        };
        LayersDirectiveCtrl.prototype.addProjectLayer = function () {
            var group = this.$layerService.findGroupById(this.layerGroup);
            if (group) {
                this.$layerService.initLayer(group, this.selectedLayer);
                group.layers.push(this.selectedLayer);
            }
            this.selectedLayer = null;
            this.state = "layers";
        };
        LayersDirectiveCtrl.prototype.startAddingFeatures = function (layer) {
            this.state = "editlayer";
            layer.layerSource.startAddingFeatures(layer);
            this.layer = layer;
            if (!this.layer.typeUrl) {
            }
        };
        LayersDirectiveCtrl.prototype.stopAddingFeatures = function (layer) {
            this.state = "layers";
            if (layer.gui["featureTypes"]) {
                for (var key in layer.gui["featureTypes"]) {
                    interact('#layerfeaturetype-' + key).onstart = null;
                    interact('#layerfeaturetype-' + key).onmove = null;
                    interact('#layerfeaturetype-' + key).onend = null;
                }
                ;
            }
            layer.layerSource.stopAddingFeatures(layer);
        };
        LayersDirectiveCtrl.prototype.setLayerOpacity = function (layer) {
            this.updateLayerOpacity(layer);
        };
        LayersDirectiveCtrl.prototype.openLayerMenu = function (e) {
            //e.stopPropagation();
            $('.left-menu').contextmenu('show', e);
            //alert('open layers');
        };
        LayersDirectiveCtrl.prototype.loadAvailableLayers = function () {
            var _this = this;
            this.project = this.$layerService.project;
            this.mylayers = [];
            if (this.project.groups) {
                this.project.groups.forEach(function (g) {
                    g.layers.forEach(function (l) { return _this.mylayers.push(l.url); });
                });
            }
            if (this.project.layerDirectory) {
                $.getJSON(this.project.layerDirectory, function (result) {
                    _this.directory = [];
                    for (var l in result)
                        _this.directory.push(result[l]);
                });
            }
        };
        LayersDirectiveCtrl.prototype.openDirectory = function () {
            this.initGroups();
            this.state = "directory";
            this.loadAvailableLayers();
            return;
            var modalInstance = this.$modal.open({
                templateUrl: 'directives/LayersList/AddLayerView.tpl.html',
                controller: LayersDirective.AddLayerCtrl,
                resolve: {}
            });
            modalInstance.result.then(function (s) {
                console.log('done adding');
                console.log(s);
                // this.showSparkline = false;
                // this.addMca(mca);
                // this.updateMca();
                //console.log(JSON.stringify(mca, null, 2));
            }, function () {
                //console.log('Modal dismissed at: ' + new Date());
            });
        };
        LayersDirectiveCtrl.prototype.initResources = function () {
            var _this = this;
            this.resources = {};
            if (!this.project.groups)
                return;
            this.project.groups.forEach(function (g) {
                if (g.layers)
                    g.layers.forEach(function (l) {
                        if (l.typeUrl && !_this.resources.hasOwnProperty(l.typeUrl))
                            _this.resources[l.typeUrl] = { title: l.typeUrl };
                    });
            });
            this.resources["<new>"] = { title: "<new type file>" };
            this.layerResourceType = "<new>";
        };
        LayersDirectiveCtrl.prototype.createLayer = function () {
            this.initGroups();
            this.loadAvailableLayers();
            this.initResources();
            if (this.$layerService.project.groups && this.$layerService.project.groups.length > 0) {
                this.layerGroup = this.$layerService.project.groups[0].id;
            }
            else {
                this.layerGroup = new csComp.Services.ProjectGroup;
                this.layerGroup.id = "<new>";
                this.layerGroup.title = "<new group>";
                this.$layerService.project.groups = [];
            }
            this.state = "createlayer";
            this.newLayer = new csComp.Services.ProjectLayer();
            this.newLayer.type = "dynamicgeojson";
        };
        LayersDirectiveCtrl.prototype.addLayer = function () {
            //this.loadAvailableLayers();
            var group;
            if (this.layerGroup == "<new>") {
                group = new csComp.Services.ProjectGroup;
                group.title = this.newGroup;
                this.$layerService.project.groups.push(group);
                this.$layerService.initGroup(group);
            }
            else {
                group = this.$layerService.findGroupById(this.layerGroup);
            }
            if (group) {
                this.$layerService.initLayer(group, this.newLayer);
                group.layers.push(this.newLayer);
                var nl = this.newLayer;
                /// create layer on server
                if (this.newLayer.type === "dynamicgeojson") {
                    this.newLayer.url = "api/layers/" + nl.title;
                    if (this.layerResourceType === "<new>") {
                        this.newLayer.typeUrl = "/api/resources/" + this.newLayer.title;
                        var r = { id: this.newLayer.title, title: this.newLayer.title, featureTypes: {}, propertyTypeData: {} };
                        this.$http.post("/api/resources/" + this.newLayer.title, r)
                            .success(function (data) {
                        })
                            .error(function (e) {
                            console.log('error adding resource');
                        });
                    }
                    else {
                        this.newLayer.typeUrl = this.layerResourceType;
                    }
                    var l = { id: nl.title, title: nl.title, isDynamic: true, type: nl.type, storage: 'file', description: nl.description, typeUrl: nl.typeUrl, tags: nl.tags, url: nl.url };
                    this.$http.post("/api/layers", l)
                        .success(function (data) {
                        console.log(data);
                    })
                        .error(function () {
                        console.log('error adding layer');
                    });
                }
                if (this.layerResourceType === "<new>") {
                }
                var rpt = csComp.Helpers.createRightPanelTab("edit", "layeredit", this.newLayer, "Edit layer");
                this.$messageBusService.publish("rightpanel", "activate", rpt);
            }
            this.exitDirectory();
        };
        LayersDirectiveCtrl.prototype.toggleLayer = function (layer) {
            $(".left-menu").on("click", function (clickE) {
                //alert('context menu');
                $(this).contextmenu({ x: clickE.offsetX, y: clickE.offsetY });
            });
            //layer.enabled = !layer.enabled;
            //if (this.$layerService.loadedLayers.containsKey(layer.id)) {
            // Unselect when dealing with a radio group, so you can turn a loaded layer off again.
            this.$layerService.toggleLayer(layer);
            // NOTE EV: You need to call apply only when an event is received outside the angular scope.
            // However, make sure you are not calling this inside an angular apply cycle, as it will generate an error.
            if (this.$scope.$root.$$phase != '$apply' && this.$scope.$root.$$phase != '$digest') {
                this.$scope.$apply();
            }
        };
        LayersDirectiveCtrl.prototype.collapseAll = function () {
            this.$layerService.collapseAll();
            this.allCollapsed = true;
            if (this.$scope.$root.$$phase != '$apply' && this.$scope.$root.$$phase != '$digest') {
                this.$scope.$apply();
            }
        };
        LayersDirectiveCtrl.prototype.expandAll = function () {
            this.$layerService.expandAll();
            this.allCollapsed = false;
            if (this.$scope.$root.$$phase != '$apply' && this.$scope.$root.$$phase != '$digest') {
                this.$scope.$apply();
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        LayersDirectiveCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService',
            'mapService',
            'dashboardService',
            '$modal', '$http'
        ];
        return LayersDirectiveCtrl;
    })();
    LayersDirective.LayersDirectiveCtrl = LayersDirectiveCtrl;
})(LayersDirective || (LayersDirective = {}));

var Legend;
(function (Legend) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Legend.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Legend.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a legend in a widget.
      */
    Legend.myModule.directive('legendDirective', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Legend/Legend.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    //console.log('this is the compile function of legendDirective');
                    return function (scope) {
                        fn(scope);
                    };
                },
                replace: true,
                transclude: true,
                controller: Legend.LegendCtrl
            };
        }
    ]);
})(Legend || (Legend = {}));

var Legend;
(function (Legend) {
    // created 12 May 2015, RPS, TNO
    // TODO1: decide how to determine which legend (from which layer) shows up immediately after loading
    // currently the last added layer shows up which is the netatmo layer in csMapUS.
    // And after a reload (refresh), the one for the current indicator's layer shows up
    // TODO2: disappear when empty -> reopen legend for the most recently activated layer that is still active
    // TODO3: positioning: from bottom up (using "bottom" in the project.json file didn't work)
    // TODO4: provide possibility to not show a legend at all. Either by a hide button (but how to show then)
    // or via a project/user setting
    var LegendData = (function () {
        function LegendData() {
        }
        return LegendData;
    })();
    Legend.LegendData = LegendData;
    var LegendCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function LegendCtrl($scope, $layerService, $messageBus) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.passcount = 1;
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = (par.widget);
            //console.log(JSON.stringify(this.widget.data));
            //$scope.title = this.widget.title;
            //$scope.timestamp = '19:45';
            if (this.widget && this.widget.data)
                $scope.data = this.widget.data;
            //$scope.s1 = $scope.data.propertyTypeKey;
            if (this.widget && this.widget.data && this.widget.data.hasOwnProperty('propertyTypeKey'))
                var ptd = this.$layerService.propertyTypeData[$scope.data.propertyTypeKey];
            //if (ptd) $scope.s2 = ptd.title;
            //$scope.s3 = 'passcount=' + this.passcount.toString();
            // if ($scope.data.mode = 'lastSelectedStyle') {
            //     $scope.legend = this.createLegend($scope.data.propertyTypeKey);
            // }
            if ($scope.data && $scope.data.mode === 'lastSelectedStyle') {
                $scope.legend = this.createLegend();
                if ($scope.$parent.hasOwnProperty('widget')) {
                    if (!$scope.legend.hasOwnProperty('legendEntries')) {
                        $scope.$parent.widget['enabled'] = false;
                    }
                    else {
                        $scope.$parent.widget['enabled'] = true;
                    }
                }
                if (!this.subscribeHandle) {
                    this.subscribeHandle = this.$messageBus.subscribe("updatelegend", function (title, ptdataKey) {
                        switch (title) {
                            case 'removelegend':
                                _this.$messageBus.unsubscribe(_this.subscribeHandle);
                                break;
                            default:
                                if (ptd && ptd.legend) {
                                    $scope.legend = ptd.legend;
                                }
                                if ($scope.data.mode = 'lastSelectedStyle') {
                                    $scope.legend = _this.createLegend();
                                    if ($scope.$parent.hasOwnProperty('widget')) {
                                        if (!$scope.legend.hasOwnProperty('legendEntries')) {
                                            $scope.$parent.widget['enabled'] = false;
                                        }
                                        else {
                                            $scope.$parent.widget['enabled'] = true;
                                        }
                                    }
                                }
                                if (_this.$scope.$root.$$phase != '$apply' && _this.$scope.$root.$$phase != '$digest') {
                                    _this.$scope.$apply();
                                }
                        }
                    });
                }
            }
        }
        LegendCtrl.prototype.createLegend = function () {
            var leg = new csComp.Services.Legend();
            var activeStyle;
            this.$layerService.project.groups.forEach(function (g) {
                g.styles.forEach(function (gs) {
                    if (gs.enabled) {
                        activeStyle = gs;
                    }
                });
            });
            if (!activeStyle)
                return leg;
            var ptd = this.$layerService.propertyTypeData[activeStyle.property];
            if (!ptd)
                return leg;
            leg.id = ptd.label + 'legendcolors';
            leg.legendKind = 'interpolated';
            leg.description = ptd.title;
            leg.legendEntries = [];
            if (activeStyle.activeLegend && activeStyle.activeLegend.legendEntries) {
                activeStyle.activeLegend.legendEntries.forEach(function (le) {
                    leg.legendEntries.push(le);
                });
            }
            else {
                leg.legendEntries.push(this.createLegendEntry(activeStyle, ptd, activeStyle.info.min));
                leg.legendEntries.push(this.createLegendEntry(activeStyle, ptd, (activeStyle.info.min + activeStyle.info.max) / 4));
                leg.legendEntries.push(this.createLegendEntry(activeStyle, ptd, 2 * (activeStyle.info.min + activeStyle.info.max) / 4));
                leg.legendEntries.push(this.createLegendEntry(activeStyle, ptd, 3 * (activeStyle.info.min + activeStyle.info.max) / 4));
                leg.legendEntries.push(this.createLegendEntry(activeStyle, ptd, activeStyle.info.max));
                leg.legendEntries = leg.legendEntries.sort(function (a, b) { return (a.value - b.value); });
            }
            return leg;
        };
        LegendCtrl.prototype.createLegendEntry = function (activeStyle, ptd, value) {
            var le = new csComp.Services.LegendEntry();
            le.label = csComp.Helpers.convertPropertyInfo(ptd, value);
            if (le.label === value.toString()) {
                //if no stringformatting was applied, define one based on maximum values
                if (activeStyle.info.max > 100) {
                    le.label = String.format("{0:#,#}", value);
                }
                else {
                    le.label = String.format("{0:#,#.#}", value);
                }
            }
            le.value = value;
            le.color = csComp.Helpers.getColor(value, activeStyle);
            return le;
        };
        LegendCtrl.prototype.getStyle = function (legend, le, key) {
            var style = {
                'float': 'left',
                'position': 'relative',
                'top': '10px',
                'background': "linear-gradient(to bottom, " + le.color + ", " + legend.legendEntries[legend.legendEntries.length - key - 2].color + ")",
                'border-left': '1px solid black',
                'border-right': '1px solid black'
            };
            if (key === 0) {
                style['border-top'] = '1px solid black';
            }
            else if (key === legend.legendEntries.length - 2) {
                style['border-bottom'] = '1px solid black';
            }
            return style;
        };
        // $inject annotation
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        LegendCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService'
        ];
        return LegendCtrl;
    })();
    Legend.LegendCtrl = LegendCtrl;
})(Legend || (Legend = {}));

var LegendList;
(function (LegendList) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        LegendList.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        LegendList.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    LegendList.myModule.directive('legendList', [
        '$window', '$compile',
        function ($window, $compile) {
            return {
                terminal: false,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/LegendList/LegendList.tpl.html',
                // Directives that want to modify the DOM typically use the link option.link takes a function with the following signature, function link(scope, element, attrs) { ... } where:
                // scope is an Angular scope object.
                // element is the jqLite - wrapped element that this directive matches.
                // attrs is a hash object with key - value pairs of normalized attribute names and their corresponding attribute values.
                link: function (scope, element, attrs) {
                    // Deal with resizing the element list
                    scope.onResizeFunction = function () {
                        var filterHeight = 50;
                        var paginationCtrlHeight = 100;
                        var itemHeight = 60;
                        //scope.windowHeight          = $window.innerHeight;
                        //scope.windowWidth           = $window.innerWidth;
                        scope.numberOfItems = Math.floor(($window.innerHeight - filterHeight - paginationCtrlHeight) / itemHeight);
                    };
                    // Call to the function when the page is first loaded
                    scope.onResizeFunction();
                    angular.element($window).bind('resize', function () {
                        scope.onResizeFunction();
                        scope.$apply();
                    });
                },
                replace: true,
                transclude: true,
                controller: LegendList.LegendListCtrl
            };
        }
    ]);
})(LegendList || (LegendList = {}));

var LegendList;
(function (LegendList) {
    var LegendListCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function LegendListCtrl($scope, $layerService, $mapService, $messageBusService, $sce) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$mapService = $mapService;
            this.$messageBusService = $messageBusService;
            this.$sce = $sce;
            $scope.vm = this;
            $messageBusService.subscribe('project', function (title) {
                switch (title) {
                    case "loaded":
                        // Update the legend when a project is loaded.
                        _this.updateLegendItems();
                        break;
                }
            });
            $messageBusService.subscribe('layer', function (title) {
                switch (title) {
                    case "activated":
                    case "deactivate":
                        // Update the legend when a layer is added or removed.
                        _this.updateLegendItems();
                        break;
                }
            });
            this.updateLegendItems();
            $scope.legendItems = [];
            $scope.numberOfItems = 10; // This is being reset in the directive upon receiving a resize.
        }
        /**
         * Three approaches for creating a legend can be used:
         * 1. Using the featureTypes loaded in LayerService, which is quick, but also includes items that are not on the list.
         *    Also, when deactivating the layer, items persist in the legendlist. Finally, items with an icon based on a property
         *    are only shown once (e.g., houses with energylabels).
         * 2. Second approach is to loop over all features on the map and select unique legend items. This is slower for large
         *    amounts of features, but the items in the legendlist are always complete and correct.
         * 3. Third approach is to use a legend that is defined in a featuretype. This is useful if you want to show a custom legend.
         * For 1. use "updateLegendItemsUsingFeatureTypes()", for 2. use "updateLegendItemsUsingFeatures(), for 3. use "updateLegendStatically()"
         */
        LegendListCtrl.prototype.updateLegendItems = function () {
            //this.updateLegendItemsUsingFeatureTypes(); // 1.
            this.updateLegendItemsUsingFeatures(); // 2.
            //this.updateLegendStatically(); // 3.
        };
        /**
         * Loops over every layer in the project. If a layer is enabled, has a typeUrl and a defaultFeatureType,
         * that corresponding featureType is acquired. When the featureType has a property 'legend' in which legenditems are defined,
         * these items are added to the legend.
         * Example definition in the FeatureType:
         * "MyFeatureType" : {
         *   "legendItems" : [{
         *     "title" : "My feature",
         *     "uri" : "images/myicon.png"
         *   }]
         * }
         */
        LegendListCtrl.prototype.updateLegendStatically = function () {
            var _this = this;
            var project = this.$layerService.project;
            if (!project)
                return;
            if (!project.hasOwnProperty('groups')) {
                console.log('Creating legend failed: no groups found');
                return;
            }
            var legendItems = [];
            var processedFeatureTypes = {};
            project.groups.forEach(function (g) {
                if (g.hasOwnProperty('layers')) {
                    g.layers.forEach(function (l) {
                        if (l.enabled && l.hasOwnProperty('typeUrl') && l.hasOwnProperty('defaultFeatureType')) {
                            var typeName = l.typeUrl + "#" + l.defaultFeatureType;
                            var fType = _this.$layerService.getFeatureTypeById(typeName);
                            if (!processedFeatureTypes.hasOwnProperty(typeName) && fType && fType.hasOwnProperty('legendItems')) {
                                fType['legendItems'].forEach(function (i) {
                                    legendItems.push({ title: i.title, uri: i.uri || '', html: i.html || '' });
                                });
                            }
                            processedFeatureTypes[typeName] = true;
                        }
                    });
                }
            });
            this.$scope.legendItems = legendItems;
        };
        LegendListCtrl.prototype.updateLegendItemsUsingFeatureTypes = function () {
            var legendItems = [];
            var existingItems = [];
            for (var key in this.$layerService._featureTypes) {
                var ft = this.$layerService._featureTypes[key];
                var uri = csComp.Helpers.getImageUri(ft);
                var html = '';
                var title = this.getName(key, ft);
                var existingItem = title + uri;
                if (existingItems.indexOf(existingItem) < 0) {
                    existingItems.push(existingItem);
                    legendItems.push({ "title": title, "uri": uri, "html": html });
                }
            }
            legendItems.sort(function (a, b) {
                if (a.title > b.title)
                    return 1;
                if (a.title < b.title)
                    return -1;
                return 0;
            });
            this.$scope.legendItems = legendItems;
        };
        LegendListCtrl.prototype.updateLegendItemsUsingFeatures = function () {
            var _this = this;
            var legendItems = [];
            var existingItems = [];
            if (!this.$layerService.project || this.$layerService.project.features.length === 0) {
                this.$scope.legendItems = legendItems;
                return;
            }
            this.$layerService.project.features.forEach(function (f) {
                var ft = f.fType;
                if (!ft)
                    ft = _this.$layerService.getFeatureType(f);
                var uri = (ft && ft.style && ft.style.hasOwnProperty('iconUri')) ? csComp.Helpers.convertStringFormat(f, ft.style.iconUri) : csComp.Helpers.getImageUri(ft);
                if (uri.indexOf('_Media') >= 0)
                    f.effectiveStyle.iconUri = "cs/images/polygon.png";
                var html = csComp.Helpers.createIconHtml(f, ft)['html'];
                var title = ft.name || f.layer.title || ((ft.id) ? ft.id.split('#').pop() : 'undefined');
                var existingItem = title + uri;
                if (existingItems.indexOf(existingItem) < 0) {
                    existingItems.push(existingItem);
                    legendItems.push({ "title": title, "uri": uri, "html": html });
                }
            });
            legendItems.sort(function (a, b) {
                if (a.title > b.title)
                    return 1;
                if (a.title < b.title)
                    return -1;
                return 0;
            });
            this.$scope.legendItems = legendItems;
        };
        LegendListCtrl.prototype.getName = function (key, ft) {
            return ft.name || key.split('#').pop();
        };
        LegendListCtrl.prototype.toTrusted = function (html) {
            try {
                if (html === undefined || html === null)
                    return this.$sce.trustAsHtml(html);
                return this.$sce.trustAsHtml(html.toString());
            }
            catch (e) {
                console.log(e + ': ' + html);
                return '';
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        LegendListCtrl.$inject = [
            '$scope',
            'layerService',
            'mapService',
            'messageBusService',
            '$sce'
        ];
        return LegendListCtrl;
    })();
    LegendList.LegendListCtrl = LegendListCtrl;
})(LegendList || (LegendList = {}));

var MapElement;
(function (MapElement) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        MapElement.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        MapElement.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    MapElement.myModule.directive('map', [
        '$window', '$compile',
        function ($window, $compile) {
            return {
                terminal: false,
                restrict: 'E',
                scope: {
                    mapid: '='
                },
                //templateUrl: 'directives/MapElement/MapElement.tpl.html',
                templateUrl: 'directives/MapElement/MapElement.tpl.html',
                link: function (scope, element, attrs) {
                    //scope.mapid = attrs.mapid;
                    //var s = jQuery.parseJSON(attrs.param);
                    //scope.initDashboard();
                },
                replace: false,
                transclude: true,
                controller: MapElement.MapElementCtrl
            };
        }
    ]);
})(MapElement || (MapElement = {}));

var MapElement;
(function (MapElement) {
    var MapElementCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function MapElementCtrl($scope, $layerService, mapService, $messageBusService) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.mapService = mapService;
            this.$messageBusService = $messageBusService;
            this.locale = "en-us";
            this.options = ["test", "boe"];
            $scope.vm = this;
            this.initMap();
            $scope.initMap = function () { return _this.initMap(); };
        }
        MapElementCtrl.prototype.initMap = function () {
            this.$layerService.selectRenderer("leaflet");
            //alert(this.$scope.mapId);
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        MapElementCtrl.$inject = [
            '$scope',
            'layerService',
            'mapService',
            'messageBusService'
        ];
        return MapElementCtrl;
    })();
    MapElement.MapElementCtrl = MapElementCtrl;
})(MapElement || (MapElement = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Mca;
(function (Mca_1) {
    var Models;
    (function (Models) {
        (function (ScoringFunctionType) {
            ScoringFunctionType[ScoringFunctionType["Manual"] = 0] = "Manual";
            ScoringFunctionType[ScoringFunctionType["Ascending"] = 1] = "Ascending";
            ScoringFunctionType[ScoringFunctionType["Descending"] = 2] = "Descending";
            ScoringFunctionType[ScoringFunctionType["AscendingSigmoid"] = 3] = "AscendingSigmoid";
            ScoringFunctionType[ScoringFunctionType["DescendingSigmoid"] = 4] = "DescendingSigmoid";
            ScoringFunctionType[ScoringFunctionType["GaussianPeak"] = 5] = "GaussianPeak";
            ScoringFunctionType[ScoringFunctionType["GaussianValley"] = 6] = "GaussianValley";
        })(Models.ScoringFunctionType || (Models.ScoringFunctionType = {}));
        var ScoringFunctionType = Models.ScoringFunctionType;
        /**
        * Scoring function creates a PLA of the scoring algorithm.
        */
        var ScoringFunction = (function () {
            //get img(): string {
            //    return '/includes/images/plot' + csComp.StringExt.Utils.toUnderscore(ScoringFunctionType[this.type]) + '.png';
            //}
            function ScoringFunction(scoringFunctionType) {
                if (typeof scoringFunctionType != 'undefined' && scoringFunctionType != null)
                    this.type = scoringFunctionType;
                this.title = ScoringFunctionType[scoringFunctionType].toString();
            }
            Object.defineProperty(ScoringFunction.prototype, "cssClass", {
                get: function () {
                    return ScoringFunctionType[this.type].toLowerCase();
                },
                enumerable: true,
                configurable: true
            });
            /**
             * Create a score based on the type, in which x in [0,10] and y in [0.1].
             * Before applying it, you need to scale the x-axis based on your actual range.
             * Typically, you would map x=0 to the min(x)+0.1*range(x) and x(10)-0.1*range(x) to max(x),
             * i.e. x' = ax+b, where a=100/(8r) and b=-100(min+0.1r)/(8r) and r=max-min
             */
            ScoringFunction.createScores = function (type) {
                var scores;
                switch (type) {
                    default:
                    case ScoringFunctionType.Ascending:
                        scores = '[0,0 10,1]';
                        break;
                    case ScoringFunctionType.Descending:
                        scores = '[0,1 10,0]';
                        break;
                    case ScoringFunctionType.AscendingSigmoid:
                        // http://mathnotepad.com/: f(x) = (3.5+2*atan(x-5))/7
                        // f([0,1,2,3,4,5,6,7,8,9,10])
                        // round(100*f([0,1,2,3,4,5,6,7,8,9,10]))/100
                        // [0.11 0.12 0.14 0.18 0.28 0.5 0.72 0.82 0.86 0.88 0.89]
                        scores = '[0,0.11 1,0.12 2,0.14 3,0.18 4,0.28 5,0.5 6,0.72 7,0.82 8,0.86 9,0.88 10,0.89]';
                        break;
                    case ScoringFunctionType.DescendingSigmoid:
                        // 1-f(x)
                        scores = '[0,0.89 1,0.88 2,0.86 3,0.82 4,0.72 5,0.5 6,0.28 7,0.18 8,0.14 9,0.12 10,0.11]';
                        break;
                    case ScoringFunctionType.GaussianPeak:
                        // h(x)=3*exp(-((x-u)^2)/(2s^2))/(s*sqrt(2pi))
                        scores = '[0,0 2,0.04 3,0.25 4,0.7 5,1 6,0.7 7,0.25 8,0.04 9,0]';
                        break;
                    case ScoringFunctionType.GaussianValley:
                        // 1-h(x)
                        scores = '[0,1 2,0.96 3,0.75 4,0.3 5,0 6,0.3 7,0.75 8,0.96 9,0]';
                        break;
                }
                return scores;
            };
            return ScoringFunction;
        })();
        Models.ScoringFunction = ScoringFunction;
        var ScoringFunctions = (function () {
            function ScoringFunctions() {
            }
            return ScoringFunctions;
        })();
        Models.ScoringFunctions = ScoringFunctions;
        var Criterion = (function () {
            function Criterion() {
                /** Specified weight by the user */
                this.userWeight = 1;
                this.propValues = [];
                this.criteria = [];
                /** Piece-wise linear approximation of the scoring function by a set of x and y points */
                this.isPlaUpdated = false;
                /** Piece-wise linear approximation must be scaled:x' = ax+b, where a=100/(8r) and b=-100(min+0.1r)/(8r) and r=max-min */
                this.isPlaScaled = false;
                this.x = [];
                this.y = [];
            }
            Criterion.prototype.deserialize = function (input) {
                var _this = this;
                this.title = input.title;
                this.description = input.description;
                this.label = input.label;
                this.color = input.color;
                this.userWeight = input.userWeight;
                this.weight = input.weight;
                this.isPlaScaled = input.isPlaScaled;
                this.scores = input.scores;
                this.minCutoffValue = input.minCutoffValue;
                this.maxCutoffValue = input.maxCutoffValue;
                this.minValue = input.minValue;
                this.maxValue = input.maxValue;
                input.criteria.forEach(function (c) {
                    _this.criteria.push(new Criterion().deserialize(c));
                });
                return this;
            };
            Criterion.prototype.requiresMinimum = function () {
                return this.scores && this.scores.indexOf('min') >= 0;
            };
            Criterion.prototype.requiresMaximum = function () {
                return this.scores && this.scores.indexOf('max') >= 0;
            };
            Criterion.prototype.getTitle = function () {
                if (this.title)
                    return this.title;
                return this.label;
            };
            /**
             * Update the piecewise linear approximation (PLA) of the scoring (a.k.a. user) function,
             * which translates a property value to a MCA value in the range [0,1] using all features.
             */
            Criterion.prototype.updatePla = function (features) {
                var _this = this;
                if (this.isPlaUpdated)
                    return;
                if (this.criteria.length > 0) {
                    this.criteria.forEach(function (c) {
                        c.updatePla(features);
                    });
                    this.isPlaUpdated = true;
                    return;
                }
                // Replace min and max by their values:
                if (this.scores == null)
                    return;
                var scores = this.scores;
                this.propValues = [];
                if (this.requiresMaximum() || this.requiresMinimum() || this.isPlaScaled) {
                    features.forEach(function (feature) {
                        if (feature.properties.hasOwnProperty(_this.label)) {
                            // The property is available. I use the '+' to convert the string value to a number.
                            var prop = feature.properties[_this.label];
                            if ($.isNumeric(prop))
                                _this.propValues.push(prop);
                        }
                    });
                }
                var max = this.maxValue, min = this.minValue;
                if (this.isPlaScaled || this.requiresMaximum()) {
                    max = max || Math.max.apply(null, this.propValues);
                    scores.replace('max', max.toPrecision(3));
                }
                if (this.isPlaScaled || this.requiresMinimum()) {
                    min = min || Math.min.apply(null, this.propValues);
                    scores.replace('min', min.toPrecision(3));
                }
                if (this.isPlaScaled) {
                    var stats = csComp.Helpers.standardDeviation(this.propValues);
                    max = max || Math.min(max, stats.avg + 2 * stats.stdDev);
                    min = min || Math.max(min, stats.avg - 2 * stats.stdDev);
                }
                // Regex to split the scores: [^\d\.]+ and remove empty entries
                var pla = scores.split(/[^\d\.]+/).filter(function (item) { return item.length > 0; });
                // Test that we have an equal number of x and y,
                var range = max - min, a, b;
                if (this.minValue != null || this.maxValue != null) {
                    a = range / 10;
                    b = min;
                }
                else {
                    a = 0.08 * range,
                        b = min + 0.1 * range;
                }
                if (pla.length % 2 !== 0)
                    throw Error(this.label + ' does not have an even (x,y) pair in scores.');
                for (var i = 0; i < pla.length / 2; i++) {
                    var x = parseFloat(pla[2 * i]);
                    if (this.isPlaScaled) {
                        // Scale x, i.e. x'=ax+b with x'(0)=min+0.1r and x'(10)=max-0.1r, r=max-min
                        // min+0.1r=b
                        // max-0.1r=10a+b=10a+min+0.1r <=> max-min-0.2r=10a <=> 0.8r=10a <=> a=0.08r
                        x = a * x + b;
                    }
                    if (i > 0 && this.x[i - 1] > x)
                        throw Error(this.label + ': x should increment continuously.');
                    this.x.push(x);
                    // Test that y in [0, 1].
                    var y = parseFloat(pla[2 * i + 1]);
                    if (y < 0)
                        y = 0;
                    else if (y > 1)
                        y = 1;
                    this.y.push(y);
                }
                this.isPlaUpdated = true;
            };
            Criterion.prototype.getScore = function (feature) {
                if (!this.isPlaUpdated)
                    throw ('Error: PLA must be updated for criterion ' + this.title + '!');
                if (this.criteria.length === 0) {
                    // End point: compute the score for each feature
                    if (feature.properties.hasOwnProperty(this.label)) {
                        // The property is available
                        var x = feature.properties[this.label];
                        if (this.maxCutoffValue <= x || x <= this.minCutoffValue)
                            return 0;
                        if (x < this.x[0])
                            return this.y[0];
                        var last = this.x.length - 1;
                        if (x > this.x[last])
                            return this.y[last];
                        //for (var k in this.x) {
                        for (var k = 0; k < this.x.length; k++) {
                            if (x < this.x[k]) {
                                // Found relative position of x in this.x
                                var x0 = this.x[k - 1];
                                var x1 = this.x[k];
                                var y0 = this.y[k - 1];
                                var y1 = this.y[k];
                                // Use linear interpolation
                                return (y1 - y0) * (x - x0) / (x1 - x0);
                            }
                        }
                    }
                    else {
                        return 0;
                    }
                }
                else {
                    // Sum all the sub-criteria.
                    var finalScore = 0;
                    this.criteria.forEach(function (crit) {
                        finalScore += crit.weight > 0
                            ? crit.weight * crit.getScore(feature)
                            : Math.abs(crit.weight) * (1 - crit.getScore(feature));
                    });
                    return this.weight > 0
                        ? this.weight * finalScore
                        : Math.abs(this.weight) * (1 - finalScore);
                }
                return 0;
            };
            return Criterion;
        })();
        Models.Criterion = Criterion;
        // NOTE: When extending a base class, make sure that the base class has been defined already.
        var Mca = (function (_super) {
            __extends(Mca, _super);
            function Mca() {
                _super.call(this);
                /** Maximum number of star ratings to use to set the weight */
                this.userWeightMax = 5;
                /** Applicable feature ids as a string[]. */
                this.featureIds = [];
                this.weight = 1;
                this.isPlaUpdated = false;
            }
            Object.defineProperty(Mca.prototype, "rankLabel", {
                get: function () {
                    return this.label + '#';
                },
                enumerable: true,
                configurable: true
            });
            Mca.prototype.deserialize = function (input) {
                this.section = input.section;
                this.stringFormat = input.stringFormat;
                this.rankTitle = input.rankTitle;
                this.rankDescription = input.rankDescription;
                this.rankFormat = input.rankFormat;
                this.userWeightMax = input.userWeightMax;
                this.featureIds = input.featureIds;
                this.minCutoffValue = input.minCutoffValue;
                this.maxCutoffValue = input.maxCutoffValue;
                this.minValue = input.minValue;
                this.maxValue = input.maxValue;
                this.scaleMinValue = input.scaleMinValue;
                this.scaleMaxValue = input.scaleMaxValue;
                _super.prototype.deserialize.call(this, input);
                return this;
            };
            /**
            * Update the MCA by calculating the weights and setting the colors.
            */
            Mca.prototype.update = function () {
                this.calculateWeights();
                this.setColors();
            };
            Mca.prototype.calculateWeights = function (criteria) {
                if (!criteria)
                    criteria = this.criteria;
                var totalWeight = 0;
                for (var k in criteria) {
                    if (!criteria.hasOwnProperty(k))
                        continue;
                    var crit = criteria[k];
                    if (crit.criteria.length > 0)
                        this.calculateWeights(crit.criteria);
                    totalWeight += Math.abs(crit.userWeight);
                }
                if (totalWeight > 0) {
                    for (var j in criteria) {
                        if (!criteria.hasOwnProperty(j))
                            continue;
                        var critj = criteria[j];
                        critj.weight = critj.userWeight / totalWeight;
                    }
                }
            };
            /** Set the colors of all criteria and sub-criteria */
            Mca.prototype.setColors = function () {
                var redColors = chroma.scale('RdYlBu').domain([0, this.criteria.length - 1], this.criteria.length);
                var totalSubcrit = 0;
                var i = 0;
                this.criteria.forEach(function (c) {
                    totalSubcrit += c.criteria.length;
                    if (!c.color)
                        c.color = redColors(i++).hex();
                });
                var blueColors = chroma.scale('PRGn').domain([0, totalSubcrit - 1], totalSubcrit);
                i = 0;
                this.criteria.forEach(function (c) {
                    c.criteria.forEach(function (crit) {
                        if (!crit.color)
                            crit.color = blueColors(i++).hex();
                    });
                });
            };
            return Mca;
        })(Criterion);
        Models.Mca = Mca;
    })(Models = Mca_1.Models || (Mca_1.Models = {}));
})(Mca || (Mca = {}));

var Mca;
(function (Mca) {
    'use strict';
    /**
     * Config
     */
    var moduleName = 'csComp';
    try {
        Mca.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Mca.myModule = angular.module(moduleName, []);
    }
    /**
     * Directive to display an MCA control.
     */
    Mca.myModule
        .directive('mca', [
        '$window', '$compile', '$templateCache',
        function ($window, $compile) {
            return {
                terminal: true,
                restrict: 'EA',
                scope: {},
                templateUrl: 'directives/MCA/Mca.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    return function (scope) {
                        fn(scope);
                    };
                },
                replace: true,
                transclude: true,
                controller: Mca.McaCtrl
            };
        }
    ]);
})(Mca || (Mca = {}));

var Mca;
(function (Mca) {
    'use strict';
    var McaCtrl = (function () {
        function McaCtrl($scope, $modal, $translate, $timeout, $localStorageService, $layerService, messageBusService) {
            var _this = this;
            this.$scope = $scope;
            this.$modal = $modal;
            this.$translate = $translate;
            this.$timeout = $timeout;
            this.$localStorageService = $localStorageService;
            this.$layerService = $layerService;
            this.messageBusService = messageBusService;
            this.features = [];
            this.availableMcas = [];
            this.showAsterChart = false; // When true, show a pie chart, when false, show a bar chart.
            this.showDialog = false;
            this.expertMode = false;
            this.showSparkline = false;
            this.featureMessageReceived = function (title, feature) {
                //console.log("MC: featureMessageReceived");
                if (_this.mca == null)
                    return;
                switch (title) {
                    case 'onFeatureSelect':
                        _this.updateSelectedFeature(feature, true);
                        break;
                    case 'onFeatureDeselect':
                        _this.showFeature = false;
                        _this.selectedFeature = null;
                        _this.drawChart();
                        break;
                    default:
                        //console.log(title);
                        break;
                }
                _this.scopeApply();
            };
            $scope.vm = this;
            messageBusService.subscribe('layer', function (title) {
                switch (title) {
                    case 'deactivate':
                    case 'activated':
                        _this.updateAvailableMcas();
                        _this.calculateMca();
                        break;
                }
            });
            messageBusService.subscribe('project', function (title) {
                switch (title) {
                    case 'loaded':
                        _this.expertMode = $layerService.project != null
                            && $layerService.project.hasOwnProperty('userPrivileges')
                            && $layerService.project.userPrivileges.hasOwnProperty('mca')
                            && $layerService.project.userPrivileges.mca.hasOwnProperty('expertMode')
                            && $layerService.project.userPrivileges.mca.expertMode;
                        if (typeof $layerService.project.mcas === 'undefined' || $layerService.project.mcas == null)
                            $layerService.project.mcas = [];
                        var mcas = _this.$localStorageService.get(McaCtrl.mcas);
                        if (typeof mcas === 'undefined' || mcas === null)
                            return;
                        mcas.forEach(function (mca) {
                            $layerService.project.mcas.push(new Mca.Models.Mca().deserialize(mca));
                        });
                        //this.createDummyMca();
                        break;
                }
            });
            messageBusService.subscribe('feature', this.featureMessageReceived);
            $translate('MCA.DELETE_MSG').then(function (translation) {
                McaCtrl.confirmationMsg1 = translation;
            });
            $translate('MCA.DELETE_MSG2').then(function (translation) {
                McaCtrl.confirmationMsg2 = translation;
            });
        }
        McaCtrl.prototype.getVotingClass = function (criterion) {
            if (criterion == null || this.mca == null || criterion.userWeight === 0 || criterion.userWeight < -this.mca.userWeightMax || criterion.userWeight > this.mca.userWeightMax)
                return 'disabledMca';
            return criterion.userWeight > 0 ? 'prefer' : 'avoid';
        };
        McaCtrl.prototype.createDummyMca = function () {
            var mca = new Mca.Models.Mca();
            mca.title = 'Mijn Zelfredzaamheid';
            mca.description = 'Analyse van de zelfredzaamheid van een gemeente.';
            mca.label = 'mca_zelfredzaamheid';
            mca.stringFormat = '{0:0.0}';
            mca.rankTitle = 'Positie';
            mca.rankDescription = 'Relatieve positie in de lijst.';
            mca.rankFormat = '{0} van {1}';
            mca.userWeightMax = 5;
            mca.featureIds = ['cities_Default'];
            var criterion = new Mca.Models.Criterion();
            criterion.label = 'p_00_14_jr';
            criterion.scores = '[0,0 20,1]';
            criterion.userWeight = 1;
            mca.criteria.push(criterion);
            criterion = new Mca.Models.Criterion();
            criterion.label = 'p_15_24_jr';
            criterion.scores = '[0,0 20,1]';
            criterion.userWeight = 1;
            mca.criteria.push(criterion);
            criterion = new Mca.Models.Criterion();
            criterion.label = 'p_65_eo_jr';
            criterion.scores = '[0,0 25,1]';
            criterion.userWeight = 3;
            mca.criteria.push(criterion);
            this.$layerService.project.mcas.push(mca);
            mca = new Mca.Models.Mca();
            mca.title = 'test';
            mca.label = 'mca_test';
            mca.stringFormat = '{0:0.0}';
            mca.rankTitle = 'Rang';
            mca.rankFormat = '{0} van {1}';
            mca.userWeightMax = 3;
            mca.featureIds = ['cities_Default'];
            criterion = new Mca.Models.Criterion();
            criterion.label = 'p_15_24_jr';
            criterion.scores = '[0,0 20,1]';
            criterion.userWeight = 1;
            mca.criteria.push(criterion);
            criterion = new Mca.Models.Criterion();
            criterion.label = 'p_65_eo_jr';
            criterion.scores = '[0,0 25,1]';
            criterion.userWeight = 3;
            mca.criteria.push(criterion);
            this.$layerService.project.mcas.push(mca);
        };
        McaCtrl.prototype.toggleMcaChartType = function () {
            this.showAsterChart = !this.showAsterChart;
            this.drawChart(this.mca.criteria[0]);
        };
        McaCtrl.prototype.toggleSparkline = function () {
            this.showSparkline = !this.showSparkline;
            if (this.showSparkline)
                this.drawChart();
        };
        McaCtrl.prototype.weightUpdated = function (criterion) {
            this.selectedCriterion = criterion;
            this.addMca(this.mca);
            this.updateMca(criterion);
        };
        McaCtrl.prototype.updateMca = function (criterion) {
            this.selectedCriterion = criterion;
            this.features = [];
            this.calculateMca();
            this.drawChart(criterion);
        };
        McaCtrl.prototype.editMca = function (mca) {
            this.showMcaEditor(mca);
        };
        McaCtrl.prototype.createMca = function () {
            this.showMcaEditor(new Mca.Models.Mca());
        };
        McaCtrl.prototype.showMcaEditor = function (newMca) {
            var _this = this;
            var modalInstance = this.$modal.open({
                templateUrl: 'directives/MCA/McaEditorView.tpl.html',
                controller: Mca.McaEditorCtrl,
                resolve: {
                    mca: function () { return newMca; }
                }
            });
            modalInstance.result.then(function (mca) {
                _this.showSparkline = false;
                _this.addMca(mca);
                _this.updateMca();
                //console.log(JSON.stringify(mca, null, 2));
            }, function () {
                //console.log('Modal dismissed at: ' + new Date());
            });
        };
        McaCtrl.prototype.removeMca = function (mca) {
            var _this = this;
            if (!mca)
                return;
            var title = String.format(McaCtrl.confirmationMsg1, mca.title);
            this.messageBusService.confirm(title, McaCtrl.confirmationMsg2, function (result) {
                if (!result)
                    return;
                _this.$timeout(function () {
                    _this.deleteMca(mca);
                    if (_this.mca)
                        _this.updateMca();
                }, 0);
            });
            this.scopeApply();
        };
        McaCtrl.prototype.getMcaIndex = function (mca) {
            var mcaIndex = -1;
            var mcas = this.$layerService.project.mcas;
            for (var i = 0; i < mcas.length; i++) {
                if (mcas[i].title !== mca.title)
                    continue;
                mcaIndex = i;
                break;
            }
            return mcaIndex;
        };
        McaCtrl.prototype.addMca = function (mca) {
            if (!mca)
                return;
            this.deleteMca(mca);
            this.$layerService.project.mcas.push(mca);
            this.addMcaToLocalStorage(mca);
            this.updateAvailableMcas(mca);
        };
        McaCtrl.prototype.deleteMca = function (mca) {
            if (!mca)
                return;
            var mcaIndex = this.getMcaIndex(mca);
            if (mcaIndex < 0)
                return;
            var mcas = this.$layerService.project.mcas;
            if (mcaIndex >= 0)
                mcas.splice(mcaIndex, 1);
            this.removeMcaFromLocalStorage(mca);
            this.updateAvailableMcas();
        };
        McaCtrl.prototype.addMcaToLocalStorage = function (mca) {
            var mcas = this.$localStorageService.get(McaCtrl.mcas);
            if (typeof mcas === 'undefined' || mcas === null)
                mcas = [];
            this.removeMcaFromLocalStorage(mca);
            mcas.push(mca);
            this.$localStorageService.set(McaCtrl.mcas, mcas); // You first need to set the key
        };
        McaCtrl.prototype.removeMcaFromLocalStorage = function (mca) {
            var mcas = this.$localStorageService.get(McaCtrl.mcas);
            if (typeof mcas === 'undefined' || mcas === null)
                return;
            var mcaIndex = -1;
            for (var i = 0; i < mcas.length; i++) {
                if (mcas[i].title !== mca.title)
                    continue;
                mcaIndex = i;
                break;
            }
            if (mcaIndex < 0)
                return;
            mcas.splice(mcaIndex, 1);
            this.$localStorageService.set(McaCtrl.mcas, mcas); // You first need to set the key
        };
        McaCtrl.prototype.scopeApply = function () {
            if (this.$scope.$root.$$phase !== '$apply' && this.$scope.$root.$$phase !== '$digest') {
                this.$scope.$apply();
            }
        };
        McaCtrl.prototype.updateSelectedFeature = function (feature, drawCharts) {
            if (drawCharts === void 0) { drawCharts = false; }
            if (typeof feature === 'undefined' || feature == null) {
                this.featureIcon = '';
                return;
            }
            this.selectedFeature = feature;
            this.featureIcon = this.selectedFeature.fType != null && this.selectedFeature.fType.style != null
                ? this.selectedFeature.fType.style.iconUri
                : '';
            if (!feature.properties.hasOwnProperty(this.mca.label))
                return;
            this.showFeature = true;
            this.properties = [];
            var mi = McaCtrl.createPropertyType(this.mca);
            var displayValue = csComp.Helpers.convertPropertyInfo(mi, feature.properties[mi.label]);
            this.properties.push(new FeatureProps.CallOutProperty(mi.title, displayValue, mi.label, true, true, feature, false, false, mi.description, mi));
            if (this.mca.rankTitle) {
                mi = McaCtrl.createRankPropertyType(this.mca);
                displayValue = csComp.Helpers.convertPropertyInfo(mi, feature.properties[mi.label]);
                this.properties.push(new FeatureProps.CallOutProperty(mi.title, displayValue, mi.label, false, false, feature, false, false, mi.description, mi));
            }
            if (drawCharts)
                this.drawChart();
        };
        McaCtrl.prototype.drawChart = function (criterion) {
            var _this = this;
            this.selectedCriterion = criterion;
            this.showChart = true;
            if (this.showFeature)
                if (this.showAsterChart)
                    this.drawAsterPlot(criterion);
                else
                    this.drawHistogram(criterion);
            else
                this.drawPieChart(criterion);
            if (!this.showSparkline)
                return;
            var i = 0;
            this.mca.criteria.forEach(function (crit) {
                var id = 'histogram_' + i++;
                if (crit.criteria.length === 0) {
                    var y1 = crit.y;
                    if (crit.userWeight < 0)
                        y1 = y1.map(function (v) { return 1 - v; });
                    csComp.Helpers.Plot.drawMcaPlot(crit.propValues, {
                        id: id,
                        width: 220,
                        height: 70,
                        xy: { x: crit.x, y: y1 },
                        featureValue: _this.selectedFeature ? _this.selectedFeature.properties[crit.label] : null
                    });
                }
                else {
                    var j = 0;
                    crit.criteria.forEach(function (c) {
                        var y2 = c.y;
                        if (crit.userWeight < 0)
                            y2 = y2.map(function (v) { return 1 - v; });
                        csComp.Helpers.Plot.drawMcaPlot(c.propValues, {
                            id: id + '_' + j++,
                            width: 220,
                            height: 70,
                            xy: { x: c.x, y: y2 },
                            featureValue: _this.selectedFeature ? _this.selectedFeature.properties[c.label] : null
                        });
                    });
                }
            });
        };
        McaCtrl.prototype.getParentOfSelectedCriterion = function (criterion) {
            var _this = this;
            var parent;
            this.mca.update();
            if (typeof criterion === 'undefined' || this.mca.criteria.indexOf(criterion) >= 0) {
                this.selectedCriterion = null;
                parent = this.mca.criteria;
            }
            else {
                this.mca.criteria.forEach(function (c) {
                    if (c.criteria.indexOf(criterion) >= 0) {
                        _this.selectedCriterion = c;
                        parent = c.criteria;
                    }
                });
            }
            return parent;
        };
        McaCtrl.prototype.drawHistogram = function (criterion) {
            var _this = this;
            if (!this.mca || !this.selectedFeature)
                return;
            var currentLevel = this.getParentOfSelectedCriterion(criterion);
            if (typeof currentLevel === 'undefined' || currentLevel == null)
                return;
            var data = [];
            var options = {
                id: McaCtrl.mcaChartId,
                numberOfBins: 10,
                width: 240,
                height: 100,
                selectedValue: this.selectedFeature.properties[this.mca.label]
            };
            this.features.forEach(function (feature) {
                if (feature.properties.hasOwnProperty(_this.mca.label)) {
                    // The property is available. I use the '+' to convert the string value to a number.
                    var prop = feature.properties[_this.mca.label];
                    if ($.isNumeric(prop))
                        data.push(prop);
                }
            });
            csComp.Helpers.Plot.drawHistogram(data, options);
        };
        McaCtrl.prototype.drawAsterPlot = function (criterion) {
            var _this = this;
            if (!this.mca || !this.selectedFeature)
                return;
            var currentLevel = this.getParentOfSelectedCriterion(criterion);
            if (typeof currentLevel === 'undefined' || currentLevel == null)
                return;
            var data = [];
            var i = 0;
            currentLevel.forEach(function (c) {
                var rawScore = c.getScore(_this.selectedFeature);
                var pieData = new csComp.Helpers.AsterPieData();
                pieData.id = i++;
                pieData.label = c.getTitle();
                pieData.weight = Math.abs(c.weight);
                pieData.color = c.color;
                pieData.score = (c.weight > 0 ? rawScore : 1 - rawScore) * 100;
                data.push(pieData);
            });
            csComp.Helpers.Plot.drawAsterPlot(100, data, McaCtrl.mcaChartId);
        };
        McaCtrl.prototype.drawPieChart = function (criterion) {
            if (!this.mca)
                return;
            var currentLevel = this.getParentOfSelectedCriterion(criterion);
            if (typeof currentLevel === 'undefined' || currentLevel == null)
                return;
            var data = [];
            var i = 0;
            currentLevel.forEach(function (c) {
                var pieData = new csComp.Helpers.PieData();
                pieData.id = i++;
                pieData.label = c.getTitle();
                pieData.weight = Math.abs(c.weight);
                pieData.color = c.color;
                data.push(pieData);
            });
            csComp.Helpers.Plot.drawPie(100, data, McaCtrl.mcaChartId);
        };
        /**
        * Based on the currently loaded features, which MCA can we use
        */
        McaCtrl.prototype.updateAvailableMcas = function (mca) {
            var _this = this;
            this.showChart = false;
            this.mca = mca;
            this.availableMcas = [];
            this.$layerService.project.mcas.forEach(function (m) {
                m.featureIds.forEach(function (featureId) {
                    if (_this.availableMcas.indexOf(m) < 0 && _this.$layerService._featureTypes.hasOwnProperty(featureId)) {
                        _this.availableMcas.push(m);
                        var featureType = _this.$layerService._featureTypes[featureId];
                        _this.applyPropertyInfoToCriteria(m, featureType);
                    }
                });
            });
            if (mca == null && this.availableMcas.length > 0) {
                this.mca = this.availableMcas[0];
                this.updateMca();
            }
        };
        McaCtrl.prototype.calculateMca = function () {
            var _this = this;
            if (!this.mca)
                return;
            var mca = this.mca;
            mca.featureIds.forEach(function (featureId) {
                if (!(_this.$layerService._featureTypes.hasOwnProperty(featureId)))
                    return;
                _this.addPropertyInfo(featureId, mca);
                _this.$layerService.project.features.forEach(function (feature) {
                    if (feature.featureTypeName != null && feature.featureTypeName === featureId)
                        _this.features.push(feature);
                });
                if (_this.features.length === 0)
                    return;
                mca.updatePla(_this.features);
                mca.update();
                var tempScores = [];
                var index = 0;
                _this.features.forEach(function (feature) {
                    var score = mca.getScore(feature);
                    if (mca.rankTitle) {
                        var tempItem = { score: score, index: index++ };
                        tempScores.push(tempItem);
                    }
                    feature.properties[mca.label] = score * 100;
                    _this.$layerService.calculateFeatureStyle(feature);
                    _this.$layerService.activeMapRenderer.updateFeature(feature);
                    //this.$layerService.updateFeature(feature);
                });
                if (mca.rankTitle) {
                    // Add rank information
                    tempScores.sort(function (a, b) { return b.score - a.score; });
                    var length = _this.features.length;
                    var scaleRange = mca.scaleMinValue ? Math.abs(mca.scaleMaxValue - mca.scaleMinValue) + 1 : length;
                    var scaleFactor = Math.ceil(length / scaleRange);
                    var rankFunction = mca.scaleMinValue
                        ? mca.scaleMaxValue > mca.scaleMinValue
                            ? function (position) { return mca.scaleMaxValue - Math.round(position / scaleFactor); }
                            : function (position) { return mca.scaleMinValue + Math.round(position / scaleFactor); }
                        : function (position) { return position; };
                    var prevScore = -1;
                    var rank = 1;
                    for (var i = 0; i < length; i++) {
                        var item = tempScores[i];
                        // Assign items with the same value the same rank.
                        if (item.score !== prevScore)
                            rank = i + 1;
                        prevScore = item.score;
                        _this.features[item.index].properties[mca.label + '#'] = rankFunction(rank) + ',' + scaleRange;
                    }
                }
            });
            this.updateSelectedFeature(this.selectedFeature, false);
            if (this.selectedFeature) {
                this.messageBusService.publish('feature', 'onFeatureSelect', this.selectedFeature);
            }
            if (this.groupStyle)
                this.$layerService.updateStyle(this.groupStyle);
        };
        McaCtrl.prototype.applyPropertyInfoToCriteria = function (mca, featureType) {
            var propertyTypes = csComp.Helpers.getPropertyTypes(featureType, this.$layerService.propertyTypeData);
            if (propertyTypes.length === 0)
                return;
            mca.criteria.forEach(function (criterion) {
                var label = criterion.label;
                propertyTypes.forEach(function (propInfo) {
                    if (propInfo.label === label) {
                        criterion.title = propInfo.title;
                        criterion.description = propInfo.description;
                    }
                });
            });
        };
        McaCtrl.prototype.addPropertyInfo = function (featureId, mca, forceUpdate) {
            if (forceUpdate === void 0) { forceUpdate = false; }
            var featureType = this.$layerService._featureTypes[featureId];
            //var propertyTypes = featureType.propertyTypeData;
            var propertyTypes = csComp.Helpers.getPropertyTypes(featureType, this.$layerService.propertyTypeData);
            var labelIndex = -1;
            for (var i = propertyTypes.length - 1; i >= 0; i--) {
                if (propertyTypes[i].label === mca.label) {
                    labelIndex = i;
                    break;
                }
            }
            if (forceUpdate || labelIndex < 0) {
                var pt = McaCtrl.createPropertyType(mca);
                if (labelIndex < 0) {
                    if (!featureType.propertyTypeData)
                        featureType.propertyTypeData = [];
                    featureType.propertyTypeData.push(pt); // NOTE: propertyTypes refers to a new list, so you cannot add to it.
                }
                else
                    propertyTypes[labelIndex] = pt; // NOTE: but you should be able to overwrite an existing property.
            }
            if (!mca.rankTitle)
                return;
            labelIndex = -1;
            for (i = propertyTypes.length - 1; i >= 0; i--) {
                if (propertyTypes[i].label === mca.rankLabel) {
                    labelIndex = i;
                    break;
                }
            }
            if (forceUpdate || labelIndex < 0) {
                pt = McaCtrl.createRankPropertyType(mca);
                if (labelIndex < 0)
                    featureType.propertyTypeData.push(pt);
                else
                    propertyTypes[labelIndex] = pt;
            }
        };
        McaCtrl.prototype.setStyle = function (item) {
            // If groupStyle has been set, we have called it before.
            // However, make sure that not another filter has set the fillColor too, overwriting our label.
            if (this.groupStyle
                && this.groupStyle.group != null
                && this.groupStyle.group.styles != null
                && this.groupStyle.group.styles.filter(function (s) { return s.visualAspect === 'fillColor'; })[0].property === this.mca.label)
                this.$layerService.updateStyle(this.groupStyle);
            else {
                this.groupStyle = this.$layerService.setStyle(item, false);
                this.groupStyle.colors = ['#F04030', '#3040F0'];
                this.$layerService.updateStyle(this.groupStyle);
            }
        };
        McaCtrl.createPropertyType = function (mca) {
            var mi = {
                title: mca.title,
                label: mca.label,
                type: 'number',
                maxValue: 1,
                minValue: 0,
                description: mca.description,
                stringFormat: mca.stringFormat,
                visibleInCallOut: true,
                section: mca.section || 'MCA'
            };
            return mi;
        };
        McaCtrl.createRankPropertyType = function (mca) {
            var mi = {
                title: mca.rankTitle,
                label: mca.rankLabel,
                type: 'rank',
                description: mca.rankDescription,
                stringFormat: mca.rankFormat,
                visibleInCallOut: true,
                section: mca.section || 'MCA'
            };
            return mi;
        };
        McaCtrl.mcaChartId = 'mcaChart';
        McaCtrl.mcas = 'MCAs';
        McaCtrl.$inject = [
            '$scope',
            '$modal',
            '$translate',
            '$timeout',
            'localStorageService',
            'layerService',
            'messageBusService'
        ];
        return McaCtrl;
    })();
    Mca.McaCtrl = McaCtrl;
})(Mca || (Mca = {}));

var Mca;
(function (Mca) {
    'use strict';
    var McaEditorCtrl = (function () {
        function McaEditorCtrl($scope, $modalInstance, $layerService, $translate, messageBusService, mca) {
            var _this = this;
            this.$scope = $scope;
            this.$modalInstance = $modalInstance;
            this.$layerService = $layerService;
            this.$translate = $translate;
            this.messageBusService = messageBusService;
            this.mca = mca;
            this.propInfos = [];
            this.headers = [];
            this.scoringFunctions = [];
            $scope.vm = this;
            this.scoringFunctions.push(new Mca.Models.ScoringFunction(Mca.Models.ScoringFunctionType.Ascending));
            //this.scoringFunctions.push(new Models.ScoringFunction(Models.ScoringFunctionType.Descending));
            this.scoringFunctions.push(new Mca.Models.ScoringFunction(Mca.Models.ScoringFunctionType.AscendingSigmoid));
            //this.scoringFunctions.push(new Models.ScoringFunction(Models.ScoringFunctionType.DescendingSigmoid));
            this.scoringFunctions.push(new Mca.Models.ScoringFunction(Mca.Models.ScoringFunctionType.GaussianPeak));
            //this.scoringFunctions.push(new Models.ScoringFunction(Models.ScoringFunctionType.GaussianValley));
            //this.scoringFunctions.push(new Models.ScoringFunction(Models.ScoringFunctionType.Manual));
            $translate('MCA.LINEAR').then(function (translation) {
                _this.scoringFunctions[0].title = translation;
            });
            $translate('MCA.SIGMOID').then(function (translation) {
                _this.scoringFunctions[1].title = translation;
            });
            $translate('MCA.GAUSSIAN').then(function (translation) {
                _this.scoringFunctions[2].title = translation;
            });
            this.dataset = csComp.Helpers.loadMapLayers(this.$layerService);
            messageBusService.subscribe('layer', function () {
                _this.dataset = csComp.Helpers.loadMapLayers(_this.$layerService);
            });
            this.mcaTitle = mca.title;
            this.rankTitle = mca.rankTitle;
            this.scaleMin = mca.scaleMinValue;
            this.scaleMax = mca.scaleMaxValue;
            this.selectedFeatureType = mca.featureIds.length === 0 ? '' : this.dataset.featureTypes[mca.featureIds[0]];
            if (this.selectedFeatureType) {
                this.updatePropertyInfo(this.selectedFeatureType);
                this.updatePropertyInfoUponEdit(mca);
            }
            else {
                this.selectFirstFeatureType();
            }
        }
        McaEditorCtrl.prototype.updatePropertyInfoUponEdit = function (criterion, category) {
            var _this = this;
            criterion.criteria.forEach(function (c) {
                if (c.label) {
                    var propInfos = _this.propInfos;
                    for (var i in propInfos) {
                        if (!propInfos.hasOwnProperty(i))
                            continue;
                        var mi = propInfos[i];
                        if (mi.label !== c.label)
                            continue;
                        mi.isSelected = true;
                        mi.minCutoffValue = c.minCutoffValue;
                        mi.maxCutoffValue = c.maxCutoffValue;
                        mi.minValue = c.minValue;
                        mi.maxValue = c.maxValue;
                        mi.userWeight = c.userWeight;
                        if (category) {
                            mi.category = category;
                        }
                        break;
                    }
                }
                else {
                    _this.updatePropertyInfoUponEdit(c, c.title);
                }
            });
        };
        McaEditorCtrl.prototype.loadPropertyTypes = function () {
            this.updatePropertyInfo(this.selectedFeatureType);
        };
        ///** 
        // * Load the features as visible on the map.
        // */
        //private loadMapLayers(): void {
        //    var data         : IGeoJsonFile = {
        //        type         : '',
        //        features     : [],
        //        featureTypes : {}
        //    };
        //    // If we are filtering, load the filter results
        //    this.$layerService.project.groups.forEach((group) => {
        //        if (group.filterResult != null)
        //            group.filterResult.forEach((f) => data.features.push(f));
        //    });
        //    // Otherwise, take all loaded features
        //    if (data.features.length === 0)
        //        data.features = this.$layerService.project.features;
        //    data.features.forEach((f: IFeature) => {
        //        if (!(data.featureTypes.hasOwnProperty(f.featureTypeName))) {
        //            var featureType = data.featureTypes[f.featureTypeName];
        //            if (!featureType.name) featureType.name = f.featureTypeName.replace('_Default', '');
        //            data.featureTypes[f.featureTypeName] = featureType;
        //        }
        //    });
        //    this.dataset = data;
        //}
        McaEditorCtrl.prototype.selectFirstFeatureType = function () {
            var featureTypes = this.dataset.featureTypes;
            for (var key in featureTypes) {
                if (!featureTypes.hasOwnProperty(key))
                    continue;
                this.selectedFeatureType = featureTypes[key];
                this.updatePropertyInfo(this.selectedFeatureType);
                return;
            }
        };
        McaEditorCtrl.prototype.updatePropertyInfo = function (featureType) {
            var _this = this;
            this.propInfos = [];
            this.headers = [];
            var titles = [];
            var pis = [];
            // Push the Name, so it always appears on top.
            pis.push({
                label: 'Name',
                visibleInCallOut: true,
                title: 'Naam',
                type: 'text',
                filterType: 'text',
                isSelected: false,
                scoringFunctionType: this.scoringFunctions[0].type
            });
            if (featureType.propertyTypeKeys != null) {
                var keys = featureType.propertyTypeKeys.split(';');
                keys.forEach(function (k) {
                    if (_this.$layerService.propertyTypeData.hasOwnProperty(k))
                        pis.push(_this.$layerService.propertyTypeData[k]);
                    else if (featureType.propertyTypeData != null) {
                        var result = $.grep(featureType.propertyTypeData, function (e) { return e.label === k; });
                        if (result.length >= 1)
                            pis.push(result);
                    }
                });
            }
            else if (featureType.propertyTypeData != null) {
                featureType.propertyTypeData.forEach(function (mi) { return pis.push(mi); });
            }
            pis.forEach(function (pi) {
                // TODO Later, we could also include categories and not only numbers, where each category represents a certain value.
                if (pi.visibleInCallOut && pi.type === 'number' && pi.label.indexOf('mca_') < 0 && titles.indexOf(pi.title) < 0) {
                    titles.push(pi.title);
                    // Clone object inline. See http://stackoverflow.com/a/122704/319711
                    _this.propInfos.push({
                        title: pi.title,
                        label: pi.label,
                        stringFormat: pi.stringFormat,
                        isSelected: false,
                        maxValue: pi.maxValue,
                        minValue: pi.minValue,
                        defaultValue: pi.defaultValue,
                        description: pi.description
                    });
                }
            });
        };
        McaEditorCtrl.prototype.toggleSelection = function (metaInfoTitle) {
            var idx = this.headers.indexOf(metaInfoTitle);
            // is currently selected
            if (idx > -1) {
                this.headers.splice(idx, 1);
            }
            else {
                this.headers.push(metaInfoTitle);
            }
        };
        McaEditorCtrl.prototype.isDisabled = function () {
            if (typeof this.mcaTitle === 'undefined' || this.mcaTitle.length === 0)
                return true;
            if (this.propInfos.length === 0 || !this.propInfos.reduce(function (p, c) { return p || c.isSelected; }))
                return true;
            return false;
        };
        /**
         * Create a new MCA criterion
         */
        McaEditorCtrl.prototype.save = function () {
            var mca = new Mca.Models.Mca();
            mca.title = this.mcaTitle || 'New MCA criterion';
            mca.label = 'mca_' + mca.title.replace(' ', '_');
            mca.stringFormat = '{0:0.0}';
            if (this.rankTitle) {
                mca.rankTitle = this.rankTitle || 'Rank';
                mca.rankFormat = '{0} / {1}';
            }
            if (this.scaleMin && this.scaleMax) {
                mca.scaleMinValue = this.scaleMin;
                mca.scaleMaxValue = this.scaleMax;
            }
            mca.userWeightMax = 5;
            var featureTypes = this.dataset.featureTypes;
            for (var key in featureTypes) {
                if (!featureTypes.hasOwnProperty(key))
                    continue;
                if (featureTypes[key] === this.selectedFeatureType)
                    mca.featureIds = [key];
            }
            this.propInfos.forEach(function (mi) {
                if (!mi.isSelected)
                    return;
                var criterion = new Mca.Models.Criterion();
                criterion.label = mi.label;
                criterion.title = mi.title;
                criterion.isPlaScaled = true;
                criterion.description = mi.description;
                criterion.userWeight = mi.userWeight || 1;
                criterion.minCutoffValue = mi.minCutoffValue ? +mi.minCutoffValue : undefined;
                criterion.maxCutoffValue = mi.maxCutoffValue ? +mi.maxCutoffValue : undefined;
                criterion.minValue = mi.minValue ? +mi.minValue : undefined;
                criterion.maxValue = mi.maxValue ? +mi.maxValue : undefined;
                if (mi.scoringFunctionType === Mca.Models.ScoringFunctionType.Manual) {
                    criterion.scores = mi.scores;
                }
                else {
                    criterion.scores = Mca.Models.ScoringFunction.createScores(mi.scoringFunctionType);
                }
                if (mi.category) {
                    var parent;
                    for (var i in mca.criteria) {
                        if (!mca.criteria.hasOwnProperty(i))
                            continue;
                        var c = mca.criteria[i];
                        if (c.title !== mi.category)
                            continue;
                        parent = c;
                        break;
                    }
                    if (parent == null) {
                        parent = new Mca.Models.Criterion;
                        parent.title = mi.category;
                        parent.isPlaUpdated = false;
                        mca.criteria.push(parent);
                    }
                    parent.criteria.push(criterion);
                }
                else {
                    mca.criteria.push(criterion);
                }
            });
            this.$modalInstance.close(mca);
        };
        McaEditorCtrl.prototype.cancel = function () {
            this.mcaTitle = '';
            this.rankTitle = '';
            this.headers = [];
            this.$modalInstance.dismiss('cancel');
        };
        McaEditorCtrl.prototype.toggleItemDetails = function (index) {
            this.showItem = this.showItem == index ? -1 : index;
        };
        McaEditorCtrl.$inject = [
            '$scope',
            '$modalInstance',
            'layerService',
            '$translate',
            'messageBusService',
            'mca'
        ];
        return McaEditorCtrl;
    })();
    Mca.McaEditorCtrl = McaEditorCtrl;
})(Mca || (Mca = {}));

var Navigate;
(function (Navigate) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Navigate.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Navigate.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    Navigate.myModule.directive('navigate', [
        '$window', '$compile',
        function ($window, $compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Navigate/Navigate.tpl.html',
                link: function (scope, element, attrs) {
                    // Deal with resizing the element list
                    scope.onResizeFunction = function () {
                        var filterHeight = 50;
                        var paginationCtrlHeight = 100;
                        var itemHeight = 60;
                        //scope.windowHeight          = $window.innerHeight;
                        //scope.windowWidth           = $window.innerWidth;
                        scope.numberOfItems = Math.floor(($window.innerHeight - filterHeight - paginationCtrlHeight) / itemHeight);
                    };
                    // Call to the function when the page is first loaded
                    scope.onResizeFunction();
                    angular.element($window).bind('resize', function () {
                        scope.onResizeFunction();
                        scope.$apply();
                    });
                },
                replace: false,
                transclude: false,
                controller: Navigate.NavigateCtrl
            };
        }
    ]).directive('bsPopover', function () {
        return function (scope, element, attrs) {
            element.find("a[rel=popover]").popover({ placement: 'right', html: 'true' });
        };
    });
})(Navigate || (Navigate = {}));

var Navigate;
(function (Navigate) {
    var RecentFeature = (function () {
        function RecentFeature() {
        }
        return RecentFeature;
    })();
    Navigate.RecentFeature = RecentFeature;
    var NavigateCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function NavigateCtrl($scope, $layerService, $messageBus, localStorageService) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.localStorageService = localStorageService;
            this.RecentLayers = [];
            this.RecentFeatures = [];
            $scope.vm = this;
            this.$messageBus.subscribe('project', function (a, p) {
                if (a === 'loaded') {
                    _this.initRecentLayers();
                    _this.initRecentFeatures();
                }
            });
        }
        NavigateCtrl.prototype.updateRecentFeaturesList = function () {
            var _this = this;
            setTimeout(function () {
                var ids = _this.localStorageService.get("recentfeatures");
                if (ids) {
                    _this.RecentFeatures = ids;
                    _this.RecentFeatures.forEach(function (rf) {
                        var l = _this.$layerService.findLayer(rf.layerId);
                        if (l && l.enabled) {
                            rf.feature = _this.$layerService.findFeature(l, rf.id);
                        }
                    });
                }
            }, 0);
        };
        NavigateCtrl.prototype.selectFeature = function (feature) {
            this.$layerService.selectFeature(feature, false, true);
        };
        NavigateCtrl.prototype.initRecentFeatures = function () {
            var _this = this;
            this.updateRecentFeaturesList();
            this.$messageBus.subscribe('feature', function (a, feature) {
                if (a === 'onFeatureSelect') {
                    _this.RecentFeatures = _this.RecentFeatures.filter(function (f) { return f.id != feature.id; });
                    var rf = { id: feature.id, name: csComp.Helpers.getFeatureTitle(feature), layerId: feature.layerId, feature: feature };
                    _this.RecentFeatures.splice(0, 0, rf);
                    if (_this.RecentFeatures.length > 5)
                        _this.RecentFeatures.pop();
                    var save = [];
                    _this.RecentFeatures.forEach(function (f) { return save.push({ id: f.id, name: f.name, layerId: f.layerId }); });
                    _this.localStorageService.set("recentfeatures", save);
                    if (_this.$scope.$root.$$phase != '$apply' && _this.$scope.$root.$$phase != '$digest') {
                        _this.$scope.$apply();
                    }
                }
            });
        };
        NavigateCtrl.prototype.toggleLayer = function (layer) {
            this.$layerService.toggleLayer(layer);
        };
        NavigateCtrl.prototype.initRecentLayers = function () {
            var _this = this;
            var ids = this.localStorageService.get("recentlayers");
            if (ids)
                ids.forEach(function (id) {
                    var l = _this.$layerService.findLayer(id);
                    if (l)
                        _this.RecentLayers.push(l);
                });
            this.$messageBus.subscribe('layer', function (a, layer) {
                if (a === 'activated') {
                    _this.RecentLayers = _this.RecentLayers.filter(function (f) { return f.id != layer.id; });
                    _this.RecentLayers.splice(0, 0, layer);
                    if (_this.RecentLayers.length > 5)
                        _this.RecentLayers.pop();
                    ids = [];
                    _this.RecentLayers.forEach(function (l) { return ids.push(l.id); });
                    _this.localStorageService.set("recentlayers", ids);
                    if (_this.$scope.$root.$$phase != '$apply' && _this.$scope.$root.$$phase != '$digest') {
                        _this.$scope.$apply();
                    }
                }
                _this.updateRecentFeaturesList();
            });
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        NavigateCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService', 'localStorageService'
        ];
        return NavigateCtrl;
    })();
    Navigate.NavigateCtrl = NavigateCtrl;
})(Navigate || (Navigate = {}));

var Search;
(function (Search) {
    var NavigateSteps = (function () {
        function NavigateSteps() {
        }
        return NavigateSteps;
    })();
    Search.NavigateSteps = NavigateSteps;
    var NavigateState = (function () {
        function NavigateState() {
        }
        return NavigateState;
    })();
    Search.NavigateState = NavigateState;
})(Search || (Search = {}));

var OfflineSearch;
(function (OfflineSearch) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        OfflineSearch.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        OfflineSearch.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    OfflineSearch.myModule.directive('offlineSearch', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/OfflineSearch/OfflineSearch.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    return function (scope) {
                        fn(scope);
                    };
                },
                replace: true,
                transclude: true,
                controller: OfflineSearch.OfflineSearchCtrl
            };
        }
    ]);
})(OfflineSearch || (OfflineSearch = {}));

var OfflineSearch;
(function (OfflineSearch) {
    var Layer = (function () {
        function Layer(groupTitle, index, id, title, path, type) {
            this.groupTitle = groupTitle;
            this.index = index;
            this.id = id;
            this.title = title;
            this.path = path;
            this.type = type;
            /**
             * Names of all the features.
             * @type {string[]}
             */
            this.featureNames = [];
        }
        return Layer;
    })();
    OfflineSearch.Layer = Layer;
    /**
     * An index entry that contains a search result.
     */
    var Entry = (function () {
        function Entry(layerIndexOrArray, featureIndex, propertyIndex) {
            this.v = Array(2);
            if (typeof layerIndexOrArray === 'number') {
                this.v[0] = layerIndexOrArray;
                this.v[1] = featureIndex;
            }
            else {
                this.v = layerIndexOrArray;
            }
        }
        Object.defineProperty(Entry.prototype, "layerIndex", {
            get: function () { return this.v[0]; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Entry.prototype, "featureIndex", {
            get: function () { return this.v[1]; },
            enumerable: true,
            configurable: true
        });
        /**
         * This function is called when serializing the Entry object to JSON, which is
         * much less verbose than the default JSON. In the constructor, I've used a
         * Union type to deserialize it again.
         */
        Entry.prototype.toJSON = function () {
            return this.v;
        };
        return Entry;
    })();
    OfflineSearch.Entry = Entry;
    var KeywordIndex = (function () {
        function KeywordIndex() {
        }
        return KeywordIndex;
    })();
    OfflineSearch.KeywordIndex = KeywordIndex;
    var OfflineSearchResult = (function () {
        function OfflineSearchResult(project, options) {
            this.project = project;
            this.options = options;
            this.layers = [];
            this.keywordIndex = {};
        }
        return OfflineSearchResult;
    })();
    OfflineSearch.OfflineSearchResult = OfflineSearchResult;
})(OfflineSearch || (OfflineSearch = {}));

var OfflineSearch;
(function (OfflineSearch) {
    var OfflineSearchResultViewModel = (function () {
        function OfflineSearchResultViewModel(title, layerTitle, groupTitle, entry) {
            this.title = title;
            this.layerTitle = layerTitle;
            this.groupTitle = groupTitle;
            this.entry = entry;
            this.firstInGroup = false;
        }
        OfflineSearchResultViewModel.prototype.toString = function () {
            return this.title;
        };
        Object.defineProperty(OfflineSearchResultViewModel.prototype, "fullTitle", {
            get: function () {
                return this.groupTitle + ' >> ' + this.layerTitle + ' >> ' + this.title;
            },
            enumerable: true,
            configurable: true
        });
        return OfflineSearchResultViewModel;
    })();
    OfflineSearch.OfflineSearchResultViewModel = OfflineSearchResultViewModel;
    var OfflineSearchCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function OfflineSearchCtrl($scope, $http, $layerService, $mapService, $messageBus) {
            var _this = this;
            this.$scope = $scope;
            this.$http = $http;
            this.$layerService = $layerService;
            this.$mapService = $mapService;
            this.$messageBus = $messageBus;
            this.isReady = false;
            $scope.vm = this;
            $messageBus.subscribe('project', function (title) {
                switch (title) {
                    case 'loaded':
                        var offlineSearchResultUrl = $layerService.projectUrl.url.replace('project.json', 'offline_search_result.json');
                        _this.loadSearchResults(offlineSearchResultUrl);
                        break;
                }
            });
            $messageBus.subscribe('language', function (title, language) {
                switch (title) {
                    case 'newLanguage':
                        // TODO switch language!
                        break;
                }
            });
        }
        /**
         * Load the offline search results (json file).
         */
        OfflineSearchCtrl.prototype.loadSearchResults = function (url) {
            var _this = this;
            this.$http.get(url)
                .success(function (offlineSearchResult) {
                _this.offlineSearchResult = offlineSearchResult;
                var kwi = offlineSearchResult.keywordIndex;
                var keywordIndex = {};
                for (var key in kwi) {
                    if (!kwi.hasOwnProperty(key))
                        continue;
                    kwi[key].forEach(function (entry) {
                        if (!keywordIndex.hasOwnProperty(key))
                            keywordIndex[key] = [];
                        keywordIndex[key].push(new OfflineSearch.Entry(entry));
                    });
                }
                _this.offlineSearchResult.keywordIndex = keywordIndex;
                _this.isReady = true;
            })
                .error(function () { console.log("OfflineSearch: error with $http "); });
        };
        /**
         * Get the locations based on the entered text.
         */
        OfflineSearchCtrl.prototype.getLocation = function (text, resultCount) {
            if (resultCount === void 0) { resultCount = 15; }
            if (!this.isReady || text === null || text.length < 3)
                return [];
            var searchWords = text.toLowerCase().split(' ');
            // test if last word in text might be a (part of) a stopword, if so remove it
            var lastSearchTerm = searchWords[searchWords.length - 1];
            var possibleStopWords = this.offlineSearchResult.options.stopWords.filter(function (stopword) { return stopword.indexOf(lastSearchTerm) > -1; });
            if (possibleStopWords.length > 0) {
                searchWords.splice(searchWords.length - 1, 1);
            }
            // remove all exact stopwords
            this.offlineSearchResult.options.stopWords.forEach(function (stopWord) {
                while (searchWords.indexOf(stopWord) > -1) {
                    searchWords.splice(searchWords.indexOf(stopWord), 1);
                }
            });
            var totResults;
            for (var j in searchWords) {
                var result = this.getKeywordHits(searchWords[j]);
                totResults = !totResults
                    ? result
                    : this.mergeResults(totResults, result);
            }
            var searchResults = [];
            var layers = this.offlineSearchResult.layers;
            var count = resultCount;
            var resultIndex = 0;
            while (count > 0 && resultIndex < totResults.length) {
                var r = totResults[resultIndex++];
                var subCount = Math.min(count, r.entries.length);
                for (var i = 0; i < subCount; i++) {
                    var entry = r.entries[i];
                    var layer = layers[entry.layerIndex];
                    count--;
                    searchResults.push(new OfflineSearchResultViewModel(layer.featureNames[entry.featureIndex], layer.title, layer.groupTitle, entry));
                }
            }
            // Group search results by groupTitle | layerTitle
            var groups = {};
            searchResults.forEach(function (sr) {
                var group = sr.groupTitle + ' >> ' + sr.layerTitle;
                if (!groups.hasOwnProperty(group))
                    groups[group] = [];
                groups[group].push(sr);
            });
            searchResults = [];
            for (var key in groups) {
                if (!groups.hasOwnProperty(key))
                    continue;
                var firstInGroup = true;
                groups[key].forEach(function (sr) {
                    sr.firstInGroup = firstInGroup;
                    searchResults.push(sr);
                    firstInGroup = false;
                });
            }
            return searchResults;
        };
        /**
         * Merge the resuls of two keyword lookups by checking whether different entries refer
         * to the same layer and feature.
         * @result1 {ILookupResult[]}
         * @result2 {ILookupResult[]}
         */
        OfflineSearchCtrl.prototype.mergeResults = function (result1, result2) {
            var r = [];
            result1.forEach(function (r1) {
                result2.forEach(function (r2) {
                    r1.entries.forEach(function (entry1) {
                        r2.entries.forEach(function (entry2) {
                            if (entry1.layerIndex === entry2.layerIndex && entry1.featureIndex === entry2.featureIndex)
                                r.push({ score: r1.score * r2.score, key: r1.key + ' ' + r2.key, entries: [entry1] });
                        });
                    });
                });
            });
            r = r.sort(function (a, b) { return b.score - a.score; });
            return r;
        };
        /**
         * Do a fuzzy keyword comparison between the entered text and the list of keywords,
         * and return a subset.
         * @text: {string}
         */
        OfflineSearchCtrl.prototype.getKeywordHits = function (text) {
            var results = [];
            var keywordIndex = this.offlineSearchResult.keywordIndex;
            var keywords = Object.getOwnPropertyNames(keywordIndex);
            keywords.forEach(function (key) {
                var score = key.score(text, null);
                if (score < 0.5)
                    return;
                results.push({ score: score, key: key, entries: keywordIndex[key] });
            });
            results = results.sort(function (a, b) { return b.score - a.score; });
            return results;
        };
        /**
         * When an item is selected, optionally open the layer and jump to the selected feature.
         */
        OfflineSearchCtrl.prototype.onSelect = function (selectedItem) {
            var _this = this;
            var layerIndex = selectedItem.entry.layerIndex;
            var layer = this.offlineSearchResult.layers[layerIndex];
            var projectLayer = this.$layerService.findLayer(layer.id);
            console.log(selectedItem);
            if (!projectLayer)
                return;
            if (projectLayer.enabled) {
                this.selectFeature(layer.id, selectedItem.entry.featureIndex);
                return;
            }
            else {
                var handle = this.$messageBus.subscribe('layer', function (title, layer) {
                    if (title !== 'activated' || projectLayer.url !== layer.url)
                        return;
                    _this.selectFeature(layer.id, selectedItem.entry.featureIndex);
                    _this.$messageBus.unsubscribe(handle);
                });
                this.$layerService.addLayer(projectLayer);
            }
            var group = $("#layergroup_" + projectLayer.groupId);
            group.collapse("show");
        };
        OfflineSearchCtrl.prototype.selectFeature = function (layerId, featureIndex) {
            var feature = this.$layerService.findFeatureByIndex(layerId, featureIndex);
            if (feature == null)
                return;
            this.$mapService.zoomTo(feature);
            this.$layerService.selectFeature(feature);
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        OfflineSearchCtrl.$inject = [
            '$scope',
            '$http',
            'layerService',
            'mapService',
            'messageBusService'
        ];
        return OfflineSearchCtrl;
    })();
    OfflineSearch.OfflineSearchCtrl = OfflineSearchCtrl;
})(OfflineSearch || (OfflineSearch = {}));

var ProjectHeaderSelection;
(function (ProjectHeaderSelection) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        ProjectHeaderSelection.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        ProjectHeaderSelection.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    ProjectHeaderSelection.myModule.directive('projectHeaderSelection', [
        '$window', '$compile',
        function ($window, $compile) {
            return {
                terminal: false,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/ProjectSelection/ProjectHeaderSelection.tpl.html',
                link: function (scope, element, attrs) {
                },
                replace: true,
                transclude: true,
                controller: ProjectHeaderSelection.ProjectHeaderSelectionCtrl
            };
        }
    ]);
})(ProjectHeaderSelection || (ProjectHeaderSelection = {}));

var ProjectHeaderSelection;
(function (ProjectHeaderSelection) {
    var ProjectHeaderSelectionCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function ProjectHeaderSelectionCtrl($scope, $layerService, $dashboardService, $mapService, $messageBusService) {
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$dashboardService = $dashboardService;
            this.$mapService = $mapService;
            this.$messageBusService = $messageBusService;
            $scope.vm = this;
        }
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        ProjectHeaderSelectionCtrl.$inject = [
            '$scope',
            'layerService',
            'dashboardService',
            'mapService',
            'messageBusService'
        ];
        return ProjectHeaderSelectionCtrl;
    })();
    ProjectHeaderSelection.ProjectHeaderSelectionCtrl = ProjectHeaderSelectionCtrl;
})(ProjectHeaderSelection || (ProjectHeaderSelection = {}));

var ProjectSettings;
(function (ProjectSettings) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        ProjectSettings.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        ProjectSettings.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    ProjectSettings.myModule.directive('projectSettings', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/ProjectSettings/ProjectSettings.tpl.html',
                // compile: el => {    // I need to explicitly compile it in order to use interpolation like {{xxx}}
                //     var fn = $compile(el);
                //     return scope => {
                //         fn(scope);
                //     };
                // },
                replace: true,
                //transclude: true,    // Add elements and attributes to the template
                controller: ProjectSettings.ProjectSettingsCtrl
            };
        }
    ]);
})(ProjectSettings || (ProjectSettings = {}));

var ProjectSettings;
(function (ProjectSettings) {
    var ProjectSettingsCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function ProjectSettingsCtrl($scope, $timeout, $layerService) {
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$layerService = $layerService;
            $scope.vm = this;
        }
        ProjectSettingsCtrl.prototype.saveSettings = function () {
            var _this = this;
            this.$timeout(function () {
                var data = _this.$layerService.project.serialize();
                //console.log(data);
                console.log("Save settings: ");
                csComp.Helpers.saveData(data, "project", "json");
            }, 0);
        };
        ProjectSettingsCtrl.prototype.updateProject = function () {
            var _this = this;
            console.log('Update project called');
            this.$timeout(function () {
                var data = _this.$layerService.project.serialize();
                var url = _this.$layerService.projectUrl.url.substr(0, _this.$layerService.projectUrl.url.indexOf('/project.json'));
                console.log('URL: ' + url);
                $.ajax({
                    url: url,
                    type: "POST",
                    data: data,
                    contentType: "application/json",
                    complete: _this.updateProjectReady
                });
            }, 0);
            for (var id in this.$layerService.typesResources) {
                if (id.indexOf('data/resourceTypes/') >= 0) {
                    var file = this.$layerService.typesResources[id];
                    var data = csComp.Services.TypeResource.serialize(file);
                    var url = "api/resourceTypes/" + id.replace('data/resourceTypes/', ''); //this.$layerService.projectUrl.url.substr(0, this.$layerService.projectUrl.url.indexOf('/project.json'));
                    $.ajax({
                        url: url,
                        type: "POST",
                        data: data,
                        contentType: "application/json",
                        complete: this.updateProjectReady
                    });
                }
            }
        };
        ProjectSettingsCtrl.prototype.updateProjectReady = function (data) {
            if (data.success().statusText != 'OK')
                console.error('Error update project.json: ' + JSON.stringify(data));
            else
                console.log('Project.json updated succesfully!');
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        ProjectSettingsCtrl.$inject = [
            '$scope',
            '$timeout',
            'layerService'
        ];
        return ProjectSettingsCtrl;
    })();
    ProjectSettings.ProjectSettingsCtrl = ProjectSettingsCtrl;
})(ProjectSettings || (ProjectSettings = {}));

var Helpers;
(function (Helpers) {
    var Resize;
    (function (Resize) {
        /**
         * Config
         */
        var moduleName = 'csComp';
        try {
            Resize.myModule = angular.module(moduleName);
        }
        catch (err) {
            // named module does not exist, so create one
            Resize.myModule = angular.module(moduleName, []);
        }
        /**
          * Directive to resize an element by settings its width or height,
          * for example to make sure that the scrollbar appears.
          * Typical usage:
          * <div style="overflow-y: auto; overflow-x: hidden" resize resize-x="20" resize-y="250">...</div>
          * Load the directive in your module, e.g.
          * angular.module('myWebApp', ['csWeb.resize'])
          */
        Resize.myModule.directive('resize', ['$window',
            function ($window) {
                return {
                    terminal: false,
                    // E = elements, A=attributes and C=css classes. Can be compined, e.g. EAC
                    restrict: 'A',
                    // Name if optional. Text Binding (Prefix: @), One-way Binding (Prefix: &), Two-way Binding (Prefix: =)
                    scope: {
                        resizeX: '@',
                        resizeY: '@'
                    },
                    // Directives that want to modify the DOM typically use the link option.link takes a function with the following signature, function link(scope, element, attrs) { ... } where:
                    // * scope is an Angular scope object.
                    // * element is the jqLite wrapped element that this directive matches.
                    // * attrs is a hash object with key-value pairs of normalized attribute names and their corresponding attribute values.
                    link: function (scope, element, attrs) {
                        scope.onResizeFunction = function () {
                            // console.log(scope.resizeX + "-" + scope.resizeY);
                            if (scope.resizeX) {
                                var windowWidth = $window.innerWidth;
                                element.width((windowWidth - scope.resizeX) + 'px');
                            }
                            if (scope.resizeY) {
                                var windowHeight = $window.innerHeight;
                                element.height((windowHeight - scope.resizeY) + 'px');
                            }
                        };
                        // Call to the function when the page is first loaded
                        scope.onResizeFunction();
                        // Listen to the resize event.
                        angular.element($window).bind('resize', function () {
                            scope.onResizeFunction();
                            scope.$apply();
                        });
                    }
                };
            }
        ]);
    })(Resize = Helpers.Resize || (Helpers.Resize = {}));
})(Helpers || (Helpers = {}));

var ShowModal;
(function (ShowModal) {
    /**
    * Config
    */
    var moduleName = 'csComp';
    try {
        ShowModal.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        ShowModal.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to show a modal dialog, whose html is specified inside the main HTML code.
      * Typical usage: http://plnkr.co/edit/WJBp7A6M3RB1MLERDXSS?p=info
      * angular.module('myWebApp', ['csWeb.showModal'])
      */
    ShowModal.myModule.directive('showModal', [
        '$parse',
        function ($parse) {
            return {
                restrict: "A",
                link: function (scope, element, attrs) {
                    //Hide or show the modal
                    scope.showModalDialog = function (visible, elem) {
                        if (!elem)
                            elem = element;
                        var myElem = $(elem);
                        if (visible)
                            myElem.appendTo('body').modal("show");
                        else
                            myElem.modal("hide");
                    };
                    //Watch for changes to the modal-visible attribute
                    scope.$watch(attrs.showModal, function (newValue, oldValue) {
                        scope.showModalDialog(newValue, attrs.$$element);
                    });
                    //Update the visible value when the dialog is closed through UI actions (Ok, cancel, etc.)
                    $(element).bind("hide.bs.modal", function () {
                        $parse(attrs.showModal).assign(scope, false);
                        if (!scope.$$phase && !scope.$root.$$phase)
                            scope.$apply();
                    });
                }
            };
        }
    ]);
})(ShowModal || (ShowModal = {}));

var StyleList;
(function (StyleList) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        StyleList.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        StyleList.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    StyleList.myModule
        .filter('reverse', function () {
        return function (items) {
            return items.slice().reverse();
        };
    })
        .directive('styleList', ['$window', '$compile', function ($window, $compile) {
            return {
                terminal: false,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/StyleList/StyleList.tpl.html',
                //compile             : el          => {    // I need to explicitly compile it in order to use interpolation like {{xxx}}
                //    var fn                        = $compile(el);
                //    return scope                  => {
                //        fn(scope);
                //    };
                //},
                link: function (scope, element, attrs) {
                    // Deal with resizing the element list
                    scope.onResizeFunction = function () {
                        var filterHeight = 50;
                        var paginationCtrlHeight = 100;
                        var itemHeight = 60;
                        //scope.windowHeight          = $window.innerHeight;
                        //scope.windowWidth           = $window.innerWidth;
                        scope.numberOfItems = Math.floor(($window.innerHeight - filterHeight - paginationCtrlHeight) / itemHeight);
                    };
                    // Call to the function when the page is first loaded
                    scope.onResizeFunction();
                    angular.element($window).bind('resize', function () {
                        scope.onResizeFunction();
                        scope.$apply();
                    });
                },
                replace: true,
                transclude: true,
                controller: StyleList.StyleListCtrl
            };
        }
    ]);
})(StyleList || (StyleList = {}));

var StyleList;
(function (StyleList) {
    var StyleListCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function StyleListCtrl($scope, $layerService) {
            this.$scope = $scope;
            this.$layerService = $layerService;
            $scope.vm = this;
        }
        StyleListCtrl.prototype.getStyle = function (legend, le, key) {
            return {
                'float': 'left',
                'position': 'relative',
                'top': '10px',
                'background': "linear-gradient(to bottom, " + le.color + ", " + legend.legendEntries[legend.legendEntries.length - key - 2].color + ")"
            };
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be in  jected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        StyleListCtrl.$inject = [
            '$scope',
            'layerService'
        ];
        return StyleListCtrl;
    })();
    StyleList.StyleListCtrl = StyleListCtrl;
})(StyleList || (StyleList = {}));

var Timeline;
(function (Timeline) {
    // The following class represents the provider
    var TimelineService = (function () {
        function TimelineService() {
            this.timelineOptions = {
                'width': '100%',
                'height': '100px',
                'editable': false,
                'layout': 'box'
            };
        }
        // Configuration function
        TimelineService.prototype.setTimelineOptions = function (options) {
            this.timelineOptions = options;
        };
        // Provider's factory function
        TimelineService.prototype.$get = function () {
            var _this = this;
            return {
                getTimelineOptions: function () { return _this.timelineOptions; },
                setTimelineOptions: function (options) { return _this.setTimelineOptions; }
            };
        };
        return TimelineService;
    })();
    /**
     * Config
     */
    var moduleName = 'csComp';
    try {
        Timeline.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Timeline.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      *
      * When turning of the event margins in app.ts (see below), also set the #focustimeContainer { bottom: 45px; }
      * $layerService.timelineOptions = {
      *     'width': '100%',
      *     "eventMargin": 0,
      *     "eventMarginAxis": 0,
      *     'editable': false,
      *     'layout': 'box'
      * };
      * @seealso: http://almende.github.io/chap-links-library/downloads.html
      */
    Timeline.myModule
        .provider('TimelineService', TimelineService)
        .directive('timeline', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Timeline/Timeline.tpl.html',
                replace: true,
                transclude: true,
                controller: Timeline.TimelineCtrl
            };
        }
    ]);
})(Timeline || (Timeline = {}));

var Timeline;
(function (Timeline) {
    var TimelineCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function TimelineCtrl($scope, $layerService, $mapService, $messageBusService, TimelineService) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$mapService = $mapService;
            this.$messageBusService = $messageBusService;
            this.TimelineService = TimelineService;
            this.locale = "en-us";
            this.expanded = false;
            this.isPinned = true;
            this.expandButtonBottom = 52;
            this.items = new vis.DataSet();
            this.ids = [];
            this.loadLocales();
            this.options = {
                'width': '100%',
                'editable': false,
                'margin': 0,
                'height': "54px"
            };
            this.debounceUpdate = _.debounce(this.updateFeatures, 500);
            $scope.vm = this;
            this.$messageBusService.subscribe("project", function (s, data) {
                setTimeout(function () {
                    //    this.initTimeline();
                    _this.updateFocusTime();
                    _this.updateDragging();
                    _this.myTimer();
                    if (_this.$layerService.project.timeLine.isLive)
                        _this.goLive();
                }, 0);
            });
            this.initTimeline();
            this.$messageBusService.subscribe("timeline", function (s, data) { _this.update(s, data); });
            this.$messageBusService.subscribe('feature', function (s, feature) {
                if (s === 'onFeatureSelect' && feature) {
                    if (_this.ids.indexOf(feature.id) != -1) {
                        _this.$scope.timeline.setSelection(feature.id);
                    }
                }
            });
            //$scope.focusDate = $layerService.project.timeLine.focusDate();
            // Options for the timeline
            this.$messageBusService.subscribe("language", function (s, newLanguage) {
                switch (s) {
                    case "newLanguage":
                        _this.initTimeline();
                        break;
                }
            });
        }
        TimelineCtrl.prototype.update = function (s, data) {
            {
                switch (s) {
                    case "updateTimerange":
                        this.$scope.timeline.setWindow(data.start, data.end);
                        this.updateFocusTime();
                        break;
                    case "loadProjectTimeRange":
                        if (typeof this.$layerService.project === 'undefined'
                            || this.$layerService.project === null
                            || typeof this.$layerService.project.timeLine === 'undefined'
                            || this.$layerService.project.timeLine === null)
                            return;
                        this.$scope.timeline.setWindow(this.$layerService.project.timeLine.start, this.$layerService.project.timeLine.end);
                        this.updateFocusTime();
                        break;
                    case "setFocus":
                        this.$scope.timeline.moveTo(data);
                        break;
                    case "updateFeatures":
                        this.debounceUpdate();
                        break;
                }
            }
        };
        TimelineCtrl.prototype.updateFeatures = function () {
            var _this = this;
            console.log("timeline:updating features");
            //this.items = [];
            //this.$scope.timeline.redraw();
            var temp = [];
            var hasChanged = false;
            // check for new items
            this.$layerService.project.features.forEach(function (f) {
                hasChanged = true;
                if (f.layer.showOnTimeline && f.properties.hasOwnProperty('date')) {
                    temp.push(f.id);
                    if (_this.ids.indexOf(f.id) === -1) {
                        var t = { id: f.id, group: 'all', content: f.properties['Name'], start: new Date(f.properties['date']) };
                        _this.items.update(t);
                        _this.ids.push(f.id);
                    }
                }
            });
            // check for old items
            this.ids.forEach(function (s) {
                hasChanged = true;
                if (temp.indexOf(s) === -1) {
                    // remove item
                    var i = _this.items.remove(s);
                    _this.ids = _this.ids.filter(function (t) { return s != t; });
                }
            });
            //this.$scope.timeline.setItems(i);
            if (hasChanged)
                this.$scope.timeline.redraw();
        };
        TimelineCtrl.prototype.initTimeline = function () {
            var _this = this;
            var container = document.getElementById('timeline');
            // Remove old timeline before initializing a new one
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            this.$layerService.timeline = this.$scope.timeline = new vis.Timeline(container, this.items, this.options);
            this.$layerService.timeline.redraw();
            if (this.$layerService.project && this.$layerService.project.timeLine !== null) {
                this.$scope.timeline.setWindow(this.$layerService.project.timeLine.start, this.$layerService.project.timeLine.end);
                if (this.$layerService.project.timeLine.isLive)
                    this.goLive();
            }
            this.updateDragging();
            this.updateFocusTime();
            this.$scope.timeline.on('select', function (properties) {
                if (properties.items && properties.items.length > 0) {
                    var id = properties.items[0];
                    var f = _this.$layerService.findFeatureById(id);
                    if (f)
                        _this.$layerService.selectFeature(f);
                }
            });
            this.$scope.timeline.addEventListener('rangechange', _.throttle(function (prop) { return _this.onRangeChanged(prop); }, 200));
            //this.addEventListener('featureschanged', _.throttle((prop) => this.updateFeatures(), 200));
        };
        TimelineCtrl.prototype.updateDragging = function () {
            var _this = this;
            if (this.$layerService.project && this.$layerService.project.timeLine.isLive) {
                $("#focustimeContainer").draggable('disable');
            }
            else {
                $("#focustimeContainer").draggable({
                    axis: "x",
                    containment: "parent",
                    drag: _.throttle(function () { return _this.updateFocusTime(); }, 200)
                });
                $("#focustimeContainer").draggable('enable');
            }
        };
        TimelineCtrl.prototype.expandToggle = function () {
            this.expanded = !this.expanded;
            //    this.options.margin = {};
            //    this.options.margin['item'] = (this.expanded) ? 65 : 0;
            this.options.height = (this.expanded) ? 150 : 54;
            this.expandButtonBottom = (this.expanded) ? 149 : 52;
            this.$layerService.timeline.setOptions(this.options);
            this.$layerService.timeline.redraw();
        };
        TimelineCtrl.prototype.onRangeChanged = function (prop) {
            this.updateFocusTime();
        };
        TimelineCtrl.prototype.start = function () {
            var _this = this;
            this.stop();
            this.isPlaying = true;
            if (this.timer)
                this.timer = null;
            this.timer = setInterval(function () { _this.myTimer(); }, 500);
        };
        TimelineCtrl.prototype.goLive = function () {
            this.stop();
            this.$layerService.project.timeLine.isLive = true;
            this.isPlaying = false;
            if (this.$layerService.project.timeLine.isLive) {
                this.myTimer();
                this.start();
            }
            this.updateDragging();
        };
        TimelineCtrl.prototype.stopLive = function () {
            if (!this.$layerService.project)
                return;
            this.stop();
            this.$layerService.project.timeLine.isLive = false;
            this.isPlaying = false;
            this.updateDragging();
        };
        TimelineCtrl.prototype.myTimer = function () {
            var tl = this.$scope.timeline;
            if (this.$layerService.project.timeLine.isLive) {
                var pos = tl._toScreen(new Date());
                $("#focustimeContainer").css('left', pos - 65);
                if (this.isPinned)
                    tl.moveTo(new Date(), { animation: { duration: 500, easingFunction: 'linear' } });
                this.updateFocusTime();
            }
            else if (this.isPlaying) {
                var w = tl.getWindow();
                var dif = (w.end.getTime() - w.start.getTime()) / 200;
                tl.setWindow(w.start.getTime() + dif, w.end.getTime() + dif, { animation: { duration: 500, easingFunction: 'linear' } });
                //tl.move(0.005);
                this.updateFocusTime();
            }
        };
        TimelineCtrl.prototype.mouseEnter = function () {
            this.updateFocusTime();
            if (!isNaN(this.focusDate.getTime())) {
                this.showControl = true;
            }
        };
        TimelineCtrl.prototype.mouseLeave = function () {
            if (!this.isPlaying)
                this.showControl = false;
        };
        TimelineCtrl.prototype.pin = function () {
            this.isPinned = true;
        };
        TimelineCtrl.prototype.unPin = function () {
            this.isPinned = false;
        };
        TimelineCtrl.prototype.pinToNow = function () {
            this.isPinned = true;
            this.start();
        };
        TimelineCtrl.prototype.stop = function () {
            this.isPlaying = false;
            if (this.timer)
                clearInterval(this.timer);
        };
        TimelineCtrl.prototype.updateFocusTime = function () {
            var _this = this;
            if (!this.$layerService.project)
                return;
            //if (!this.$mapService.timelineVisible) return;
            setTimeout(function () {
                var tl = _this.$scope.timeline;
                tl.showCustomTime = true;
                tl.setCustomTime = typeof _this.$layerService.project === 'undefined'
                    ? new Date()
                    : _this.$layerService.project.timeLine.focusDate();
                //var end = $("#timeline").width;
                var range = _this.$scope.timeline.getWindow();
                //tl.calcConversionFactor();
                var pos = $("#focustimeContainer").position().left + $("#focustimeContainer").width() / 2;
                if (_this.$layerService.project.timeLine.isLive) {
                    _this.focusDate = new Date();
                }
                else {
                    _this.focusDate = new Date(_this.$scope.timeline._toTime(pos + 1));
                }
                _this.startDate = range.start; //new Date(range.start); //this.$scope.timeline.screenToTime(0));
                _this.endDate = range.end; //new Date(this.$scope.timeline.screenToTime(end));
                if (_this.$layerService.project != null && _this.$layerService.project.timeLine != null) {
                    var projecttime = _this.$layerService.project.timeLine;
                    projecttime.setFocus(_this.focusDate, _this.startDate, _this.endDate);
                    var month = _this.focusDate.toLocaleString(_this.locale, { month: "long" });
                    switch (projecttime.zoomLevelName) {
                        case "decades":
                            _this.line1 = _this.focusDate.getFullYear().toString();
                            _this.line2 = "";
                            break;
                        case "years":
                            _this.line1 = _this.focusDate.getFullYear().toString();
                            _this.line2 = month;
                            break;
                        case "weeks":
                            _this.line1 = _this.focusDate.getFullYear().toString();
                            _this.line2 = moment(_this.focusDate).format('DD') + " " + month;
                            break;
                        case "milliseconds":
                            _this.line1 = moment(_this.focusDate).format('MM - DD - YYYY');
                            _this.line2 = moment(_this.focusDate).format('HH:mm:ss.SSS');
                            break;
                        default:
                            _this.line1 = moment(_this.focusDate).format('MM - DD - YYYY');
                            _this.line2 = moment(_this.focusDate).format('HH:mm:ss');
                    }
                }
                if (_this.$scope.$$phase != '$apply' && _this.$scope.$$phase != '$digest') {
                    _this.$scope.$apply();
                }
                _this.$messageBusService.publish("timeline", "focusChange", _this.focusDate);
            }, 0);
            //this.$layerService.focusTime = new Date(this.timelineCtrl.screenToTime(centerX));
        };
        /**
        * Load the locales: instead of loading them from the original timeline-locales.js distribution,
        * add them here so you don't need to add another js dependency.
        * @seealso: http://almende.github.io/chap-links-library/downloads.html
        */
        TimelineCtrl.prototype.loadLocales = function () {
            if (typeof vis === 'undefined') {
                vis = {};
                vis.locales = {};
            }
            else if (typeof vis.locales === 'undefined') {
                vis.locales = {};
            }
            // English ===================================================
            vis.locales['en'] = {
                'MONTHS': ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                'MONTHS_SHORT': ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
                'DAYS': ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                'DAYS_SHORT': ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                'ZOOM_IN': "Zoom in",
                'ZOOM_OUT': "Zoom out",
                'MOVE_LEFT': "Move left",
                'MOVE_RIGHT': "Move right",
                'NEW': "New",
                'CREATE_NEW_EVENT': "Create new event"
            };
            vis.locales['en_US'] = vis.locales['en'];
            vis.locales['en_UK'] = vis.locales['en'];
            // French ===================================================
            vis.locales['fr'] = {
                'MONTHS': ["Janvier", "Fvrier", "Mars", "Avril", "Mai", "Juin", "Juillet", "Aot", "Septembre", "Octobre", "Novembre", "Dcembre"],
                'MONTHS_SHORT': ["Jan", "Fev", "Mar", "Avr", "Mai", "Jun", "Jul", "Aou", "Sep", "Oct", "Nov", "Dec"],
                'DAYS': ["Dimanche", "Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi"],
                'DAYS_SHORT': ["Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"],
                'ZOOM_IN': "Zoomer",
                'ZOOM_OUT': "Dzoomer",
                'MOVE_LEFT': "Dplacer  gauche",
                'MOVE_RIGHT': "Dplacer  droite",
                'NEW': "Nouveau",
                'CREATE_NEW_EVENT': "Crer un nouvel vnement"
            };
            vis.locales['fr_FR'] = vis.locales['fr'];
            vis.locales['fr_BE'] = vis.locales['fr'];
            vis.locales['fr_CA'] = vis.locales['fr'];
            // German ===================================================
            vis.locales['de'] = {
                'MONTHS': ["Januar", "Februar", "Mrz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"],
                'MONTHS_SHORT': ["Jan", "Feb", "Mr", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"],
                'DAYS': ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"],
                'DAYS_SHORT': ["Son", "Mon", "Die", "Mit", "Don", "Fre", "Sam"],
                'ZOOM_IN': "Vergrern",
                'ZOOM_OUT': "Verkleinern",
                'MOVE_LEFT': "Nach links verschieben",
                'MOVE_RIGHT': "Nach rechts verschieben",
                'NEW': "Neu",
                'CREATE_NEW_EVENT': "Neues Ereignis erzeugen"
            };
            vis.locales['de_DE'] = vis.locales['de'];
            vis.locales['de_CH'] = vis.locales['de'];
            // Dutch =====================================================
            vis.locales['nl'] = {
                'MONTHS': ["januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"],
                'MONTHS_SHORT': ["jan", "feb", "mrt", "apr", "mei", "jun", "jul", "aug", "sep", "okt", "nov", "dec"],
                'DAYS': ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"],
                'DAYS_SHORT': ["zo", "ma", "di", "wo", "do", "vr", "za"],
                'ZOOM_IN': "Inzoomen",
                'ZOOM_OUT': "Uitzoomen",
                'MOVE_LEFT': "Naar links",
                'MOVE_RIGHT': "Naar rechts",
                'NEW': "Nieuw",
                'CREATE_NEW_EVENT': "Nieuwe gebeurtenis maken"
            };
            vis.locales['nl_NL'] = vis.locales['nl'];
            vis.locales['nl_BE'] = vis.locales['nl'];
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        TimelineCtrl.$inject = [
            '$scope',
            'layerService',
            'mapService',
            'messageBusService',
            'TimelineService'
        ];
        return TimelineCtrl;
    })();
    Timeline.TimelineCtrl = TimelineCtrl;
})(Timeline || (Timeline = {}));

var TripPlanner;
(function (TripPlanner) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        TripPlanner.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        TripPlanner.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a feature's properties in a panel.
      *
      * @seealso          : http://www.youtube.com/watch?v=gjJ5vLRK8R8&list=UUGD_0i6L48hucTiiyhb5QzQ
      * @seealso          : http://plnkr.co/edit/HyBP9d?p=preview
      */
    TripPlanner.myModule.directive('tripplanner', ['$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/TripPlanner/TripPlanner.tpl.html',
                replace: true,
                transclude: true,
                controller: TripPlanner.TripPlannerCtrl
            };
        }
    ]);
})(TripPlanner || (TripPlanner = {}));

var TripPlanner;
(function (TripPlanner) {
    var TripPlannerCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function TripPlannerCtrl($scope, $mapService, $layerService, $messageBusService, $dashboardService) {
            var _this = this;
            this.$scope = $scope;
            this.$mapService = $mapService;
            this.$layerService = $layerService;
            this.$messageBusService = $messageBusService;
            this.$dashboardService = $dashboardService;
            this.urlKeys = ['arriveBy', 'fromPlace', 'toPlace', 'intermediatePlaces', 'date', 'time', 'mode', 'maxWalkDistance', 'walkSpeed', 'bikeSpeed',
                'maxTimeSec', 'precisionMeters', 'zDataType', 'coordinateOrigin'];
            this.scope = $scope;
            $scope.vm = this;
            this.layer = $scope.$parent["data"];
            this.tabs = [];
            this.tabs.push({ icon: 'fa-edit', title: 'Edit' });
            this.tabs.push({ icon: 'fa-map-marker', title: 'Route' });
            this.activeTab = 'Edit';
            this.urlParameters = {};
            this.urlKeys.forEach(function (key) { _this.urlParameters[key] = 0; });
            this.bikeSpeedKm;
            this.walkSpeedKm;
            this.transportModes = {};
            this.transportModes["Walking"] = "WALK";
            this.transportModes["Biking"] = "BICYCLE";
            this.transportModes["Public transport"] = "TRANSIT";
            //this.transportModes["Car"] = "CAR";
        }
        TripPlannerCtrl.prototype.planRoute = function () {
            this.urlParameters['time'] = encodeURIComponent(this.time);
            this.urlParameters['mode'] = this.transportMode;
            if (this.walkSpeedKm)
                this.urlParameters['walkSpeed'] = csComp.Helpers.GeoExtensions.convertKmToMile(this.walkSpeedKm);
            if (this.bikeSpeedKm)
                this.urlParameters['bikeSpeed'] = csComp.Helpers.GeoExtensions.convertKmToMile(this.bikeSpeedKm);
            this.layer.url = csComp.Helpers.joinUrlParameters(this.urlParameters, '?', '&', '=');
            if (!this.layer.enabled) {
                this.$layerService.addLayer(this.layer);
            }
            else {
                if (this.layer.layerSource)
                    this.layer.layerSource.refreshLayer(this.layer);
            }
            this.$layerService.visual.rightPanelVisible = true;
        };
        TripPlannerCtrl.prototype.parseUrl = function () {
            this.urlParameters = csComp.Helpers.parseUrlParameters(this.layer.url, '?', '&', '=');
            var d = new Date(Date.now());
            this.time = ('0' + d.getHours()).slice(-2) + ':' + ('0' + d.getMinutes()).slice(-2);
            this.urlParameters['date'] = (d.getMonth() + 1) + '-' + d.getDate() + '-' + d.getFullYear();
            this.transportMode = this.urlParameters['mode'];
            if (this.urlParameters.hasOwnProperty('walkSpeed'))
                this.walkSpeedKm = +csComp.Helpers.GeoExtensions.convertMileToKm(this.urlParameters['walkSpeed']).toFixed(2);
            if (this.urlParameters.hasOwnProperty('bikeSpeed'))
                this.bikeSpeedKm = +csComp.Helpers.GeoExtensions.convertMileToKm(this.urlParameters['bikeSpeed']).toFixed(2);
            if (this.$scope.$root.$$phase != '$apply' && this.$scope.$root.$$phase != '$digest') {
                this.$scope.$apply();
            }
        };
        TripPlannerCtrl.prototype.featureTabActivated = function (title) {
            var _this = this;
            console.log('activated tab' + title);
            if (title === 'Route') {
                var layer = this.$layerService.findLayer('tripplanner');
                if (!layer)
                    return;
                if (!layer.data.features || layer.data.features.length === 0)
                    return;
                this.itineraries = [];
                layer.data.features.forEach(function (f) {
                    _this.itineraries.push(f.properties);
                });
                this.activeTab = 'Route';
            }
            else {
                this.activeTab = 'Edit';
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        TripPlannerCtrl.$inject = [
            '$scope',
            'mapService',
            'layerService',
            'messageBusService',
            'dashboardService'
        ];
        return TripPlannerCtrl;
    })();
    TripPlanner.TripPlannerCtrl = TripPlannerCtrl;
})(TripPlanner || (TripPlanner = {}));

var Voting;
(function (Voting) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Voting.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Voting.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display an MCA control.
      */
    Voting.myModule.directive('voting', ['$timeout', function ($timeout) {
            return {
                restrict: 'EA',
                require: '^ngModel',
                scope: {
                    min: '=',
                    max: '=',
                    ngModel: '=',
                    ngChange: '&'
                },
                template: '<div style="line-height: 12px; vertical-align: top; margin: 0; background: rgba(0, 0, 0, 0.1); border-radius: 6px; padding: 4px 6px;">' +
                    '<a href="" data-ng-click="decrement()" data-ng-disabled="ngModel <= min" style="float: left;"><i class="fa" data-ng-class="{true: \'fa-minus-square\', false: \'fa-minus-square-o\'}[ngModel > min]"></i></a>' +
                    '<span style="float: left; width:28px; text-align: center;">{{ngModel}}</span>' +
                    '<a href="" data-ng-click="increment()" data-ng-disabled="ngModel >= max"><i class="fa" data-ng-class="{true: \'fa-plus-square\' , false: \'fa-plus-square-o\' }[ngModel < max]"></i></a>' +
                    '</div>',
                link: function ($scope) {
                    $scope.increment = function () {
                        if ($scope.ngModel >= $scope.max)
                            return;
                        $scope.ngModel++;
                        $timeout($scope.ngChange, 0);
                    };
                    $scope.decrement = function () {
                        if ($scope.ngModel <= $scope.min)
                            return;
                        $scope.ngModel--;
                        $timeout($scope.ngChange, 0);
                    };
                }
            };
        }
    ]);
})(Voting || (Voting = {}));


var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var ClientMessage = (function () {
            function ClientMessage(action, data) {
                this.action = action;
                this.data = data;
            }
            return ClientMessage;
        })();
        Services.ClientMessage = ClientMessage;
        // Handle returned when subscribing to a topic
        var MessageBusHandle = (function () {
            function MessageBusHandle(topic, callback) {
                this.topic = topic;
                this.callback = callback;
            }
            return MessageBusHandle;
        })();
        Services.MessageBusHandle = MessageBusHandle;
        var TypedEvent = (function () {
            function TypedEvent() {
                // Private member vars
                this._listeners = [];
            }
            TypedEvent.prototype.add = function (listener) {
                /// <summary>Registers a new listener for the event.</summary>
                /// <param name="listener">The callback function to register.</param>
                this._listeners.push(listener);
            };
            TypedEvent.prototype.remove = function (listener) {
                /// <summary>Unregisters a listener from the event.</summary>
                /// <param name="listener">The callback function that was registered. If missing then all listeners will be removed.</param>
                if (typeof listener === 'function') {
                    for (var i = 0, l = this._listeners.length; i < l; l++) {
                        if (this._listeners[i] === listener) {
                            this._listeners.splice(i, 1);
                            break;
                        }
                    }
                }
                else {
                    this._listeners = [];
                }
            };
            TypedEvent.prototype.trigger = function () {
                var a = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    a[_i - 0] = arguments[_i];
                }
                /// <summary>Invokes all of the listeners for this event.</summary>
                /// <param name="args">Optional set of arguments to pass to listners.</param>
                var context = {};
                var listeners = this._listeners.slice(0);
                for (var i = 0, l = listeners.length; i < l; i++) {
                    listeners[i].apply(context, a || []);
                }
            };
            return TypedEvent;
        })();
        Services.TypedEvent = TypedEvent;
        var Connection = (function () {
            function Connection(id, url, bus) {
                this.id = id;
                this.url = url;
                this.bus = bus;
                this.cache = {};
                this.subscriptions = {};
                // Events
                this.events = new TypedEvent();
            }
            Connection.prototype.unsubscribe = function (id, callback) {
                if (this.subscriptions.hasOwnProperty(id)) {
                    var s = this.subscriptions[id];
                    s.callbacks = s.callbacks.filter(function (f) { return f != callback; });
                    if (s.callbacks.length == 0) {
                        this.socket.emit(id, { action: "unsubscribe" });
                        this.socket.removeListener(id, s.serverCallback);
                        s.serverCallback = null;
                        delete this.subscriptions[id];
                    }
                }
            };
            Connection.prototype.reSubscribeAll = function () {
                console.log('resubscribing...');
                for (var s in this.subscriptions) {
                    console.log('reconnecting ' + s);
                    var sub = this.subscriptions[s];
                    this.socket.emit("subscribe", { id: sub.id, target: sub.target, type: sub.type });
                }
            };
            Connection.prototype.disconnectAll = function () {
                console.log('resubscribing...');
                for (var s in this.subscriptions) {
                    var sub = this.subscriptions[s];
                    sub.callbacks.forEach(function (cb) { return cb(sub.id, { action: "unsubscribed" }); });
                }
            };
            Connection.prototype.subscribe = function (target, type, callback) {
                var _this = this;
                var sub;
                var subs = [];
                for (var s in this.subscriptions) {
                    if (this.subscriptions[s].target == target && this.subscriptions[s].type == type)
                        subs.push(this.subscriptions[s]);
                }
                if (subs == null || subs.length == 0) {
                    sub = new ServerSubscription(target, type);
                    this.socket.emit("subscribe", { id: sub.id, target: sub.target, type: sub.type });
                    sub.callbacks.push(callback);
                    this.subscriptions[sub.id] = sub;
                    sub.serverCallback = function (r) {
                        if (type === "key") {
                            _this.bus.publish("keyupdate", target, r);
                        }
                        //console.log(r.action);
                        sub.callbacks.forEach(function (cb) { return cb(sub.id, r); });
                    };
                    this.socket.on(sub.id, sub.serverCallback);
                }
                else {
                    sub = subs[0];
                    sub.callbacks.push(callback);
                }
                return sub;
            };
            Connection.prototype.connect = function (callback) {
                var _this = this;
                if (this.isConnected || this.isConnecting || typeof io === "undefined")
                    return;
                this.socket = io();
                this.isConnecting = true;
                this.socket.on('connect', function () {
                    //console.log(JSON.stringify(this.socket));
                    console.log('socket.io connected');
                    _this.isConnecting = false;
                    _this.isConnected = true;
                    _this.events.trigger("connected");
                    _this.reSubscribeAll();
                    callback();
                });
                this.socket.on('disconnect', function () {
                    _this.isConnecting = false;
                    _this.isConnected = false;
                    _this.disconnectAll();
                    _this.events.trigger('disconnected');
                });
                this.socket.on('reconnect_attempt', function () {
                    console.log('socket.io reconnect attempt');
                    _this.isConnecting = true;
                    _this.isConnected = false;
                });
                this.socket.on('reconnect_failed', function () {
                    console.log('socket.io reconnect failed');
                    _this.isConnecting = false;
                });
            };
            Connection.prototype.disconnect = function () { };
            return Connection;
        })();
        Services.Connection = Connection;
        (function (NotifyLocation) {
            NotifyLocation[NotifyLocation["BottomRight"] = 0] = "BottomRight";
            NotifyLocation[NotifyLocation["BottomLeft"] = 1] = "BottomLeft";
            NotifyLocation[NotifyLocation["TopRight"] = 2] = "TopRight";
            NotifyLocation[NotifyLocation["TopLeft"] = 3] = "TopLeft";
        })(Services.NotifyLocation || (Services.NotifyLocation = {}));
        var NotifyLocation = Services.NotifyLocation;
        (function (NotifyType) {
            NotifyType[NotifyType["Normal"] = 0] = "Normal";
            NotifyType[NotifyType["Info"] = 1] = "Info";
            NotifyType[NotifyType["Error"] = 2] = "Error";
            NotifyType[NotifyType["Success"] = 3] = "Success";
        })(Services.NotifyType || (Services.NotifyType = {}));
        var NotifyType = Services.NotifyType;
        var ServerSubscription = (function () {
            function ServerSubscription(target, type) {
                this.target = target;
                this.type = type;
                this.callbacks = [];
                this.id = csComp.Helpers.getGuid();
            }
            return ServerSubscription;
        })();
        Services.ServerSubscription = ServerSubscription;
        /**
         * Simple message bus service, used for subscribing and unsubsubscribing to topics.
         * @see {@link https://gist.github.com/floatingmonkey/3384419}
         */
        var MessageBusService = (function () {
            function MessageBusService($translate) {
                this.$translate = $translate;
                this.connections = {};
                this.notifications = [];
                PNotify.prototype.options.styling = "fontawesome";
            }
            MessageBusService.prototype.getConnection = function (id) {
                if (this.connections.hasOwnProperty(id))
                    return this.connections[id];
                return null;
            };
            MessageBusService.prototype.initConnection = function (id, url, callback) {
                if (id == null)
                    id = "";
                var c = this.getConnection(id);
                if (c == null) {
                    c = new Connection(id, url, this);
                    this.connections[c.id] = c;
                }
                this.connections[id].connect(function () {
                    //for (var topic in c.cache) {
                    //    c.socket.on(topic,(r) => {
                    //        c.cache[topic].forEach(cb => cb(topic, r));
                    //    });
                    //}
                    callback();
                });
            };
            MessageBusService.prototype.serverPublish = function (topic, message, serverId) {
                if (serverId === void 0) { serverId = ""; }
                var c = this.getConnection(serverId);
                if (c == null)
                    return null;
                c.socket.emit(topic, message);
            };
            MessageBusService.prototype.serverSendMessage = function (msg, serverId) {
                if (serverId === void 0) { serverId = ""; }
                var c = this.getConnection(serverId);
                if (c == null)
                    return null;
                c.socket.emit("msg", msg);
            };
            MessageBusService.prototype.serverSendMessageAction = function (action, data, serverId) {
                if (serverId === void 0) { serverId = ""; }
                var cm = new ClientMessage(action, data);
                this.serverSendMessage(cm, serverId);
            };
            MessageBusService.prototype.serverSubscribe = function (target, type, callback, serverId) {
                if (serverId === void 0) { serverId = ""; }
                var c = this.getConnection(serverId);
                if (c == null)
                    return null;
                var sub = c.subscribe(target, type, callback);
                return new MessageBusHandle(sub.id, callback);
            };
            MessageBusService.prototype.serverUnsubscribe = function (handle, serverId) {
                if (serverId === void 0) { serverId = ""; }
                if (!handle)
                    return;
                var c = this.getConnection(serverId);
                if (c == null)
                    return null;
                c.unsubscribe(handle.topic, handle.callback);
            };
            /**
             * Publish a notification that needs to be translated
             * @title:       the translation key of the notification's title
             * @text:        the translation key of the notification's content
             * @location:    the location on the screen where the notification is shown (default bottom right)
             */
            MessageBusService.prototype.notifyWithTranslation = function (title, text, location) {
                var _this = this;
                if (location === void 0) { location = NotifyLocation.BottomRight; }
                this.$translate(title).then(function (translatedTitle) {
                    _this.$translate(text).then(function (translatedText) {
                        _this.notify(translatedTitle, translatedText, location);
                    });
                });
            };
            /**
             * Publish a notification
             * @title:       the title of the notification
             * @text:        the contents of the notification
             * @location:    the location on the screen where the notification is shown (default bottom right)
             * @notifyType:  the type of notification
             */
            MessageBusService.prototype.notify = function (title, text, location, notifyType) {
                if (location === void 0) { location = NotifyLocation.TopRight; }
                if (notifyType === void 0) { notifyType = NotifyType.Normal; }
                console.log('notify : ' + title);
                //Check if a notication with the same title exists. If so, update existing, if not, add new notification.
                if (this.notifications) {
                    this.notifications = this.notifications.filter(function (n) { return (n.state && n.state !== 'closed'); });
                    var updatedText;
                    this.notifications.some(function (n) {
                        if (n.state === 'closed')
                            return false;
                        if (n.options.title === title) {
                            var foundText = false;
                            var splittedText = n.options.text.split('\n');
                            splittedText.some(function (textLine, index, _splittedText) {
                                if (textLine.replace(/(\ \<\d+\>$)/, "") === text) {
                                    var txt = textLine.replace(/(\ \<\d+\>$)/, "");
                                    var nrWithBrackets = textLine.match(/(\ \<\d+\>$)/);
                                    var nr;
                                    nr = (!nrWithBrackets) ? 2 : +(nrWithBrackets[0].match(/\d+/)) + 1;
                                    _splittedText[index] = txt + ' <' + nr + '>';
                                    foundText = true;
                                    return true;
                                }
                                return false;
                            });
                            if (!foundText) {
                                splittedText.push(text);
                            }
                            updatedText = splittedText.join('\n');
                            n.update({ text: updatedText });
                            return true;
                        }
                        else {
                            return false;
                        }
                    });
                    if (updatedText) {
                        return;
                    }
                }
                var cssLocation;
                var cornerglass = 'ui-pnotify-sharp';
                var myStack = { dir1: "", dir2: "" };
                switch (location) {
                    case NotifyLocation.BottomLeft:
                        cssLocation = 'stack-bottomleft';
                        myStack.dir1 = 'up';
                        myStack.dir2 = 'right';
                        break;
                    case NotifyLocation.TopLeft:
                        cssLocation = 'stack-topleft';
                        myStack.dir1 = 'down';
                        myStack.dir2 = 'right';
                        break;
                    default:
                        //case NotifyLocation.TopRight:
                        cssLocation = 'stack-topright';
                        myStack.dir1 = 'down';
                        myStack.dir2 = 'left';
                        break;
                }
                var options = {
                    title: title,
                    text: text,
                    cornerclass: cornerglass,
                    addclass: cssLocation,
                    stack: myStack
                };
                switch (notifyType) {
                    default:
                        options.icon = 'fa fa-info';
                        break;
                    case NotifyType.Info:
                        options.icon = 'fa fa-info-circle';
                        options.type = 'info';
                        break;
                    case NotifyType.Error:
                        options.icon = 'fa fa-exclamation-triangle';
                        options.type = 'error';
                        break;
                    case NotifyType.Success:
                        options.icon = 'fa fa-thumbs-o-up';
                        options.type = 'success';
                        break;
                }
                //var pn = new PNotify(options);
                // var s = new PNotify({
                //     title: 'Non-Blocking Notice',
                //     text: 'I\'m a non-blocking notice with buttons.',
                //
                //     buttons: {
                //         show_on_nonblock: true
                //     }
                // });
                //var stack_bar_top = { "dir1": "down", "dir2": "right", "push": "top", "width": "500px", "spacing1": 0, "spacing2": 0 };
                //var stack_bar_top = { "dir1": "down", "dir2": "right", "push": "top", "firstpos1": 0, "firstpos2": ($(window).width() / 2 - 500) }
                var stack_bar_bottom = { "dir1": "up", "dir2": "right", "spacing1": 0, "spacing2": 0 };
                var opts = {
                    title: title,
                    text: text,
                    cornerclass: 'ui-pnotify-sharp',
                    shadow: false,
                    nonblock: {
                        nonblock: true,
                        nonblock_opacity: .2
                    },
                    // confirm: {
                    //     confirm: true,
                    //     buttons: [{
                    //         buttons: [{
                    //             text: 'Fries',
                    //             addClass: 'btn-primary',
                    //             click: (notice) => {
                    //                 notice.update({
                    //                     title: 'You\'ve Chosen a Side',
                    //                     text: 'You want fries.',
                    //                     icon: true,
                    //                     type: 'info',
                    //                     hide: true,
                    //                     confirm: {
                    //                         confirm: false
                    //                     },
                    //                     buttons: {
                    //                         show_on_nonblock: true,
                    //                         closer: true,
                    //                         sticker: true
                    //                     }
                    //                 });
                    //             }
                    //         }]
                    //     }]
                    // },
                    buttons: {
                        closer: false,
                        sticker: false
                    },
                    type: "info",
                    hide: true
                };
                var PNot = new PNotify(opts);
                this.notifications.push(PNot);
            };
            /**
             * Show a confirm dialog
             * @title           : the title of the notification
             * @text            : the contents of the notification
             * @callback        : the callback that will be called after the confirmation has been answered.
             */
            MessageBusService.prototype.confirm = function (title, text, callback) {
                var options = {
                    title: title,
                    text: text,
                    hide: false,
                    confirm: {
                        confirm: true
                    },
                    buttons: {
                        closer: false,
                        sticker: false
                    },
                    history: {
                        history: false
                    },
                    icon: 'fa fa-question-circle',
                    cornerclass: 'ui-pnotify-sharp',
                    addclass: "stack-topright",
                    stack: { "dir1": "down", "dir2": "left", "firstpos1": 25, "firstpos2": 25 }
                };
                var pn = new PNotify(options).get()
                    .on('pnotify.confirm', function () { callback(true); })
                    .on('pnotify.cancel', function () { callback(false); });
            };
            MessageBusService.prototype.notifyBottom = function (title, text) {
                var stack_bar_bottom = { "dir1": "up", "dir2": "right", "spacing1": 0, "spacing2": 0 };
                var options = {
                    title: "Over Here",
                    text: "Check me out. I'm in a different stack.",
                    addclass: "stack-bar-bottom",
                    cornerclass: "",
                    width: "70%",
                    stack: stack_bar_bottom
                };
                var pn = new PNotify(options);
            };
            /**
             * Publish a notification
             * @title: the title of the notification
             * @text:  the contents of the notification
             */
            MessageBusService.prototype.notifyData = function (data) {
                var pn = new PNotify(data);
                //this.publish("notify", "", data);
            };
            /**
             * Publish to a topic
             */
            MessageBusService.prototype.publish = function (topic, title, data) {
                //window.console.log("publish: " + topic + ", " + title);
                if (!MessageBusService.cache[topic])
                    return;
                MessageBusService.cache[topic].forEach(function (cb) { return cb(title, data); });
            };
            //public publish(topic: string, title: string, data?: any): void {
            //	MessageBusService.publish(topic, title, data);
            //}
            /**
             * Subscribe to a topic
             * @param {string} topic The desired topic of the message.
             * @param {IMessageBusCallback} callback The callback to call.
             */
            MessageBusService.prototype.subscribe = function (topic, callback) {
                if (!MessageBusService.cache[topic])
                    MessageBusService.cache[topic] = new Array();
                MessageBusService.cache[topic].push(callback);
                return new MessageBusHandle(topic, callback);
            };
            /**
             * Unsubscribe to a topic by providing its handle
             */
            MessageBusService.prototype.unsubscribe = function (handle) {
                var topic = handle.topic;
                var callback = handle.callback;
                if (!MessageBusService.cache[topic])
                    return;
                MessageBusService.cache[topic].forEach(function (cb, idx) {
                    if (cb == callback) {
                        MessageBusService.cache[topic].splice(idx, 1);
                        return;
                    }
                });
            };
            MessageBusService.cache = {};
            MessageBusService.$inject = [
                '$translate'
            ];
            return MessageBusService;
        })();
        Services.MessageBusService = MessageBusService;
        var EventObj = (function () {
            function EventObj() {
            }
            // Events primitives ======================
            EventObj.prototype.bind = function (event, fct) {
                this.myEvents = this.myEvents || {};
                this.myEvents[event] = this.myEvents[event] || [];
                this.myEvents[event].push(fct);
            };
            EventObj.prototype.unbind = function (event, fct) {
                this.myEvents = this.myEvents || {};
                if (event in this.myEvents === false)
                    return;
                this.myEvents[event].splice(this.myEvents[event].indexOf(fct), 1);
            };
            EventObj.prototype.unbindEvent = function (event) {
                this.myEvents = this.myEvents || {};
                this.myEvents[event] = [];
            };
            EventObj.prototype.unbindAll = function () {
                this.myEvents = this.myEvents || {};
                for (var event in this.myEvents)
                    this.myEvents[event] = false;
            };
            EventObj.prototype.trigger = function (event) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                this.myEvents = this.myEvents || {};
                if (event in this.myEvents === false)
                    return;
                for (var i = 0; i < this.myEvents[event].length; i++) {
                    this.myEvents[event][i].apply(this, Array.prototype.slice.call(arguments, 1));
                }
            };
            EventObj.prototype.registerEvent = function (evtname) {
                this[evtname] = function (callback, replace) {
                    if (typeof callback == 'function') {
                        if (replace)
                            this.unbindEvent(evtname);
                        this.bind(evtname, callback);
                    }
                    return this;
                };
            };
            EventObj.prototype.registerEvents = function (evtnames) {
                var _this = this;
                evtnames.forEach(function (evtname) {
                    _this.registerEvent(evtname);
                });
            };
            return EventObj;
        })();
        Services.EventObj = EventObj;
        /**
          * Register service
          */
        var moduleName = 'csComp';
        try {
            Services.myModule = angular.module(moduleName);
        }
        catch (err) {
            // named module does not exist, so create one
            Services.myModule = angular.module(moduleName, []);
        }
        Services.myModule.service('messageBusService', csComp.Services.MessageBusService);
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        /** Contains properties needed to describe right panel */
        var RightPanelTab = (function () {
            function RightPanelTab() {
                this.icon = 'tachometer';
                this.popover = '';
            }
            return RightPanelTab;
        })();
        Services.RightPanelTab = RightPanelTab;
        /** service for managing dashboards */
        var DashboardService = (function () {
            function DashboardService($rootScope, $compile, $injector, $location, $timeout, $translate, $messageBusService, $layerService, $mapService) {
                //$translate('FILTER_INFO').then((translation) => console.log(translation));
                // NOTE EV: private props in constructor automatically become fields, so mb and map are superfluous.
                var _this = this;
                this.$rootScope = $rootScope;
                this.$compile = $compile;
                this.$injector = $injector;
                this.$location = $location;
                this.$timeout = $timeout;
                this.$translate = $translate;
                this.$messageBusService = $messageBusService;
                this.$layerService = $layerService;
                this.$mapService = $mapService;
                this.widgetTypes = {};
                //alert('init dashbard');
                this.mainDashboard = new csComp.Services.Dashboard();
                this.dashboards = [];
                this.dashboards["main"] = this.mainDashboard;
                this.$messageBusService.subscribe("dashboard", function (event, id) {
                    //alert(event);
                });
                this.$messageBusService.subscribe("rightpanel", function (event, tab) {
                    switch (event) {
                        case "activate":
                            _this.activateTab(tab);
                            break;
                        case "deactivate":
                            _this.deactivateTab(tab);
                            break;
                        case "deactiveContainer":
                            _this.deactivateTabContainer(tab);
                            break;
                    }
                });
                this.widgetTypes["indicators"] = { id: "indicators", icon: "cs/images/widgets/indicators.png", description: "Showing sensor data using charts" };
                this.widgetTypes["charts"] = { id: "charts", icon: "cs/images/widgets/markdown.png", description: "Show custom chart" };
                this.widgetTypes["markdownwidget"] = { id: "markdownwidget", icon: "cs/images/widgets/markdown.png", description: "Show custom markdown or html content" };
                this.widgetTypes["mcawidget"] = { id: "mcawidget", icon: "cs/images/widgets/mca.png", description: "Show available MCA's" };
                this.widgetTypes["iframewidget"] = { id: "iframewidget", icon: "cs/images/widgets/markdown.png", description: "Show custom iframe" };
                this.widgetTypes["kanbanboard"] = { id: "kanbanboard", icon: "cs/images/widgets/markdown.png", description: "Show kanbanboard" };
                this.widgetTypes["navigator"] = { id: "navigatorwidget", icon: "cs/images/widgets/markdown.png", description: "Show navigator" };
                this.widgetTypes["postman"] = { id: "postman", icon: "cs/images/widgets/Script.png", description: "POST messages" };
                this.widgetTypes["simtimecontroller"] = { id: "simtimecontroller", icon: "cs/images/widgets/Media-Play.png", description: "Show simulation time controller" };
                this.widgetTypes["simstate"] = { id: "simstate", icon: "cs/images/widgets/ServerStatus.png", description: "Show status of simulation services." };
            }
            DashboardService.prototype.leftMenuVisible = function (id) {
                var d = this.$layerService.project.activeDashboard;
                if (!d.visibleLeftMenuItems)
                    return true;
                return (d.visibleLeftMenuItems.indexOf(id) >= 0);
            };
            DashboardService.prototype.selectDashboard = function (dashboard, container) {
                this.$messageBusService.publish('updatelegend', 'removelegend');
                this.$layerService.project.activeDashboard = dashboard;
                this.$messageBusService.publish("dashboard-" + container, "activated", dashboard);
                this.$location.search('dashboard', dashboard.id);
            };
            DashboardService.prototype.activateTab = function (tab) {
                var _this = this;
                if (!tab.hasOwnProperty("container"))
                    return;
                this.$layerService.visual.rightPanelVisible = true;
                var content = tab.container + "-content";
                $("#" + tab.container + "-tab").remove();
                var c = $("#" + content);
                try {
                    if (c)
                        c.remove();
                }
                catch (e) {
                }
                var popoverString = '';
                if (tab.popover !== '' && (this.$mapService.expertMode === Services.Expertise.Beginner || this.$mapService.expertMode === Services.Expertise.Intermediate)) {
                    popoverString = "popover='" + tab.popover + "' popover-placement='left' popover-trigger='mouseenter' popover-append-to-body='true'";
                }
                $("#rightpanelTabs").append(this.$compile("<li id='" + tab.container + "-tab' class='rightPanelTab rightPanelTabAnimated' " + popoverString + "><a id='" + tab.container + "-tab-a' href='#" + content + "' data-toggle='tab'><span class='fa fa-" + tab.icon + " fa-lg'></span></a></li>")(this.$rootScope));
                $("#rightpanelTabPanes").append("<div class='tab-pane' style='width:355px' id='" + content + "'></div>");
                $("#" + tab.container + "-tab-a").click(function () {
                    _this.$layerService.visual.rightPanelVisible = true;
                    console.log('rp visible');
                    _this.$rootScope.$apply();
                });
                var newScope = this.$rootScope;
                newScope.data = tab.data;
                var widgetElement = this.$compile("<" + tab.directive + "></" + tab.directive + ">")(newScope);
                $("#" + content).append(widgetElement);
                $("#rightpanelTabs a[href='#" + content + "']").tab('show');
            };
            DashboardService.prototype.deactivateTabContainer = function (container) {
                this.$layerService.visual.rightPanelVisible = false;
                var content = container + "-content";
                $("#" + container + "-tab").remove();
                try {
                    var c = $("#" + content);
                    if (c) {
                        //var s = (<any>c).scope();
                        c.remove();
                    }
                }
                catch (e) { }
            };
            DashboardService.prototype.deactivateTab = function (tab) {
                if (!tab.hasOwnProperty("container"))
                    return;
                this.deactivateTabContainer(tab.container);
            };
            DashboardService.prototype.editWidget = function (widget) {
                this.activeWidget = widget;
                this.editWidgetMode = true;
                var rpt = csComp.Helpers.createRightPanelTab('widget', 'widgetedit', widget, 'Edit widget', 'Edit widget', 'th-large');
                this.$messageBusService.publish('rightpanel', 'activate', rpt);
                // call widgetctrl edit function
                if (widget._ctrl)
                    widget._ctrl.startEdit();
                // check if editor exists
                if (this.$injector.has(widget.directive + 'EditDirective')) {
                    var rptc = csComp.Helpers.createRightPanelTab('widget-content', widget.directive + "-edit", widget, 'Edit widget', 'Edit widget', 'cog');
                    this.$messageBusService.publish('rightpanel', 'activate', rptc);
                }
                //(<any>$('#leftPanelTab a[href="#widgetedit"]')).tab('show'); // Select tab by name
            };
            DashboardService.prototype.stopEditWidget = function () {
                this.activeWidget = null;
                this.editWidgetMode = false;
                //this.$layerService.visual.rightPanelVisible = false;
                $("#widgetEdit").removeClass('active');
            };
            DashboardService.prototype.removeWidget = function () {
                var _this = this;
                if (this.activeWidget && this.mainDashboard) {
                    this.mainDashboard.widgets = this.mainDashboard.widgets.filter(function (w) { return w.id != _this.activeWidget.id; });
                    this.activeWidget = null;
                    $('#leftPanelTab a[href="#basewidgets"]').tab('show'); // Select tab by name
                }
            };
            DashboardService.$inject = [
                '$rootScope',
                '$compile',
                '$injector',
                '$location',
                '$timeout',
                '$translate',
                'messageBusService',
                'layerService',
                'mapService',
            ];
            return DashboardService;
        })();
        Services.DashboardService = DashboardService;
        /**
          * Register service
          */
        var moduleName = 'csComp';
        try {
            Services.myModule = angular.module(moduleName);
        }
        catch (err) {
            // named module does not exist, so create one
            Services.myModule = angular.module(moduleName, []);
        }
        Services.myModule.service('dashboardService', csComp.Services.DashboardService);
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        'use strict';
        var Coordinates = (function () {
            function Coordinates() {
            }
            return Coordinates;
        })();
        Services.Coordinates = Coordinates;
        var Geoposition = (function () {
            function Geoposition() {
            }
            return Geoposition;
        })();
        Services.Geoposition = Geoposition;
        var GeoService = (function () {
            function GeoService(bus, $rootScope, $window, $q) {
                this.bus = bus;
                this.$rootScope = $rootScope;
                this.$window = $window;
                this.$q = $q;
                this.geolocation_msgs = {
                    'errors.location.unsupportedBrowser': 'Browser does not support location services',
                    'errors.location.permissionDenied': 'You have rejected access to your location',
                    'errors.location.positionUnavailable': 'Unable to determine your location',
                    'errors.location.timeout': 'Service timeout has been reached'
                };
            }
            GeoService.prototype.getLocation = function () {
                return this.position;
            };
            GeoService.prototype.start = function (opts) {
                var _this = this;
                if (!opts) {
                    opts = {
                        enableHighAccuracy: true,
                        maximumAge: 3000
                    };
                }
                if (this.$window.navigator && this.$window.navigator.geolocation) {
                    this.$window.navigator.geolocation.watchPosition(function (position) {
                        _this.position = position;
                        _this.bus.publish('geo', 'pos', position);
                    }, function (error) {
                        alert(error);
                        switch (error.code) {
                            case 1:
                                // this.$rootScope.$broadcast('error', this.geolocation_msgs['errors.location.permissionDenied']);
                                // this.$rootScope.$apply(function() {
                                //     deferred.reject(this.geolocation_msgs['errors.location.permissionDenied']);
                                // });
                                break;
                            case 2:
                                // this.$rootScope.$broadcast('error', this.geolocation_msgs['errors.location.positionUnavailable']);
                                // this.$rootScope.$apply(function() {
                                //     deferred.reject(this.geolocation_msgs['errors.location.positionUnavailable']);
                                // });
                                break;
                            case 3:
                                // this.$rootScope.$broadcast('error', this.geolocation_msgs['errors.location.timeout']);
                                // this.$rootScope.$apply(function() {
                                //     deferred.reject(this.geolocation_msgs['errors.location.timeout']);
                                // });
                                break;
                        }
                    }, opts);
                }
                else {
                }
                return;
            };
            GeoService.$inject = [
                'messageBusService',
                '$rootScope',
                '$window',
                '$q'
            ];
            return GeoService;
        })();
        Services.GeoService = GeoService;
        /**
          * Register service
          */
        var moduleName = 'csComp';
        try {
            Services.myModule = angular.module(moduleName);
        }
        catch (err) {
            // named module does not exist, so create one
            Services.myModule = angular.module(moduleName, []);
        }
        Services.myModule.service('geoService', csComp.Services.GeoService);
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

var ContourAction;
(function (ContourAction) {
    var ContourActionModel = (function () {
        function ContourActionModel() {
            this.id = 'ContourActionModel';
        }
        ContourActionModel.prototype.stop = function () { };
        ContourActionModel.prototype.addFeature = function (feature) { };
        ContourActionModel.prototype.removeFeature = function (feature) { };
        ContourActionModel.prototype.selectFeature = function (feature) { };
        ContourActionModel.prototype.getFeatureActions = function (feature) {
            return [];
        };
        ContourActionModel.prototype.getFeatureHoverActions = function (feature) {
            if (!feature)
                return [];
            var showContourOption = {
                title: "show"
            };
            showContourOption.callback = this.showContour;
            var hideContourOption = {
                title: "hide"
            };
            hideContourOption.callback = this.hideContour;
            return [showContourOption, hideContourOption];
        };
        ContourActionModel.prototype.deselectFeature = function (feature) { };
        ContourActionModel.prototype.updateFeature = function (feuture) { };
        ContourActionModel.prototype.showContour = function (feature, layerService) {
            if (layerService.currentContour)
                layerService.map.map.removeLayer(layerService.currentContour); //remove old contour first
            var fType = layerService.getFeatureType(feature);
            if (fType && fType.hasOwnProperty('contourProperty') && feature.properties.hasOwnProperty(fType['contourProperty'])) {
                var geoContour = JSON.parse(feature.properties[fType.contourProperty]);
                layerService.currentContour = L.geoJson(geoContour);
                layerService.currentContour.addTo(layerService.map.map);
            }
        };
        ContourActionModel.prototype.hideContour = function (feature, layerService) {
            if (layerService.currentContour)
                layerService.map.map.removeLayer(layerService.currentContour); //remove contour
        };
        ContourActionModel.prototype.init = function (layerService) {
            console.log('init ContourActionService');
        };
        return ContourActionModel;
    })();
    ContourAction.ContourActionModel = ContourActionModel;
})(ContourAction || (ContourAction = {}));

var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        'use strict';
        var LayerActions = (function () {
            function LayerActions() {
                this.id = 'LayerActions';
            }
            LayerActions.prototype.stop = function () { };
            LayerActions.prototype.addFeature = function (feature) { };
            LayerActions.prototype.removeFeature = function (feature) { };
            LayerActions.prototype.selectFeature = function (feature) { };
            LayerActions.prototype.getFeatureActions = function (feature) {
                if (feature.layer.isDynamic) {
                    var setFilterActionOption = {
                        title: "Edit"
                    };
                    setFilterActionOption.callback = this.setAsFilter;
                    return [setFilterActionOption];
                }
                else {
                    return [];
                }
            };
            LayerActions.prototype.getFeatureHoverActions = function (feature) {
                return [];
            };
            LayerActions.prototype.deselectFeature = function (feature) { };
            LayerActions.prototype.updateFeature = function (feuture) { };
            LayerActions.prototype.setAsFilter = function (feature, layerService) {
                layerService.editFeature(feature);
            };
            LayerActions.prototype.init = function (layerService) {
                console.log('init LayerActions');
                this.layerService = layerService;
            };
            return LayerActions;
        })();
        Services.LayerActions = LayerActions;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        'use strict';
        (function (ActionType) {
            ActionType[ActionType["Context"] = 0] = "Context";
            ActionType[ActionType["Hover"] = 1] = "Hover";
        })(Services.ActionType || (Services.ActionType = {}));
        var ActionType = Services.ActionType;
        /** layer service is responsible for reading and managing all project, layer and sensor related data */
        var LayerService = (function () {
            function LayerService($location, $compile, $translate, $messageBusService, $mapService, $rootScope, geoService, $http) {
                var _this = this;
                this.$location = $location;
                this.$compile = $compile;
                this.$translate = $translate;
                this.$messageBusService = $messageBusService;
                this.$mapService = $mapService;
                this.$rootScope = $rootScope;
                this.geoService = geoService;
                this.$http = $http;
                /** layers that are currently active */
                this.loadedLayers = new csComp.Helpers.Dictionary();
                this.actionServices = [];
                this.visual = new Services.VisualState();
                //$translate('FILTER_INFO').then((translation) => console.log(translation));
                // NOTE EV: private props in constructor automatically become fields, so mb and map are superfluous.
                this.mb = $messageBusService;
                this.map = $mapService;
                this.openSingleProject = false;
                this.emptySolutionUrl = 'data/api/defaultSolution.json';
                this.accentColor = '';
                this.title = '';
                this.typesResources = {};
                this._featureTypes = {};
                this.propertyTypeData = {};
                this.selectedFeatures = [];
                this.currentLocale = $translate.preferredLanguage();
                // init map renderers
                this.mapRenderers = {};
                this.visual = new Services.VisualState();
                // add renderers
                this.mapRenderers["leaflet"] = new Services.LeafletRenderer();
                this.mapRenderers["leaflet"].init(this);
                this.mapRenderers["cesium"] = new Services.CesiumRenderer();
                this.mapRenderers["cesium"].init(this);
                this.initLayerSources();
                this.throttleTimelineUpdate = _.throttle(this.updateAllLogs, 500);
                $messageBusService.subscribe('timeline', function (trigger) {
                    switch (trigger) {
                        case 'focusChange':
                            _this.updateSensorData();
                            _this.throttleTimelineUpdate();
                            //this.updateAllLogs();
                            break;
                    }
                });
                $messageBusService.subscribe('language', function (title, language) {
                    switch (title) {
                        case 'newLanguage':
                            _this.currentLocale = language;
                            $messageBusService.notifyWithTranslation('LAYER_SERVICE.RELOAD_PROJECT_TITLE', 'LAYER_SERVICE.RELOAD_PROJECT_MSG');
                            _this.openProject(_this.projectUrl);
                            break;
                    }
                });
                $messageBusService.subscribe('mapbbox', function (title, bbox) {
                    if (title === "update") {
                        for (var l in _this.loadedLayers) {
                            var layer = _this.loadedLayers[l];
                            if (layer.refreshBBOX) {
                                layer.BBOX = bbox;
                                layer.layerSource.refreshLayer(layer);
                            }
                        }
                    }
                });
                $messageBusService.subscribe("geo", function (action, loc) {
                    switch (action) {
                        case "pos":
                            //alert(loc.coords.latitude + " - " + loc.coords.longitude);
                            break;
                    }
                });
                //this.geoService.start();
                this.addActionService(new Services.LayerActions());
                var delayFocusChange = _.throttle(function (date) {
                    for (var l in _this.loadedLayers) {
                        var layer = _this.loadedLayers[l];
                        if (layer.timeDependent) {
                            layer.layerSource.refreshLayer(layer);
                        }
                    }
                }, 1000);
                $messageBusService.subscribe("timeline", function (action, date) {
                    if (action === "focusChange") {
                        delayFocusChange(date);
                    }
                });
            }
            LayerService.prototype.getActions = function (feature, type) {
                if (!feature || typeof type !== 'number')
                    return;
                var options = [];
                if (type === ActionType.Context) {
                    this.actionServices.forEach(function (as) {
                        var asOptions = as.getFeatureActions(feature);
                        if (asOptions)
                            options = options.concat(asOptions);
                    });
                    options.forEach(function (a) {
                        a.feature = feature;
                    });
                }
                else if (type === ActionType.Hover) {
                    this.actionServices.forEach(function (as) {
                        var asOptions = as.getFeatureHoverActions(feature);
                        if (asOptions)
                            options = options.concat(asOptions);
                    });
                    options.forEach(function (a) {
                        a.feature = feature;
                    });
                }
                return options;
            };
            LayerService.prototype.addActionService = function (as) {
                var asAlreadyExists = false;
                this.actionServices.some(function (actServ) {
                    if (actServ.id === as.id) {
                        asAlreadyExists = true;
                        return true;
                    }
                    return false;
                });
                if (asAlreadyExists) {
                    console.log('Actionservice ' + as.id + ' already exists.');
                }
                else {
                    this.actionServices.push(as);
                    as.init(this);
                }
            };
            LayerService.prototype.removeActionService = function (as) {
                as.stop();
            };
            /** Find a dashboard by ID */
            LayerService.prototype.findDashboardById = function (dashboardId) {
                var dashboard;
                this.project.dashboards.some(function (d) {
                    if (d.id !== dashboardId)
                        return false;
                    dashboard = d;
                    return true;
                });
                return dashboard;
            };
            /** Find a widget by ID, optionally supplying its parent dashboard id. */
            LayerService.prototype.findWidgetById = function (widgetId, dashboardId) {
                var dashboard;
                var widget;
                if (dashboardId) {
                    dashboard = this.findDashboardById(dashboardId);
                    if (!dashboard)
                        return null;
                    dashboard.widgets.some(function (w) {
                        if (w.id !== widgetId)
                            return false;
                        widget = w;
                        return true;
                    });
                }
                else {
                    this.project.dashboards.some(function (d) {
                        d.widgets.some(function (w) {
                            if (w.id !== widgetId)
                                return false;
                            widget = w;
                            return true;
                        });
                        if (!widget)
                            return false;
                        return true;
                    });
                }
                return widget;
            };
            /**
             * Initialize the available layer sources
             */
            LayerService.prototype.initLayerSources = function () {
                // init layer sources
                this.layerSources = {};
                // add a topo/geojson source
                var geojsonsource = new Services.GeoJsonSource(this, this.$http);
                this.layerSources["geojson"] = geojsonsource;
                this.layerSources["topojson"] = geojsonsource;
                this.layerSources["dynamicgeojson"] = new Services.DynamicGeoJsonSource(this, this.$http);
                this.layerSources["esrijson"] = new Services.EsriJsonSource(this, this.$http);
                // add kml source
                var kmlDataSource = new Services.KmlDataSource(this, this.$http);
                this.layerSources["kml"] = kmlDataSource;
                this.layerSources["gpx"] = kmlDataSource;
                // add wms source
                this.layerSources["wms"] = new Services.WmsSource(this);
                //add tile layer
                this.layerSources["tilelayer"] = new Services.TileLayerSource(this);
                //add heatmap layer
                this.layerSources["heatmap"] = new Services.HeatmapSource(this);
                //add hierarchy layer
                this.layerSources["hierarchy"] = new Services.HierarchySource(this, this.$http);
                //add grid layer
                this.layerSources["grid"] = new Services.GridDataSource(this, this.$http);
                //add day or night data source
                this.layerSources["daynight"] = new Services.NightDayDataSource(this, this.$http);
                // add RSS data source
                this.layerSources["rss"] = new Services.RssDataSource(this, this.$http);
                // add Database data source
                this.layerSources["database"] = new Services.DatabaseSource(this);
                // check for every feature (de)select if layers should automatically be activated
                this.checkFeatureSubLayers();
            };
            LayerService.prototype.removeSubLayers = function (feature) {
                var _this = this;
                if (!feature || !feature.fType)
                    return;
                var props = csComp.Helpers.getPropertyTypes(feature.fType, this.propertyTypeData);
                props.forEach(function (prop) {
                    if (prop.type === "layer" && feature.properties.hasOwnProperty(prop.label)) {
                        var l = feature.properties[prop.label];
                        if (_this.loadedLayers.containsKey(l)) {
                            var layer = _this.loadedLayers[l];
                            _this.removeLayer(_this.loadedLayers[l], true);
                        }
                    }
                });
            };
            /**
            check for every feature (de)select if layers should automatically be activated
            */
            LayerService.prototype.checkFeatureSubLayers = function () {
                var _this = this;
                this.$messageBusService.subscribe('feature', function (action, feature) {
                    if (!feature || !feature.fType)
                        return;
                    var props = csComp.Helpers.getPropertyTypes(feature.fType, _this.propertyTypeData);
                    switch (action) {
                        case 'onFeatureDeselect':
                            // check sub-layers
                            break;
                        case 'onFeatureSelect':
                            // check sub-layers
                            props.forEach(function (prop) {
                                if (prop.type === "matrix" && prop.activation === "automatic" && feature.properties.hasOwnProperty(prop.label)) {
                                    var matrix = feature.properties[prop.label];
                                    _this.project.features.forEach(function (f) {
                                        if (f.layer == feature.layer && f.properties.hasOwnProperty(prop.targetid) && matrix.hasOwnProperty(f.properties[prop.targetid])) {
                                            var newValue = matrix[f.properties[prop.targetid]];
                                            for (var val in newValue) {
                                                f.properties[val] = newValue[val];
                                            }
                                        }
                                    });
                                    _this.updateGroupFeatures(feature.layer.group);
                                }
                                if (prop.type === "layer" && feature.properties.hasOwnProperty(prop.label)) {
                                    if (prop.activation === "automatic")
                                        _this.removeSubLayers(feature.layer.lastSelectedFeature);
                                    feature.layer.lastSelectedFeature = feature;
                                    var l = feature.properties[prop.label];
                                    var pl = _this.findLayer(l);
                                    if (pl) {
                                        _this.addLayer(pl);
                                    }
                                    else {
                                        if (typeof l === 'string') {
                                            pl = new Services.ProjectLayer();
                                            pl.url = l;
                                        }
                                        else {
                                            pl = l;
                                        }
                                        if (!pl.id)
                                            pl.id = l;
                                        if (!pl.group) {
                                            pl.group = feature.layer.group;
                                        }
                                        else {
                                            if (typeof pl.group === 'string') {
                                                pl.group = _this.findGroupById(pl.group);
                                            }
                                        }
                                        if (!pl.type)
                                            pl.type = feature.layer.type;
                                        if (!pl.title)
                                            pl.title = feature.properties["Name"] + " " + prop.title;
                                        if (!pl.defaultFeatureType)
                                            pl.defaultFeatureType = "link";
                                        //pl.parentFeature = feature;
                                        pl.group.layers.push(pl);
                                    }
                                    _this.addLayer(pl);
                                }
                            });
                            break;
                    }
                });
            };
            LayerService.prototype.loadRequiredLayers = function (layer) {
                var _this = this;
                // find layer source, and activate layer
                var layerSource = layer.type.toLowerCase();
                // if a layer is depends on other layers, load those first
                if (this.layerSources.hasOwnProperty(layerSource)) {
                    if (this.layerSources[layerSource].requiresLayer) {
                        var requiredLayers = this.layerSources[layerSource].getRequiredLayers(layer) || [];
                        requiredLayers.forEach(function (l) {
                            _this.addLayer(l);
                        });
                    }
                }
            };
            LayerService.prototype.addLayer = function (layer, layerloaded) {
                var _this = this;
                if (this.loadedLayers.containsKey(layer.id) && (!layer.quickRefresh || layer.quickRefresh == false))
                    return;
                if (layer.isLoading)
                    return;
                layer.isLoading = true;
                this.$messageBusService.publish('layer', 'loading', layer);
                var disableLayers = [];
                async.series([
                    function (callback) {
                        // check if in this group only one layer can be active
                        // make sure all existising active layers are disabled
                        if (layer.group.oneLayerActive) {
                            layer.group.layers.forEach(function (l) {
                                if (l.id !== layer.id && l.enabled) {
                                    disableLayers.push(l);
                                }
                            });
                        }
                        callback(null, null);
                    },
                    function (callback) {
                        console.log('loading types : ' + layer.typeUrl);
                        if (layer.typeUrl) {
                            _this.loadTypeResources(layer.typeUrl, layer.dynamicResource || false, function () { return callback(null, null); });
                        }
                        else {
                            callback(null, null);
                        }
                    },
                    function (callback) {
                        // load required feature layers, if applicable
                        _this.loadRequiredLayers(layer);
                        // find layer source, and activate layer
                        var layerSource = layer.type.toLowerCase();
                        if (!_this.layerSources.hasOwnProperty(layerSource)) {
                            // We don't know how to deal with an unknown layer source, so stop here.
                            layer.isLoading = false;
                            callback(null, null);
                            // TODO Stop spinner
                            return;
                        }
                        layer.layerSource = _this.layerSources[layerSource];
                        // load layer from source
                        if (layer.type === 'database') {
                            _this.$messageBusService.serverSubscribe(layer.id, "layer", function (sub, msg) {
                                console.log(msg);
                                if (msg.action === "layer-update") {
                                    if (!msg.data.group) {
                                        msg.data.group = _this.findGroupByLayerId(msg.data);
                                    }
                                    _this.addLayer(msg.data, function () { });
                                }
                            });
                        }
                        layer.layerSource.addLayer(layer, function (l) {
                            if (layerloaded)
                                layerloaded(layer);
                            if (l.enabled) {
                                _this.loadedLayers[layer.id] = l;
                                _this.updateSensorData();
                                _this.updateAllLogs();
                                _this.activeMapRenderer.addLayer(layer);
                                if (layer.defaultLegendProperty)
                                    _this.checkLayerLegend(layer, layer.defaultLegendProperty);
                                _this.checkLayerTimer(layer);
                                //this.$messageBusService.publish('layer', 'activated', layer);
                                _this.$messageBusService.publish('updatelegend', 'updatedstyle');
                            }
                            _this.$messageBusService.publish('layer', 'activated', layer);
                        });
                        _this.$messageBusService.publish("timeline", "updateFeatures");
                        callback(null, null);
                    },
                    function (callback) {
                        // now remove the layers that need to be disabled
                        disableLayers.forEach(function (l) {
                            _this.removeLayer(l);
                            l.enabled = false;
                        });
                        callback(null, null);
                    }
                ]);
            };
            LayerService.prototype.expandGroup = function (layer) {
                // expand the group in the layerlist if it is collapsed
                if (!layer || !layer.group)
                    return;
                var id = "#layergroup_" + layer.group.id;
                $(id).collapse("show");
                $('*[data-target="' + id + '"]').removeClass('collapsed');
                //(<any>$('div#layergroupStyle')).removeClass('collapsed');
                //
                if (this.$rootScope.$root.$$phase != '$apply' && this.$rootScope.$root.$$phase != '$digest') {
                    this.$rootScope.$apply();
                }
            };
            LayerService.prototype.collapseAll = function () {
                this.project.groups.forEach(function (g) {
                    var layerEnabled = false;
                    g.layers.some(function (l) {
                        if (l.enabled)
                            layerEnabled = true;
                        return l.enabled;
                    });
                    if (!layerEnabled) {
                        var id = "#layergroup_" + g.id;
                        $(id).collapse("hide");
                        $('*[data-target="' + id + '"]').addClass('collapsed');
                    }
                });
            };
            LayerService.prototype.expandAll = function () {
                this.project.groups.forEach(function (g) {
                    var id = "#layergroup_" + g.id;
                    if (!$(id).hasClass("in")) {
                        $(id).collapse("show");
                        $('*[data-target="' + id + '"]').removeClass('collapsed');
                    }
                });
            };
            /** load external type resource for a project or layer */
            LayerService.prototype.loadTypeResources = function (url, requestReload, callback) {
                var _this = this;
                if (url) {
                    // todo check for list of type resources
                    if (typeof url === 'string') {
                        if (!this.typesResources.hasOwnProperty(url) || requestReload) {
                            var success = false;
                            this.$http.get(url)
                                .success(function (resource) {
                                success = true;
                                resource.url = url;
                                _this.initTypeResources(resource);
                                _this.$messageBusService.publish("typesource", url, resource);
                                callback();
                            })
                                .error(function (err) {
                                _this.$messageBusService.notify('ERROR loading TypeResources', 'While loading: ' + url);
                                console.log(err);
                            });
                            setTimeout(function () {
                                if (!success) {
                                    callback();
                                }
                            }, 3000);
                        }
                        else {
                            //make sure featureTypes in typeResources are initialized,
                            //which is not the case when switching projects
                            this.initTypeResources(this.typesResources[url]);
                            callback();
                        }
                    }
                    else {
                        callback();
                    }
                }
            };
            /**
             * returns a list of all project layers in all groups
             */
            LayerService.prototype.allLayers = function () {
                var res = [];
                if (this.project == null || this.project.groups == null)
                    return [];
                this.project.groups.forEach(function (p) {
                    if (p.layers)
                        res = res.concat(p.layers);
                });
                return res;
            };
            /** add a types resource (project, resource file or layer) */
            LayerService.prototype.initTypeResources = function (source) {
                this.typesResources[source.url] = source;
                if (!source.title)
                    source.title = source.url;
                var featureTypes = source.featureTypes;
                if (featureTypes) {
                    for (var typeName in featureTypes) {
                        var tn = source.url + "#" + typeName;
                        //if (!this._featureTypes.hasOwnProperty(tn)) continue;
                        var featureType = featureTypes[typeName];
                        featureType.id = tn;
                        this.initFeatureType(featureType);
                        this._featureTypes[tn] = featureType;
                    }
                }
                if (source.propertyTypeData) {
                    for (var key in source.propertyTypeData) {
                        var propertyType = source.propertyTypeData[key];
                        this.initPropertyType(propertyType);
                        if (!propertyType.label)
                            propertyType.label = key;
                        this.propertyTypeData[key] = propertyType;
                    }
                }
            };
            LayerService.prototype.checkLayerLegend = function (layer, property) {
                var _this = this;
                var ptd = this.propertyTypeData[property];
                if (ptd && ptd.legend) {
                    var gs;
                    if (layer.group.styles && (layer.group.styles.length > 0)) {
                        gs = layer.group.styles[0]; // TODO: when do we need a different one than the first?
                    }
                    else {
                        gs = new Services.GroupStyle(this.$translate);
                        layer.group.styles.push(gs);
                    }
                    gs.title = ptd.title;
                    gs.id = csComp.Helpers.getGuid();
                    gs.activeLegend = ptd.legend;
                    gs.group = layer.group;
                    gs.property = ptd.label;
                    gs.legends[ptd.title] = ptd.legend;
                    gs.colorScales[ptd.title] = ['purple', 'purple'];
                    gs.enabled = true;
                    gs.visualAspect = (ptd.legend.visualAspect)
                        ? ptd.legend.visualAspect
                        : 'strokeColor'; // TODO: let this be read from the propertyTypeData
                    this.saveStyle(layer.group, gs);
                    this.project.features.forEach(function (fe) {
                        if (fe.layer === layer) {
                            _this.calculateFeatureStyle(fe);
                            _this.activeMapRenderer.updateFeature(fe);
                        }
                    });
                    // upon deactivation of the layer? (but other layers can also have active styles)
                    this.mb.publish('updatelegend', 'title', property);
                }
                else {
                    //when no layer is defined, set the given propertytype as styled property (and trigger creating a dynamic legend subsequently)
                    this.project.features.some(function (f) {
                        if (f.properties.hasOwnProperty(property)) {
                            var pt = _this.getPropertyType(f, property);
                            _this.setStyle({ feature: f, property: property, key: pt.title || property });
                            return true;
                        }
                        return false;
                    });
                }
            };
            /**
             * Check whether we need to enable the timer to refresh the layer.
             */
            LayerService.prototype.checkLayerTimer = function (layer) {
                if (!layer.refreshTimeInterval)
                    return;
                if (layer.enabled) {
                    if (!layer.timerToken) {
                        layer.timerToken = setInterval(function () {
                            layer.layerSource.refreshLayer(layer);
                        }, layer.refreshTimeInterval * 1000);
                        console.log("Timer started for " + layer.title + ": " + layer.timerToken);
                    }
                }
                else if (layer.timerToken) {
                    clearInterval(layer.timerToken);
                    layer.timerToken = null;
                }
            };
            LayerService.prototype.removeStyle = function (style) {
                var g = style.group;
                g.styles = g.styles.filter(function (s) { return s.id !== style.id; });
                this.$messageBusService.publish('updatelegend', 'updatedstyle');
                this.updateGroupFeatures(g);
            };
            LayerService.prototype.updatePropertyStyle = function (k, v, parent) {
                // method of class LayerService
                /* k, v is key-value pair of style.colorScales => key is a string */
                /* value is in most cases a list of two strings. actually it is not used in this function */
                /* parent is a ??which class??  ($parent in stylelist.tpl.html) */
                //alert('key = ' + k + '; value = ' + v);
                var l;
                l = parent.style.legends[k];
                if (l && (l.legendEntries.length > 0)) {
                    var e1 = l.legendEntries[0];
                    var e2 = l.legendEntries[l.legendEntries.length - 1];
                    parent.style.colors = [e1.color, e2.color];
                }
                else {
                    parent.style.colors = v;
                }
                parent.style.activeLegend = l;
                this.$messageBusService.publish('updatelegend', 'updatedstyle');
            };
            LayerService.prototype.updateStyle = function (style) {
                //console.log('update style ' + style.title);
                if (style == null)
                    return;
                if (style.property && style.property === 'gridlayer') {
                    if (!style.group || !style.group.layers)
                        return;
                    style.group.layers.forEach(function (l) {
                        if (l.mapLayer && l.enabled) {
                            var mapLayers = l.mapLayer.getLayers();
                            mapLayers.forEach(function (ml) {
                                if (ml.redraw && typeof ml.redraw === 'function') {
                                    ml.params({ minColor: style.colors[0], maxColor: style.colors[1], areColorsUpdated: true });
                                    ml.redraw();
                                }
                            });
                        }
                    });
                }
                else {
                    if (style.group != null && style.group.styles[0] != null) {
                        if (style.group.styles[0].fixedColorRange) {
                            style.info = style.group.styles[0].info;
                        }
                        else {
                            style.info = this.calculatePropertyInfo(style.group, style.property);
                        }
                        style.canSelectColor = style.visualAspect.toLowerCase().indexOf('color') > -1;
                        this.updateGroupFeatures(style.group);
                    }
                }
            };
            LayerService.prototype.updateGroupFeatures = function (group) {
                var _this = this;
                if (!group)
                    return;
                this.project.features.forEach(function (f) {
                    if (f.layer.group == group) {
                        _this.calculateFeatureStyle(f);
                        _this.activeMapRenderer.updateFeature(f);
                    }
                });
            };
            /** Recompute the style of the layer features, e.g. after changing the opacity. */
            LayerService.prototype.updateLayerFeatures = function (layer) {
                var _this = this;
                if (!layer)
                    return;
                this.project.features.forEach(function (f) {
                    if (f.layer.id === layer.id) {
                        _this.calculateFeatureStyle(f);
                        _this.activeMapRenderer.updateFeature(f);
                    }
                });
            };
            LayerService.prototype.updateCanvasOverlay = function (layer) {
                if (!layer || !layer.mapLayer)
                    return;
                var mapLayers = layer.mapLayer.getLayers();
                mapLayers.forEach(function (ml) {
                    if (ml.redraw && typeof ml.redraw === 'function') {
                        var layerOpacity = (+layer.opacity) / 100;
                        layerOpacity = Math.min(1, Math.max(0, layerOpacity)); //set bounds to 0 - 1
                        ml.params({ opacity: layerOpacity });
                        ml.redraw();
                    }
                });
            };
            LayerService.prototype.updateFeatureTypes = function (featureType) {
                var _this = this;
                this.project.features.forEach(function (f) {
                    if (f.featureTypeName === featureType.id) {
                        _this.calculateFeatureStyle(f);
                        _this.activeMapRenderer.updateFeature(f);
                    }
                });
            };
            LayerService.prototype.selectRenderer = function (renderer) {
                if (this.activeMapRenderer && this.activeMapRenderer.title === renderer)
                    return;
                if (this.activeMapRenderer)
                    this.activeMapRenderer.disable();
                if (this.mapRenderers.hasOwnProperty(renderer)) {
                    this.activeMapRenderer = this.mapRenderers[renderer];
                    this.activeMapRenderer.enable();
                }
            };
            LayerService.prototype.editFeature = function (feature) {
                feature.gui["editMode"] = true;
                this.selectFeature(feature);
            };
            LayerService.prototype.deselectFeature = function (feature) {
                feature.isSelected = false;
                this.calculateFeatureStyle(feature);
                this.activeMapRenderer.updateFeature(feature);
            };
            LayerService.prototype.selectFeature = function (feature, multi, force) {
                var _this = this;
                if (multi === void 0) { multi = false; }
                if (force === void 0) { force = false; }
                if (force) {
                    feature.isSelected = true;
                }
                else
                    feature.isSelected = !feature.isSelected;
                feature.gui['title'] = csComp.Helpers.getFeatureTitle(feature);
                this.actionServices.forEach(function (as) {
                    if (feature.isSelected) {
                        as.selectFeature(feature);
                    }
                    else {
                        as.deselectFeature(feature);
                    }
                });
                // deselect last feature and also update
                if (this.lastSelectedFeature != null && this.lastSelectedFeature !== feature && !multi) {
                    this.deselectFeature(this.lastSelectedFeature);
                    this.$messageBusService.publish('feature', 'onFeatureDeselect', this.lastSelectedFeature);
                }
                if (feature.isSelected)
                    this.lastSelectedFeature = feature;
                // select new feature, set selected style and bring to front
                this.calculateFeatureStyle(feature);
                this.activeMapRenderer.updateFeature(feature);
                if (multi) {
                    if (feature.isSelected) {
                        if (this.selectedFeatures.indexOf(feature) === -1) {
                            this.selectedFeatures.push(feature);
                        }
                    }
                    else {
                        if (this.selectedFeatures.indexOf(feature) >= 0) {
                            this.selectedFeatures = this.selectedFeatures.filter(function (f) { return f.id !== feature.id; });
                        }
                    }
                }
                else {
                    this.selectedFeatures.forEach(function (f) { if (f != feature)
                        _this.deselectFeature(f); });
                    this.selectedFeatures = (feature.isSelected) ? [feature] : [];
                }
                if (!feature.isSelected) {
                    this.$messageBusService.publish('feature', 'onFeatureDeselect', feature);
                }
                else {
                    // var rpt = csComp.Helpers.createRightPanelTab('featurerelations', 'featurerelations', feature, 'Related features', '{{"RELATED_FEATURES" | translate}}', 'link');
                    // this.$messageBusService.publish('rightpanel', 'activate', rpt);
                    // var rpt = csComp.Helpers.createRightPanelTab('featureprops', 'featureprops', feature, 'Selected feature', '{{"FEATURE_INFO" | translate}}', 'info');
                    // this.$messageBusService.publish('rightpanel', 'activate', rpt);
                    this.$messageBusService.publish('feature', 'onFeatureSelect', feature);
                }
            };
            LayerService.prototype.updateAllLogs = function () {
                var _this = this;
                if (this.project == null || this.project.timeLine == null || this.project.features == null)
                    return;
                this.project.features.forEach(function (f) {
                    if (f.layer.isDynamic && f.layer.useLog) {
                        //if (f.gui.hasOwnProperty("lastUpdate") && this.project.timeLine.focusDate < f.gui["lastUpdate"])
                        _this.updateLog(f);
                    }
                });
            };
            LayerService.prototype.lookupLog = function (logs, timestamp) {
                if (!logs || logs.length == 0)
                    return {};
                var d = logs; //_.sortBy(logs, 'ts');
                if (timestamp <= d[0].ts)
                    return d[0];
                if (timestamp >= d[logs.length - 1].ts)
                    return d[d.length - 1];
                var res = {};
                for (var i = 0; i < d.length; i++) {
                    if (d[i].ts > timestamp) {
                        res = d[i];
                        break;
                    }
                }
                return res;
            };
            LayerService.prototype.updateLog = function (f) {
                var date = this.project.timeLine.focus;
                var changed = false;
                if (f.logs && !this.isLocked(f)) {
                    // find all keys
                    for (var key in f.logs) {
                        // lookup value
                        var l = this.lookupLog(f.logs[key], date);
                        if (key === "~geometry") {
                            if (l.value != f.geometry) {
                                f.geometry = l.value;
                                changed = true;
                            }
                        }
                        else {
                            if (!f.properties.hasOwnProperty(key)) {
                                f.properties[key] = l.value;
                                changed = true;
                            }
                            else {
                                if (f.properties[key] != l.value) {
                                    f.properties[key] = l.value;
                                    changed = true;
                                }
                            }
                        }
                    }
                    if (changed) {
                        this.calculateFeatureStyle(f);
                        this.updateFeature(f);
                    }
                }
            };
            LayerService.prototype.updateFeature = function (feature) {
                this.activeMapRenderer.updateFeature(feature);
                if (feature === this.lastSelectedFeature) {
                    this.$messageBusService.publish("feature", "onFeatureUpdated");
                }
            };
            /** update for all features the active sensor data values and update styles */
            LayerService.prototype.updateSensorData = function () {
                var _this = this;
                if (this.project == null || this.project.timeLine == null || this.project.features == null)
                    return;
                var date = this.project.timeLine.focus;
                var timepos = {};
                if (this.project.datasources) {
                    this.project.datasources.forEach(function (ds) {
                        for (var sensorTitle in ds.sensors) {
                            var sensor = ds.sensors[sensorTitle];
                            if (sensor.timestamps) {
                                if (sensor.timestamps.length == 1) {
                                    sensor.activeValue = sensor.values[0];
                                }
                                else
                                    for (var i = 1; i < sensor.timestamps.length; i++) {
                                        if (sensor.timestamps[i] < date) {
                                            sensor.activeValue = sensor.values[i];
                                            //console.log('updateSensor: sensor.activeValue = ' + sensor.activeValue + " - " + i);
                                            break;
                                        }
                                    }
                            }
                        }
                    });
                }
                ;
                this.project.features.forEach(function (f) {
                    var l = f.layer;
                    if (l != null) {
                        if (f.sensors || f.coordinates) {
                            var getIndex = function (d, timestamps) {
                                for (var i = 1; i < timestamps.length; i++) {
                                    if (timestamps[i] > d) {
                                        return i;
                                    }
                                }
                                return timestamps.length - 1;
                            };
                            var pos = 0;
                            if (f.timestamps) {
                                pos = getIndex(date, f.timestamps);
                            }
                            else if (l.timestamps) {
                                if (timepos.hasOwnProperty(f.layerId)) {
                                    pos = timepos[f.layerId];
                                }
                                else {
                                    pos = getIndex(date, l.timestamps);
                                    timepos[f.layerId] = pos;
                                }
                            }
                            // check if a new coordinate is avaiable
                            if (f.coordinates && f.geometry && f.coordinates.length > pos && f.coordinates[pos] != f.geometry.coordinates) {
                                f.geometry.coordinates = f.coordinates[pos];
                                // get marker
                                if (l.group.markers.hasOwnProperty(f.id)) {
                                    var m = l.group.markers[f.id];
                                    // update position
                                    m.setLatLng(new L.LatLng(f.geometry.coordinates[1], f.geometry.coordinates[0]));
                                }
                            }
                            if (f.sensors) {
                                for (var sensorTitle in f.sensors) {
                                    var sensor = f.sensors[sensorTitle];
                                    var value = sensor[pos];
                                    f.properties[sensorTitle] = value;
                                }
                                _this.calculateFeatureStyle(f);
                                _this.activeMapRenderer.updateFeature(f);
                                if (f.isSelected)
                                    _this.$messageBusService.publish("feature", "onFeatureUpdated", f);
                            }
                        }
                    }
                });
            };
            /***
             * get list of properties that are part of the filter collection
             */
            LayerService.prototype.filterProperties = function (group) {
                var result = [];
                if (group.filters != null && group.filters.length > 0) {
                    group.filters.forEach(function (f) {
                        result.push(f.property);
                    });
                }
                ;
                return result;
            };
            /**
             * init feature (add to feature list, crossfilter)
             */
            LayerService.prototype.initFeature = function (feature, layer, applyDigest, publishToTimeline) {
                if (applyDigest === void 0) { applyDigest = false; }
                if (publishToTimeline === void 0) { publishToTimeline = true; }
                if (!feature.isInitialized) {
                    feature.isInitialized = true;
                    feature.gui = {};
                    if (!feature.logs)
                        feature.logs = {};
                    if (feature.properties == null)
                        feature.properties = {};
                    feature.index = layer.count++;
                    // make sure it has an id
                    if (feature.id == null)
                        feature.id = csComp.Helpers.getGuid();
                    feature.layerId = layer.id;
                    feature.layer = layer;
                    // add feature to global list of features
                    this.project.features.push(feature);
                    // add to crossfilter
                    layer.group.ndx.add([feature]);
                    // resolve feature type
                    feature.fType = this.getFeatureType(feature);
                    this.initFeatureType(feature.fType);
                    // add missing properties
                    if (feature.fType.showAllProperties)
                        csComp.Helpers.addPropertyTypes(feature, feature.fType);
                    // Do we have a name?
                    if (!feature.properties.hasOwnProperty('Name'))
                        csComp.Helpers.setFeatureName(feature, this.propertyTypeData);
                    this.calculateFeatureStyle(feature);
                    feature.propertiesOld = {};
                    this.trackFeature(feature);
                    if (applyDigest && this.$rootScope.$root.$$phase != '$apply' && this.$rootScope.$root.$$phase != '$digest') {
                        this.$rootScope.$apply();
                    }
                    if (publishToTimeline)
                        this.$messageBusService.publish("timeline", "updateFeatures");
                }
                return feature.type;
            };
            /** remove feature */
            LayerService.prototype.removeFeature = function (feature, dynamic) {
                if (dynamic === void 0) { dynamic = false; }
                this.project.features = this.project.features.filter(function (f) { return f != feature; });
                feature.layer.data.features = feature.layer.data.features.filter(function (f) { return f != feature; });
                if (feature.layer.group.filterResult)
                    feature.layer.group.filterResult = feature.layer.group.filterResult.filter(function (f) { return f != feature; });
                feature.layer.group.ndx.remove([feature]);
                this.activeMapRenderer.removeFeature(feature);
                if (dynamic) {
                    var s = new LayerUpdate();
                    s.layerId = feature.layerId;
                    s.action = LayerUpdateAction.deleteFeature;
                    s.item = feature.id;
                    this.$messageBusService.serverSendMessageAction("layer", s);
                }
            };
            /**
            * Calculate the effective feature style.
            */
            LayerService.prototype.calculateFeatureStyle = function (feature) {
                var s = csComp.Helpers.getDefaultFeatureStyle();
                var ft = this.getFeatureType(feature);
                if (ft.style) {
                    if (ft.style.nameLabel)
                        s.nameLabel = ft.style.nameLabel;
                    if (ft.style.iconUri)
                        s.iconUri = ft.style.iconUri;
                    if (ft.style.fillOpacity)
                        s.fillOpacity = ft.style.fillOpacity;
                    if (ft.style.opacity)
                        s.opacity = ft.style.opacity;
                    if (ft.style.fillColor)
                        s.fillColor = csComp.Helpers.getColorString(ft.style.fillColor);
                    // Stroke is a boolean property, so you have to check whether it is undefined.
                    if (typeof ft.style.stroke !== 'undefined')
                        s.stroke = ft.style.stroke;
                    if (ft.style.strokeColor)
                        s.strokeColor = csComp.Helpers.getColorString(ft.style.strokeColor, '#fff');
                    // StrokeWidth can be 0 (interpreted as false), so you have to check whether it is undefined.
                    if (typeof ft.style.strokeWidth !== 'undefined')
                        s.strokeWidth = ft.style.strokeWidth;
                    if (ft.style.selectedStrokeColor)
                        s.selectedStrokeColor = csComp.Helpers.getColorString(ft.style.selectedStrokeColor, '#000');
                    if (ft.style.selectedFillColor)
                        s.selectedFillColor = csComp.Helpers.getColorString(ft.style.selectedFillColor);
                    if (ft.style.selectedStrokeWidth)
                        s.selectedStrokeWidth = ft.style.selectedStrokeWidth;
                    if (ft.style.iconWidth)
                        s.iconWidth = ft.style.iconWidth;
                    if (ft.style.iconHeight)
                        s.iconHeight = ft.style.iconHeight;
                    if (ft.style.modelUri)
                        s.modelUri = ft.style.modelUri;
                    if (ft.style.modelScale)
                        s.modelScale = ft.style.modelScale;
                    if (ft.style.modelMinimumPixelSize)
                        s.modelMinimumPixelSize = ft.style.modelMinimumPixelSize;
                    if (ft.style.innerTextProperty)
                        s.innerTextProperty = ft.style.innerTextProperty;
                    if (ft.style.innerTextSize)
                        s.innerTextSize = ft.style.innerTextSize;
                    if (ft.style.cornerRadius)
                        s.cornerRadius = ft.style.cornerRadius;
                    if (ft.style.rotateProperty && feature.properties.hasOwnProperty(ft.style.rotateProperty)) {
                        s.rotate = Number(feature.properties[ft.style.rotateProperty]);
                    }
                }
                feature.gui['style'] = {};
                s.opacity = s.opacity * (feature.layer.opacity / 100);
                s.fillOpacity = s.fillOpacity * (feature.layer.opacity / 100);
                feature.layer.group.styles.forEach(function (gs) {
                    if (gs.enabled && feature.properties.hasOwnProperty(gs.property)) {
                        //delete feature.gui[gs.property];
                        var v = Number(feature.properties[gs.property]);
                        if (!isNaN(v)) {
                            switch (gs.visualAspect) {
                                case 'strokeColor':
                                    s.strokeColor = csComp.Helpers.getColor(v, gs);
                                    feature.gui['style'][gs.property] = s.strokeColor;
                                    break;
                                case 'fillColor':
                                    s.fillColor = csComp.Helpers.getColor(v, gs);
                                    feature.gui['style'][gs.property] = s.fillColor;
                                    break;
                                case 'strokeWidth':
                                    s.strokeWidth = ((v - gs.info.min) / (gs.info.max - gs.info.min) * 10) + 1;
                                    break;
                                case 'height':
                                    s.height = ((v - gs.info.min) / (gs.info.max - gs.info.min) * 25000);
                                    break;
                            }
                        }
                        else {
                            var ss = feature.properties[gs.property];
                            switch (gs.visualAspect) {
                                case 'strokeColor':
                                    s.strokeColor = csComp.Helpers.getColorFromStringValue(ss, gs);
                                    feature.gui['style'][gs.property] = s.strokeColor;
                                    break;
                                case 'fillColor':
                                    s.fillColor = csComp.Helpers.getColorFromStringValue(ss, gs);
                                    feature.gui['style'][gs.property] = s.fillColor;
                                    break;
                            }
                        }
                    }
                });
                if (feature.isSelected) {
                    s.strokeWidth = s.selectedStrokeWidth || 3;
                    s.strokeColor = s.selectedStrokeColor || 'black';
                    if (s.selectedFillColor)
                        s.fillColor = s.selectedFillColor;
                }
                feature.effectiveStyle = s;
            };
            /**
            * Initialize the feature type and its property types by setting default property values, and by localizing it.
            */
            LayerService.prototype.initFeatureType = function (ft) {
                var _this = this;
                if (ft.isInitialized)
                    return;
                ft.isInitialized = true;
                this.initIconUri(ft);
                if (ft.languages != null && this.currentLocale in ft.languages) {
                    var locale = ft.languages[this.currentLocale];
                    if (locale.name)
                        ft.name = locale.name;
                }
                if (ft.propertyTypeData == null || ft.propertyTypeData.length == 0)
                    return;
                if (ft.propertyTypeData.forEach) {
                    ft.propertyTypeData.forEach(function (pt) {
                        _this.initPropertyType(pt);
                    });
                }
                else {
                    for (var ptlabel in ft.propertyTypeData) {
                        if (ft.propertyTypeData.hasOwnProperty(ptlabel)) {
                            this.initPropertyType(ft.propertyTypeData[ptlabel]);
                        }
                    }
                }
            };
            /** Set the iconUri for remote servers (newIconUri = server/oldIconUri) */
            LayerService.prototype.initIconUri = function (ft) {
                if (!ft.style.iconUri)
                    return;
                var testForRemoteServerRegex = /^(http[s]?:\/\/[:a-zA-Z0-9_\.]+)\/.*$/g;
                var matches = testForRemoteServerRegex.exec(ft.id);
                if (matches && matches.length > 1) {
                    ft.style.iconUri = matches[1] + "/" + ft.style.iconUri;
                }
            };
            /**
            * Initialize the property type with default values, and, if applicable, localize it.
            */
            LayerService.prototype.initPropertyType = function (pt) {
                this.setDefaultPropertyType(pt);
                if (pt.languages != null)
                    this.localizePropertyType(pt);
            };
            /**
            * Set default PropertyType's properties:
            * type              = text
            * visibleInCallout  = true
            * canEdit           = false
            * isSearchable      = true
            */
            LayerService.prototype.setDefaultPropertyType = function (pt) {
                if (!pt.type)
                    pt.type = "text";
                if (typeof pt.title == 'undefined')
                    pt.title = pt.label;
                if (typeof pt.canEdit == 'undefined')
                    pt.canEdit = false;
                if (typeof pt.visibleInCallOut == 'undefined')
                    pt.visibleInCallOut = true;
                if (typeof pt.isSearchable == 'undefined' && pt.type === 'text')
                    pt.isSearchable = true;
            };
            LayerService.prototype.localizePropertyType = function (pt) {
                if (pt.languages != null && this.currentLocale in pt.languages) {
                    var locale = pt.languages[this.currentLocale];
                    if (locale.title)
                        pt.title = locale.title;
                    if (locale.description)
                        pt.description = locale.description;
                    if (locale.section)
                        pt.section = locale.section;
                    if (locale.options != null)
                        pt.options = locale.options;
                }
                ;
            };
            /**
             * find a filter for a specific group/property combination
             */
            LayerService.prototype.findFilter = function (group, property) {
                if (group.filters == null)
                    group.filters = [];
                var r = group.filters.filter(function (f) { return f.property === property; });
                if (r.length > 0)
                    return r[0];
                return null;
            };
            /**
             * Find a feature by layerId and FeatureId.
             * @layerId {string}
             * @featureIndex {number}
             */
            LayerService.prototype.findFeatureByIndex = function (layerId, featureIndex) {
                for (var i = 0; i < this.project.features.length; i++) {
                    var feature = this.project.features[i];
                    if (featureIndex === feature.index && layerId === feature.layerId)
                        return feature;
                }
            };
            /**
             * Find a feature by layerId and FeatureId.
             * @layerId {string}
             * @featureIndex {number}
             */
            LayerService.prototype.findFeatureById = function (featureId) {
                return _.find(this.project.features, function (f) { return f.id === featureId; });
            };
            /**
             * Find a feature by layerId and FeatureId.
             * @layer {ProjectLayer}
             * @featureId {number}
             */
            LayerService.prototype.findFeature = function (layer, featureId) {
                if (!layer.data || !layer.data.features)
                    return null;
                return _.find(layer.data.features, function (f) { return f.id === featureId; });
            };
            /**
             * Find a group by id
             */
            LayerService.prototype.findGroupById = function (id) {
                for (var i = 0; i < this.project.groups.length; i++) {
                    if (this.project.groups[i].id === id)
                        return this.project.groups[i];
                }
                return null;
            };
            /**
             * Find a group by id
             */
            LayerService.prototype.findGroupByLayerId = function (layer) {
                if (!layer.id)
                    return null;
                var matchedGroup;
                this.project.groups.some(function (group) {
                    if (group.layers) {
                        group.layers.some(function (l) {
                            if (l.id === layer.id) {
                                matchedGroup = group;
                                return true;
                            }
                            return false;
                        });
                    }
                    if (matchedGroup)
                        return true;
                    return false;
                });
                return matchedGroup;
            };
            /**
             * Find the feature by name.
             */
            LayerService.prototype.findFeatureByName = function (name) {
                for (var i = 0; i < this.project.features.length; i++) {
                    var feature = this.project.features[i];
                    if (feature.hasOwnProperty("Name") && name === feature.properties["Name"])
                        return feature;
                }
            };
            /**
            * Find a loaded layer with a specific id.
            */
            LayerService.prototype.findLoadedLayer = function (id) {
                if (this.loadedLayers.containsKey(id))
                    return this.loadedLayers[id];
                return null;
            };
            /**
             * Find a layer with a specific id.
             */
            LayerService.prototype.findLayer = function (id) {
                if (this.loadedLayers.containsKey(id))
                    return this.loadedLayers[id];
                //return null;
                var r;
                this.project.groups.forEach(function (g) {
                    g.layers.forEach(function (l) {
                        if (l.id === id) {
                            r = l;
                        }
                    });
                });
                return r;
            };
            /**
             * Creates a GroupStyle based on a property and adds it to a group.
             * If the group already has a style which contains legends, those legends are copied into the newly created group.
             * Already existing groups (for the same visualAspect) are replaced by the new group
             * Restoring a previously used groupstyle is possible by sending that GroupStyle object
             */
            LayerService.prototype.setStyle = function (property, openStyleTab, customStyleInfo, groupStyle) {
                var _this = this;
                if (openStyleTab === void 0) { openStyleTab = false; }
                // parameter property is of the type ICallOutProperty. explicit declaration gives the red squigglies
                var f = property.feature;
                if (f != null) {
                    var ft = this.getFeatureType(f);
                    // use the groupstyle that was passed along, or create a new groupstyle if none is present
                    var gs;
                    if (groupStyle) {
                        gs = groupStyle;
                        gs.info = this.calculatePropertyInfo(f.layer.group, property.property);
                    }
                    else {
                        gs = new Services.GroupStyle(this.$translate);
                        gs.id = csComp.Helpers.getGuid();
                        gs.title = property.key;
                        gs.meta = property.meta;
                        gs.visualAspect = (ft.style && ft.style.drawingMode && ft.style.drawingMode.toLowerCase() == 'line') ? 'strokeColor' : 'fillColor';
                        gs.canSelectColor = gs.visualAspect.toLowerCase().indexOf('color') > -1;
                        gs.property = property.property;
                        if (customStyleInfo) {
                            gs.info = customStyleInfo;
                            gs.fixedColorRange = true;
                        }
                        else {
                            if (gs.info == null)
                                gs.info = this.calculatePropertyInfo(f.layer.group, property.property);
                        }
                        gs.enabled = true;
                        gs.group = f.layer.group;
                        gs.meta = property.meta;
                        var ptd = this.propertyTypeData[property.property];
                        if (ptd && ptd.legend) {
                            gs.activeLegend = ptd.legend;
                            gs.legends[ptd.title] = ptd.legend;
                            gs.colorScales[ptd.title] = ['purple', 'purple'];
                        }
                        if (ft.style && ft.style.fillColor) {
                            gs.colors = ['white', '#FF5500'];
                        }
                        else {
                            gs.colors = ['red', 'white', 'blue'];
                        }
                    }
                    this.saveStyle(f.layer.group, gs);
                    this.project.features.forEach(function (fe) {
                        if (fe.layer.group == f.layer.group) {
                            _this.calculateFeatureStyle(fe);
                            _this.activeMapRenderer.updateFeature(fe);
                        }
                    });
                    if (openStyleTab)
                        $('#leftPanelTab a[href="#styles"]').tab('show'); // Select tab by name
                    return gs;
                }
                return null;
            };
            LayerService.prototype.toggleStyle = function (property, group, openStyleTab, customStyleInfo) {
                var _this = this;
                if (openStyleTab === void 0) { openStyleTab = false; }
                var s = property.feature.layer.group.styles;
                if (!s.some(function (s) { return s.property === property.property; })) {
                    this.setStyle(property, openStyleTab, customStyleInfo);
                }
                else {
                    s.filter(function (s) { return s.property === property.property; }).forEach(function (st) { return _this.removeStyle(st); });
                }
                this.$messageBusService.publish('updatelegend', 'updatedstyle');
            };
            /**
             * checks if there are other styles that affect the same visual aspect, removes them (it)
             * and then adds the style to the group's styles
             */
            LayerService.prototype.saveStyle = function (group, style) {
                var oldStyles = group.styles.filter(function (s) { return s.visualAspect === style.visualAspect; });
                if (oldStyles.length > 0) {
                    var pos = group.styles.indexOf(oldStyles[0]);
                    group.styles.splice(pos, 1); // RS, 2015-04-04: why delete only one style? (what if oldStyles.length > 1)
                }
                group.styles.push(style);
            };
            LayerService.prototype.addFilter = function (group, prop) {
                var filter = this.findFilter(group, prop);
                if (filter == null) {
                    var gf = new Services.GroupFilter();
                    gf.property = prop;
                    //gf.filterType = "row";
                    gf.title = prop;
                    gf.rangex = [0, 1];
                    group.filters.push(gf);
                }
                else {
                    var pos = group.filters.indexOf(filter);
                    if (pos !== -1)
                        group.filters.slice(pos, 1);
                }
                $('#leftPanelTab a[href="#filters"]').tab('show'); // Select tab by name
            };
            /**
             * enable a filter for a specific property
             */
            LayerService.prototype.setFilter = function (filter, group) {
                filter.group = group;
                group.filters.push(filter);
                $('#leftPanelTab a[href="#filters"]').tab('show'); // Select tab by name
                this.triggerUpdateFilter(group.id);
            };
            LayerService.prototype.setLocationFilter = function (group) {
                if (group.filters.some(function (f) { return f.filterType === 'location'; }))
                    return;
                var gf = new Services.GroupFilter();
                gf.id = csComp.Helpers.getGuid();
                gf.group = group;
                gf.filterType = 'location';
                gf.title = 'Location';
                gf.rangex = [0, 1];
                group.filters.push(gf);
                $('#leftPanelTab a[href="#filters"]').tab('show'); // Select tab by name
                this.triggerUpdateFilter(group.id);
            };
            LayerService.prototype.setFeatureAreaFilter = function (f) {
                this.project.groups.forEach(function (g) {
                    if (g.id === f.layer.group.id)
                        return;
                    if (!g.filters.some(function (f) { return f.filterType === 'area'; })) {
                        var gf = new Services.GroupFilter();
                        gf.id = csComp.Helpers.getGuid();
                        gf.group = g;
                        gf.filterType = 'area';
                        gf.title = 'Area';
                        gf.rangex = [0, 1];
                        gf.value = f;
                        g.filters.push(gf);
                        g.filterResult = g.filterResult || [];
                    }
                });
                // if (this.$rootScope.$root.$$phase != '$apply' && this.$rootScope.$root.$$phase != '$digest') { this.$rootScope.$apply(); }
                this.triggerUpdateFilter(f.layer.group.id);
            };
            LayerService.prototype.resetFeatureAreaFilter = function () {
                var _this = this;
                this.project.groups.forEach(function (g) {
                    g.filters.some(function (f) {
                        if (f.filterType === 'area') {
                            _this.removeFilter(f);
                            return true;
                        }
                        return false;
                    });
                });
            };
            /**
            * enable a filter for a specific property
            */
            LayerService.prototype.setPropertyFilter = function (property) {
                var prop = property.property;
                var f = property.feature;
                if (f != null) {
                    var layer = f.layer;
                    if (layer != null) {
                        var filter = this.findFilter(layer.group, prop);
                        if (filter == null) {
                            var gf = new Services.GroupFilter();
                            gf.property = prop;
                            gf.id = csComp.Helpers.getGuid();
                            gf.group = layer.group;
                            gf.meta = property.propertyType;
                            gf.filterType = 'bar';
                            if (gf.meta != null) {
                                if (gf.meta.filterType != null) {
                                    gf.filterType = gf.meta.filterType;
                                }
                                else {
                                    switch (gf.meta.type) {
                                        case 'boolean':
                                            gf.filterType = 'boolean';
                                            break;
                                        case "date":
                                            gf.filterType = 'date';
                                            break;
                                        case 'number':
                                        case 'options':
                                            gf.filterType = 'bar';
                                            break;
                                        //case 'rank':
                                        //    gf.filterType  = 'bar';
                                        //    gf.value = property.value.split(',')[0];
                                        //    break;
                                        default:
                                            gf.filterType = 'text';
                                            gf.stringValue = property.value;
                                            gf.value = property.value;
                                            break;
                                    }
                                }
                            }
                            gf.title = property.key;
                            gf.rangex = [0, 1];
                            // if (gf.filterType === 'text') {
                            //     var old = layer.group.filters.filter((flt: GroupFilter) => flt.filterType === 'text');
                            //     old.forEach((groupFilter: GroupFilter) => {
                            //         groupFilter.dimension.filterAll();
                            //         groupFilter.dimension.dispose();
                            //     });
                            //     layer.group.filters = layer.group.filters.filter((groupFilter: GroupFilter) => groupFilter.filterType !== 'text');
                            // }
                            // add filter
                            layer.group.filters.push(gf);
                        }
                        else {
                            this.removeFilter(filter);
                        }
                    }
                    $('#leftPanelTab a[href="#filters"]').tab('show'); // Select tab by name
                }
                this.triggerUpdateFilter(layer.group.id);
            };
            LayerService.prototype.createScatterFilter = function (group, prop1, prop2) {
                console.log("create scatter " + prop1 + "-" + prop2);
                var gf = new Services.GroupFilter();
                gf.property = prop1;
                gf.property2 = prop2;
                gf.id = csComp.Helpers.getGuid();
                gf.group = group;
                //gf.meta = property.meta;
                gf.filterType = 'scatter';
                // if (gf.meta != null) {
                //     if (gf.meta.filterType != null) {
                //         gf.filterType = gf.meta.filterType;
                //     } else {
                //         switch (gf.meta.type) {
                //             case "date":
                //                 gf.filterType = 'date';
                //                 break;
                //             case 'number':
                //             case 'options':
                //                 gf.filterType = 'bar';
                //                 break;
                //             //case 'rank':
                //             //    gf.filterType  = 'bar';
                //             //    gf.value = property.value.split(',')[0];
                //             //    break;
                //             default:
                //                 gf.filterType = 'text';
                //                 gf.stringValue = property.value;
                //                 gf.value = property.value;
                //                 break;
                //         }
                //     }
                // }
                gf.title = "Scatter";
                gf.rangex = [0, 1];
                // add filter
                group.filters.push(gf);
                $('#leftPanelTab a[href="#filters"]').tab('show'); // Select tab by name
                this.triggerUpdateFilter(group.id);
            };
            LayerService.prototype.triggerUpdateFilter = function (groupId) {
                this.mb.publish("filters", "updated", groupId);
            };
            /** remove filter from group */
            LayerService.prototype.removeFilter = function (filter) {
                // dispose crossfilter dimension
                filter.group.filterResult = filter.dimension.filterAll().top(Infinity);
                filter.dimension.dispose();
                filter.group.filters = filter.group.filters.filter(function (f) { return f != filter; });
                this.resetMapFilter(filter.group);
                this.updateMapFilter(filter.group);
                this.triggerUpdateFilter(filter.group.id);
            };
            /**
             * Returs propertytype for a specific property in a feature
             */
            LayerService.prototype.getPropertyType = function (feature, property) {
                var res;
                // search for local propertytypes in featuretype
                if (feature.fType && feature.fType.propertyTypeData) {
                    res = _.find(feature.fType.propertyTypeData, function (pt) { return pt.label === property; });
                }
                if (!res && feature.fType.propertyTypeKeys && feature.layer.typeUrl && this.typesResources.hasOwnProperty(feature.layer.typeUrl)) {
                    var rt = this.typesResources[feature.layer.typeUrl];
                    feature.fType.propertyTypeKeys.split(';').forEach(function (key) {
                        if (rt.propertyTypeData.hasOwnProperty(key) && rt.propertyTypeData[key].label === property)
                            res = rt.propertyTypeData[key];
                    });
                }
                return res;
            };
            /**
            Returns the featureTypeId for specific feature.
            It looks for the FeatureTypeId property, defaultFeatureType of his layer
            and checks if it should be found in a resource file or within his own layer
            */
            LayerService.prototype.getFeatureTypeId = function (feature) {
                if (!feature.hasOwnProperty('layer'))
                    feature['layer'] = new Services.ProjectLayer();
                var name = feature.properties['FeatureTypeId'] || feature.properties['featureTypeId'] || feature.layer.defaultFeatureType || 'Default';
                // if (name.toLowerCase().startsWith("http://")) return name;
                // if (csComp.Helpers.startsWith(name.toLowerCase(), "http://")) return name;
                if (/^http:\/\//.test(name.toLowerCase()))
                    return name;
                if (feature.layer.typeUrl)
                    return feature.layer.typeUrl + "#" + name;
                return feature.layer.url
                    ? feature.layer.url + "#" + name
                    : this.project.url + "#" + name;
            };
            /**
             * Find a feature type by its ID (of the format "featuretypeurl + # + featuretypename").
             * If it does not exist, return null.
             */
            LayerService.prototype.getFeatureTypeById = function (featureTypeId) {
                if (this._featureTypes.hasOwnProperty(featureTypeId)) {
                    return this._featureTypes[featureTypeId];
                }
                else {
                    return;
                }
            };
            /**
             * Return the feature style for a specific feature.
             * First, look for a layer specific feature type, otherwise, look for a project-specific feature type.
             * In case both fail, create a default feature type at the layer level.
             *
             * If the feature type contains a _{xxx} part, replace the {xxx} with the value of feature.property['xxx']
             * if it exists, otherwise remove it.
             */
            LayerService.prototype.getFeatureType = function (feature) {
                if (!feature.featureTypeName) {
                    feature.featureTypeName = this.getFeatureTypeId(feature);
                }
                var isPropertyBasedFeatureType = feature.featureTypeName.indexOf('_{') >= 0;
                if (!isPropertyBasedFeatureType && feature.fType)
                    return feature.fType;
                var featureTypeName = feature.featureTypeName;
                if (isPropertyBasedFeatureType) {
                    // Feature type depends on a property, so substite the property placeholder with its value,
                    // e.g. featureTypeId="default_{state}", and property state="failed", look for featureTypeId=default_failed
                    // If state is not defined, featureTypeId=default.
                    var re = /_{([a-zA-Z_0-9]+)}/g;
                    var matches = re.exec(featureTypeName);
                    if (matches) {
                        for (var i = 1; i < matches.length; i++) {
                            var match = matches[i];
                            featureTypeName = feature.properties.hasOwnProperty(match)
                                ? featureTypeName.replace("{" + match + "}", feature.properties[match])
                                : featureTypeName.replace("_{" + match + "}", '');
                        }
                    }
                }
                if (!this._featureTypes.hasOwnProperty(featureTypeName)) {
                    this.createMissingFeatureType(feature);
                }
                feature.fType = this._featureTypes[featureTypeName];
                return feature.fType;
            };
            LayerService.prototype.createMissingFeatureType = function (feature) {
                var _this = this;
                var ftKeys = Object.getOwnPropertyNames(this._featureTypes);
                var featureTypes = ftKeys.map(function (key) { return _this._featureTypes[key]; }).filter(function (ft) { return ft.name == feature.featureTypeName; });
                if (featureTypes.length > 0) {
                    this._featureTypes[feature.featureTypeName] = featureTypes[0];
                }
                else {
                    this._featureTypes[feature.featureTypeName] = csComp.Helpers.createDefaultType(feature);
                }
            };
            LayerService.prototype.resetFilters = function () {
                dc.filterAll();
                dc.redrawAll();
            };
            LayerService.prototype.getGroupFeatures = function (g) {
                // find active layers
                var ls = [];
                g.layers.forEach(function (l) { if (l.enabled)
                    ls.push(l.id); });
                // add active features
                var r = this.project.features.filter(function (k) { return ls.indexOf(k.layerId) > -1; });
                return r;
            };
            LayerService.prototype.rebuildFilters = function (g) {
                // remove all data from crossfilter group
                g.ndx = crossfilter([]);
                var features = this.getGroupFeatures(g);
                g.ndx.add(features);
            };
            /**
             * deactivate layer
             */
            LayerService.prototype.removeLayer = function (layer, removeFromGroup) {
                var _this = this;
                if (removeFromGroup === void 0) { removeFromGroup = false; }
                var m;
                var g = layer.group;
                layer.enabled = false;
                layer.isLoading = false;
                layer.gui.more = false;
                //if (layer.refreshTimer) layer.stop();
                // make sure the timers are disabled
                this.checkLayerTimer(layer);
                this.loadedLayers.remove(layer.id);
                // find layer source, and remove layer
                if (!layer.layerSource)
                    layer.layerSource = this.layerSources[layer.type.toLowerCase()];
                layer.layerSource.removeLayer(layer);
                if (this.lastSelectedFeature != null && this.lastSelectedFeature.layerId === layer.id) {
                    this.lastSelectedFeature = null;
                    this.visual.rightPanelVisible = false;
                    this.$messageBusService.publish('feature', 'onFeatureDeselect');
                }
                if (this.selectedFeatures.length > 0) {
                    this.selectedFeatures = this.selectedFeatures.filter(function (f) { return f.layerId !== layer.id; });
                }
                this.activeMapRenderer.removeLayer(layer);
                this.project.features = this.project.features.filter(function (k) { return k.layerId !== layer.id; });
                var layerName = layer.id + '_';
                var featureTypes = this._featureTypes;
                // EV What should this have done?
                // for (var poiTypeName in featureTypes) {
                //     if (!featureTypes.hasOwnProperty(poiTypeName)) continue;
                // }
                // check if there are no more active layers in group and remove filters/styles
                if (g.layers.filter(function (l) { return (l.enabled); }).length === 0 || g.oneLayerActive === true) {
                    g.filters.forEach(function (f) { if (f.dimension != null)
                        f.dimension.dispose(); });
                    g.filters = [];
                    g.styles.forEach(function (s) { _this.removeStyle(s); });
                    g.styles = [];
                }
                this.rebuildFilters(g);
                if (removeFromGroup)
                    layer.group.layers = layer.group.layers.filter(function (pl) { return pl != layer; });
                if (this.$rootScope.$root.$$phase != '$apply' && this.$rootScope.$root.$$phase != '$digest') {
                    this.$rootScope.$apply();
                }
                this.$messageBusService.publish('layer', 'deactivate', layer);
                this.$messageBusService.publish('rightpanel', 'deactiveContainer', 'edit');
                this.$messageBusService.publish("timeline", "updateFeatures");
            };
            /***
             * Open solution file with references to available baselayers and projects
             * @params url: URL of the solution
             * @params layers: Optionally provide a semi-colon separated list of layer IDs that should be opened.
             * @params initialProject: Optionally provide a project name that should be loaded, if omitted the first project in the definition will be loaded
             */
            LayerService.prototype.openSolution = function (url, layers, initialProject) {
                var _this = this;
                //console.log('layers (openSolution): ' + JSON.stringify(layers));
                this.loadedLayers.clear();
                var searchParams = this.$location.search();
                if (searchParams.hasOwnProperty('project')) {
                    url = this.emptySolutionUrl;
                    this.openSingleProject = true;
                }
                this.$http.get(url)
                    .success(function (solution) {
                    if (solution.maxBounds) {
                        _this.maxBounds = solution.maxBounds;
                        _this.$mapService.map.setMaxBounds(new L.LatLngBounds(L.latLng(solution.maxBounds.southWest[0], solution.maxBounds.southWest[1]), L.latLng(solution.maxBounds.northEast[0], solution.maxBounds.northEast[1])));
                    }
                    if (solution.viewBounds) {
                        _this.activeMapRenderer.fitBounds(solution.viewBounds);
                    }
                    if (solution.baselayers) {
                        solution.baselayers.forEach(function (b) {
                            var baselayer = new Services.BaseLayer();
                            if (b.subdomains != null)
                                baselayer.subdomains = b.subdomains;
                            if (b.maxZoom != null)
                                baselayer.maxZoom = b.maxZoom;
                            if (b.minZoom != null)
                                baselayer.minZoom = b.minZoom;
                            if (b.attribution != null)
                                baselayer.attribution = b.attribution;
                            if (b.id != null)
                                baselayer.id = b.id;
                            if (b.title != null)
                                baselayer.title = b.title;
                            if (b.subtitle != null)
                                baselayer.subtitle = b.subtitle;
                            if (b.preview != null)
                                baselayer.preview = b.preview;
                            if (b.url != null)
                                baselayer.url = b.url;
                            if (b.cesium_url != null)
                                baselayer.cesium_url = b.cesium_url;
                            if (b.cesium_maptype != null)
                                baselayer.cesium_maptype = b.cesium_maptype;
                            _this.$mapService.baseLayers[b.title] = baselayer;
                            if (b.isDefault) {
                                _this.activeMapRenderer.changeBaseLayer(baselayer);
                                _this.$mapService.changeBaseLayer(b.title);
                            }
                        });
                    }
                    if (_this.openSingleProject) {
                        var u = 'api/projects/' + searchParams['project'];
                        _this.$http.get(u)
                            .success(function (data) {
                            if (data) {
                                _this.parseProject(data, { title: data.title, url: data.url, dynamic: true }, []);
                            }
                        })
                            .error(function (data) {
                            _this.$messageBusService.notify('ERROR loading project', 'while loading: ' + u);
                        });
                    }
                    if (solution.projects && solution.projects.length > 0) {
                        var p = solution.projects.filter(function (aProject) { return aProject.title === initialProject; })[0];
                        if (p != null) {
                            _this.openProject(p, layers);
                        }
                        else {
                            _this.openProject(solution.projects[0], layers);
                        }
                    }
                    // make sure a default WidgetStyle exists
                    if (!solution.widgetStyles)
                        solution.widgetStyles = {};
                    if (!solution.widgetStyles.hasOwnProperty('default')) {
                        var defaultStyle = new Services.WidgetStyle();
                        defaultStyle.background = "red";
                        solution.widgetStyles["default"] = defaultStyle;
                    }
                    _this.solution = solution;
                })
                    .error(function () {
                    _this.$messageBusService.notify('ERROR loading solution', 'while loading: ' + url);
                });
            };
            /**
            * Clear all layers.
            */
            LayerService.prototype.clearLayers = function () {
                var _this = this;
                if (this.project == null || this.project.groups == null)
                    return;
                this.project.groups.forEach(function (group) {
                    group.layers.forEach(function (layer) {
                        if (layer.enabled) {
                            _this.removeLayer(layer);
                            layer.enabled = false;
                        }
                    });
                });
            };
            /**
             * Open project
             * @params url: URL of the project
             * @params layers: Optionally provide a semi-colon separated list of layer IDs that should be opened.
             * @params project: Optionally provide the project that should be parsed. If not provided, it will be requested using the solution url.
             */
            LayerService.prototype.openProject = function (solutionProject, layers, project) {
                var _this = this;
                this.projectUrl = solutionProject;
                var layerIds = [];
                if (layers) {
                    layers.split(';').forEach(function (layerId) { layerIds.push(layerId.toLowerCase()); });
                }
                this.clearLayers();
                this._featureTypes = {};
                this.propertyTypeData = {};
                //typesResources
                var s = this.$location.search();
                if (s.hasOwnProperty('dashboard')) {
                    this.startDashboardId = s['dashboard'];
                }
                if (!project) {
                    this.$http.get(solutionProject.url)
                        .success(function (prj) {
                        _this.parseProject(prj, solutionProject, layerIds);
                        //alert('project open ' + this.$location.absUrl());
                    })
                        .error(function () {
                        _this.$messageBusService.notify('ERROR loading project', 'while loading: ' + solutionProject.url);
                    });
                }
                else {
                    this.parseProject(project, solutionProject, layerIds);
                }
            };
            LayerService.prototype.parseProject = function (prj, solutionProject, layerIds) {
                var _this = this;
                prj.solution = this.solution;
                this.project = new Services.Project().deserialize(prj);
                if (!this.project.timeLine) {
                    this.project.timeLine = new Services.DateRange();
                }
                else {
                    // Set range
                    this.$messageBusService.publish('timeline', 'updateTimerange', this.project.timeLine);
                }
                if (this.project.viewBounds) {
                    this.activeMapRenderer.fitBounds(this.project.viewBounds);
                }
                this.initTypeResources(this.project);
                if (!this.project.dashboards) {
                    this.project.dashboards = [];
                    var d = new Services.Dashboard();
                    d.id = "map";
                    d.name = "Home";
                    d.showMap = true;
                    d.showLeftmenu = true;
                    d.widgets = [];
                    this.project.dashboards.push(d);
                    var d2 = new Services.Dashboard();
                    d2.id = "datatable";
                    d2.name = "Table";
                    d2.showMap = false;
                    d2.showLeftmenu = false;
                    d2.showRightmenu = false;
                    d2.showTimeline = false;
                    d2.widgets = [{
                            id: "datatable_id",
                            directive: "datatable",
                            elementId: "widget-datatable_id",
                            enabled: true,
                            width: "100%",
                            height: "100%"
                        }];
                    this.project.dashboards.push(d2);
                }
                else {
                    this.project.dashboards.forEach(function (d) {
                        if (!d.id) {
                            d.id = csComp.Helpers.getGuid();
                        }
                        if (d.widgets && d.widgets.length > 0)
                            d.widgets.forEach(function (w) {
                                if (!w.id)
                                    w.id = csComp.Helpers.getGuid();
                                if (!w.enabled)
                                    w.enabled = true;
                            });
                    });
                }
                async.series([
                    function (callback) {
                        if (_this.project.typeUrls && _this.project.typeUrls.length > 0) {
                            async.eachSeries(_this.project.typeUrls, function (item, cb) {
                                _this.loadTypeResources(item, false, function () { return cb(null, null); });
                            }, function () {
                                callback(null, null);
                            });
                        }
                        else {
                            callback(null, null);
                        }
                    },
                    function (callback) {
                        if (!_this.project.datasources)
                            _this.project.datasources = [];
                        _this.project.datasources.forEach(function (ds) {
                            if (ds.url) {
                                Services.DataSource.LoadData(_this.$http, ds, function () {
                                    if (ds.type === "dynamic") {
                                        _this.checkDataSourceSubscriptions(ds);
                                    }
                                    for (var s in ds.sensors) {
                                        var ss = ds.sensors[s];
                                        /// check if there is an propertytype available for this sensor
                                        if (ss.propertyTypeKey != null && _this.propertyTypeData.hasOwnProperty(ss.propertyTypeKey)) {
                                            ss.propertyType = _this.propertyTypeData[ss.propertyTypeKey];
                                        }
                                        else {
                                            var id = "sensor-" + csComp.Helpers.getGuid();
                                            var pt = {};
                                            pt.title = s;
                                            ss.propertyTypeKey = id;
                                            _this.project.propertyTypeData[id] = pt;
                                            ss.propertyType = pt;
                                        }
                                        if (ss.values && ss.values.length > 0) {
                                            ss.activeValue = ss.values[ss.values.length - 1];
                                        }
                                    }
                                });
                            }
                        });
                    }
                ]);
                if (!this.project.dataSets) {
                    this.project.dataSets = [];
                }
                this.project.features = [];
                if (this.project.groups && this.project.groups.length > 0) {
                    this.project.groups.forEach(function (group) {
                        _this.initGroup(group, layerIds);
                        if (prj.startposition) {
                            _this.$mapService.zoomToLocation(new L.LatLng(prj.startposition.latitude, prj.startposition.longitude));
                        }
                    });
                }
                if (this.project.connected) {
                    // check connection
                    this.$messageBusService.initConnection("", "", function () {
                        var handle = _this.$messageBusService.subscribe("keyupdate", function (key, msg) {
                            if (msg.action === "key") {
                                var id = "keys/" + msg.data.keyId;
                                _this.findSensorSet(id, function (ss) {
                                    var time = new Date().getTime();
                                    if (msg.data.item.hasOwnProperty('time')) {
                                        time = msg.data.item['time'];
                                    }
                                    else {
                                        ss.timestamps = [];
                                        ss.values = [];
                                    }
                                    ss.addValue(new Date().getTime(), msg.data.item);
                                    ss.activeValue = msg.data.item;
                                });
                            }
                            // console.log('got it');
                            // console.log(msg);
                        });
                        //     if (msg.action !== "subscribed") {
                        //         if (msg.data) {
                        //             var id = "keys/" + msg.data.keyId;
                        //             this.findSensorSet(id, (ss: SensorSet) => {
                        //                 var time = new Date().getTime();
                        //                 if (msg.data.item.hasOwnProperty('time')) {
                        //                     time = msg.data.item['time'];
                        //                 }
                        //                 else {
                        //                     ss.timestamps = [];
                        //                     ss.values = [];
                        //                 }
                        //                 ss.addValue(new Date().getTime(), msg.data.item);
                        //                 ss.activeValue = msg.data.item;
                        //             });
                        //             this.$messageBusService.publish(id, "update", msg.data.item);
                        //         }
                        //         //this.project.dataSets
                        //     }
                        //
                        // });
                        // setTimeout(() => {
                        //     for (var ll in this.loadedLayers) {
                        //         var layer = <ProjectLayer>this.loadedLayers[ll];
                        //         if (layer && layer.layerSource && layer.layerSource.title.toLowerCase() === "dynamicgeojson") {
                        //             layer.layerSource.refreshLayer(layer);
                        //         }
                        //     }
                        // }, 5000);
                    });
                }
                // check if project is dynamic
                if (solutionProject.dynamic) {
                    // listen to directory updates
                    //
                    if (!this.directoryHandle) {
                        this.directoryHandle = this.$messageBusService.serverSubscribe("", "directory", function (sub, msg) {
                            if (msg.action === "subscribed")
                                return;
                            if (msg.action === 'layer' && msg.data && msg.data.item) {
                                // Disabled for single-project-solutions, as layers from excel2map get updated twice: on layer update and on project update
                                if (_this.openSingleProject === false) {
                                    var layer = msg.data.item;
                                    if (layer) {
                                        var l = _this.findLayer(layer.id);
                                        if (!l) {
                                        }
                                        else {
                                            _this.$messageBusService.notify('New update available for layer ', layer.title);
                                            if (l.enabled) {
                                                l.layerSource.refreshLayer(l);
                                            }
                                        }
                                    }
                                }
                            }
                            if (msg.action === 'project' && msg.data && msg.data.item) {
                                var project = msg.data.item;
                                if (project) {
                                    var p = (_this.project.id === project.id);
                                    if (!p && !_this.openSingleProject) {
                                        _this.$messageBusService.notify('New project available', project.title);
                                        if (project.url && project.url.substring(project.url.length - 4) !== 'json')
                                            project.url = '/data' + project.url + '.json';
                                        if (!_this.solution.projects.some(function (sp) { return (sp.title === project.title); })) {
                                            _this.solution.projects.push({ title: project.title, url: project.url, dynamic: true });
                                        }
                                        else {
                                            console.log('Project already exists (' + project.title + ')');
                                        }
                                    }
                                    else {
                                        _this.$messageBusService.notify('New update available for project ', project.title);
                                        //var solProj = this.solution.projects.filter(sp => { return (sp.title === project.title) }).pop();
                                        _this.openProject(solutionProject, null, project);
                                    }
                                }
                            }
                        });
                    }
                    if (!this.$messageBusService.getConnection(this.project.id)) {
                        this.$messageBusService.serverSubscribe(this.project.id, "project", function (sub, msg) {
                            if (msg.action === "layer-update") {
                                msg.data.layer.forEach(function (l) {
                                    var g;
                                    // find group
                                    if (l.groupId) {
                                        g = _this.findGroupById(l.groupId);
                                    }
                                    else {
                                        l.groupId = "main";
                                    }
                                    if (!g) {
                                        g = new Services.ProjectGroup();
                                        g.id = l.groupId;
                                        g.title = msg.data.group.title;
                                        g.clustering = msg.data.group.clustering;
                                        g.clusterLevel = msg.data.group.clusterLevel;
                                        _this.project.groups.push(g);
                                        _this.initGroup(g);
                                    }
                                    else {
                                        g.clustering = msg.data.group.clustering;
                                        g.clusterLevel = msg.data.group.clusterLevel;
                                    }
                                    var layerExists = false;
                                    var layerIndex = 0;
                                    g.layers.forEach(function (gl, index) {
                                        if (gl.id === l.id) {
                                            layerExists = true;
                                            layerIndex = index;
                                        }
                                    });
                                    if (!layerExists) {
                                        g.layers.push(l);
                                        _this.initLayer(g, l);
                                        if (!l.layerSource) {
                                            l.layerSource = _this.layerSources[l.type.toLowerCase()];
                                        }
                                        l.layerSource.refreshLayer(g.layers[g.layers.length - 1]);
                                    }
                                    else {
                                        var currentStyle = g.styles;
                                        if (_this.lastSelectedFeature && _this.lastSelectedFeature.isSelected)
                                            _this.selectFeature(_this.lastSelectedFeature);
                                        if (!l.layerSource)
                                            l.layerSource = _this.layerSources[l.type.toLowerCase()];
                                        l.group = g;
                                        //l.layerSource.refreshLayer(g.layers[layerIndex]);
                                        _this.removeLayer(g.layers[layerIndex]);
                                        _this.addLayer(g.layers[layerIndex], function () {
                                            if (currentStyle && currentStyle.length > 0)
                                                _this.setStyle({ feature: { featureTypeName: l.url + "#" + l.defaultFeatureType, layer: l }, property: currentStyle[0].property, key: currentStyle[0].title, meta: currentStyle[0].meta }, false, null, currentStyle[0]);
                                        });
                                    }
                                    if (_this.$rootScope.$root.$$phase != '$apply' && _this.$rootScope.$root.$$phase != '$digest') {
                                        _this.$rootScope.$apply();
                                    }
                                });
                            }
                            if (msg.action === "layer-remove") {
                                msg.data.forEach(function (l) {
                                    var g;
                                    // find group
                                    if (l.groupId) {
                                        g = _this.findGroupById(l.groupId);
                                    }
                                    else {
                                        l.groupId = "main";
                                    }
                                    if (g != null) {
                                        g.layers.forEach(function (layer) {
                                            if (layer.id == l.id) {
                                                _this.removeLayer(layer, true);
                                            }
                                        });
                                        if (g.layers.length == 0) {
                                            _this.removeGroup(g);
                                        }
                                    }
                                });
                            }
                        });
                    }
                }
                if (prj.hasOwnProperty('collapseAllLayers') && prj.collapseAllLayers === true) {
                    if (this.$rootScope.$root.$$phase != '$apply' && this.$rootScope.$root.$$phase != '$digest') {
                        this.$rootScope.$apply();
                    }
                    this.collapseAll();
                }
                this.$messageBusService.publish('project', 'loaded', this.project);
                if (this.project.dashboards && this.project.dashboards.length > 0) {
                    var startd = this.project.dashboards[Object.keys(this.project.dashboards)[0]];
                    // find dashboard from url
                    if (this.startDashboardId && this.findDashboardById(this.startDashboardId)) {
                        startd = this.findDashboardById(this.startDashboardId);
                    }
                    this.$messageBusService.publish('dashboard-main', 'activated', startd);
                }
            };
            LayerService.prototype.toggleLayer = function (layer) {
                if (layer.group.oneLayerActive && this.findLoadedLayer(layer.id))
                    layer.enabled = false;
                if (layer.enabled) {
                    this.addLayer(layer);
                }
                else {
                    this.removeLayer(layer);
                }
            };
            LayerService.prototype.removeGroup = function (group) {
                var _this = this;
                if (group.layers) {
                    group.layers.forEach(function (l) {
                        if (l.enabled)
                            _this.removeLayer(l, true);
                    });
                }
                group.ndx = null;
                this.project.groups = this.project.groups.filter(function (g) { return g != group; });
                if (this.$rootScope.$root.$$phase != '$apply' && this.$rootScope.$root.$$phase != '$digest') {
                    this.$rootScope.$apply();
                }
            };
            /** initializes project group (create crossfilter index, clustering, initializes layers) */
            LayerService.prototype.initGroup = function (group, layerIds) {
                var _this = this;
                if (group.id == null)
                    group.id = csComp.Helpers.getGuid();
                group.ndx = crossfilter([]);
                if ((group.styles) && (group.styles.length > 0)) {
                    var styleId = group.styles[0].id;
                }
                ;
                if (group.styles == null)
                    group.styles = [];
                if (group.filters == null)
                    group.filters = [];
                group.markers = {};
                if (group.languages != null && this.currentLocale in group.languages) {
                    var locale = group.languages[this.currentLocale];
                    if (locale.title)
                        group.title = locale.title;
                    if (locale.description)
                        group.description = locale.description;
                }
                if (group.clustering) {
                    group.cluster = new L.MarkerClusterGroup({
                        maxClusterRadius: function (zoom) { if (zoom > 18) {
                            return 2;
                        }
                        else {
                            return group.maxClusterRadius || 80;
                        } },
                        disableClusteringAtZoom: group.clusterLevel || 0
                    });
                    group.cluster.on('clustermouseover', function (a) {
                        if (a.layer._childClusters.length === 0) {
                            var childs = a.layer.getAllChildMarkers();
                            if (childs[0] && childs[0].hasOwnProperty('feature')) {
                                var f = childs[0].feature;
                                var actions = _this.getActions(f, ActionType.Hover);
                                actions.forEach(function (fa) {
                                    if (fa.title.toLowerCase() === 'show') {
                                        fa.callback(f, _this);
                                    }
                                });
                            }
                        }
                    });
                    group.cluster.on('clustermouseout', function (a) {
                        if (a.layer._childClusters.length === 0) {
                            var childs = a.layer.getAllChildMarkers();
                            if (childs[0] && childs[0].hasOwnProperty('feature')) {
                                var f = childs[0].feature;
                                var actions = _this.getActions(f, ActionType.Hover);
                                actions.forEach(function (fa) {
                                    if (fa.title.toLowerCase() === 'hide') {
                                        fa.callback(f, _this);
                                    }
                                });
                            }
                        }
                    });
                    this.map.map.addLayer(group.cluster);
                }
                else {
                    group.vectors = new L.LayerGroup();
                    this.map.map.addLayer(group.vectors);
                }
                if (!group.layers)
                    group.layers = [];
                group.layers.forEach(function (layer) {
                    _this.initLayer(group, layer, layerIds);
                });
                group.styles.forEach(function (style) {
                    if (style.id != null)
                        style.id = csComp.Helpers.getGuid();
                });
                group.filters.forEach(function (filter) {
                    if (filter.id != null)
                        filter.id = csComp.Helpers.getGuid();
                });
            };
            /** initializes a layer (check for id, language, references group, add to active map renderer) */
            LayerService.prototype.initLayer = function (group, layer, layerIds) {
                if (layer.id == null)
                    layer.id = csComp.Helpers.getGuid();
                layer.type = (layer.type) ? layer.type.toLowerCase() : "geojson";
                layer.gui = {};
                layer.renderType = (layer.renderType) ? layer.renderType.toLowerCase() : layer.type;
                if (layer.type === "dynamicgeojson")
                    layer.isDynamic = true;
                if (layer.reference == null)
                    layer.reference = layer.id; //Helpers.getGuid();
                if (layer.title == null)
                    layer.title = layer.id;
                if (layer.languages != null && this.currentLocale in layer.languages) {
                    var locale = layer.languages[this.currentLocale];
                    if (locale.title)
                        layer.title = locale.title;
                    if (locale.description)
                        layer.description = locale.description;
                }
                layer.group = group;
                if (!layer.groupId)
                    layer.groupId = group.id;
                if (layer.enabled || (layerIds && layerIds.indexOf(layer.reference.toLowerCase()) >= 0)) {
                    layer.enabled = true;
                    this.addLayer(layer);
                }
            };
            LayerService.prototype.checkDataSourceSubscriptions = function (ds) {
                var _this = this;
                for (var s in ds.sensors) {
                    this.$messageBusService.serverSubscribe(s, "sensor", function (sub, msg) {
                        if (msg.action === "sensor-update") {
                            var d = msg.data[0];
                            var ss = ds.sensors[d.sensor];
                            if (ss != null) {
                                ss.timestamps.push(d.date);
                                ss.values.push(d.value);
                                while (ss.timestamps.length > 30) {
                                    ss.timestamps.shift();
                                    ss.values.shift();
                                }
                                ss.activeValue = d.value;
                                _this.$messageBusService.publish("sensor-" + ds.id + "/" + d.sensor, "update", ss.activeValue);
                                if (_this.$rootScope.$root.$$phase != '$apply' && _this.$rootScope.$root.$$phase != '$digest') {
                                    _this.$rootScope.$apply();
                                }
                            }
                        }
                    });
                }
            };
            LayerService.prototype.checkSubscriptions = function () {
                var _this = this;
                this.project.datasources.forEach(function (ds) {
                    if (ds.url && ds.type === "dynamic") {
                        _this.checkDataSourceSubscriptions(ds);
                    }
                });
            };
            LayerService.prototype.closeProject = function () {
                var _this = this;
                if (this.project == null)
                    return;
                this.project.groups.forEach(function (group) {
                    group.layers.forEach(function (layer) {
                        if (layer.enabled) {
                            _this.removeLayer(layer);
                        }
                    });
                });
            };
            /** Find a sensor set for a specific source/sensor combination. Key should be something like datasource/sensorid */
            LayerService.prototype.findSensorSet = function (key, callback) {
                var kk = key.split('/');
                if (kk.length == 2) {
                    var dataSourceId = kk[0];
                    var sensorId = kk[1];
                    var dss = this.project.datasources.filter(function (ds) { return ds.id === dataSourceId; });
                    if (dss.length === 0) {
                        var ds = new Services.DataSource();
                        ds.id = dataSourceId;
                        ds.type = "dynamic";
                        ds.sensors = {};
                        dss.push(ds);
                        this.project.datasources.push(ds);
                    }
                    ds = dss[0];
                    if (ds.sensors.hasOwnProperty(sensorId)) {
                        callback(ds.sensors[sensorId]);
                    }
                    else {
                        var ss = new Services.SensorSet();
                        ss.id = sensorId;
                        ss.title = sensorId;
                        ss.timestamps = [];
                        ss.values = [];
                        ds.sensors[sensorId] = ss;
                        callback(ss);
                    }
                }
                return null;
            };
            //private zoom(data: any) {
            //    //var a = data;
            //}
            LayerService.prototype.getPropertyValues = function (layer, property) {
                var r = [];
                var features = [];
                if (this.selectedFeatures.length > 1) {
                    features = this.selectedFeatures;
                }
                else {
                    features = (layer.group.filterResult) ? layer.group.filterResult : layer.data.features;
                }
                if (features)
                    features.forEach(function (f) { if (f.layerId === layer.id)
                        r.push(f.properties); });
                if (r.length === 0)
                    r = layer.data.features;
                return r;
            };
            /**
             * Calculate min/max/count for a specific property in a group
             */
            LayerService.prototype.calculatePropertyInfo = function (group, property) {
                var _this = this;
                var r = new Services.PropertyInfo();
                r.count = 0;
                var sum = 0; // stores sum of elements
                var sumsq = 0; // stores sum of squares
                group.layers.forEach(function (l) {
                    if (l.enabled) {
                        _this.project.features.forEach(function (f) {
                            if (f.layerId === l.id && f.properties.hasOwnProperty(property)) {
                                var s = f.properties[property];
                                var v = Number(s);
                                if (!isNaN(v)) {
                                    r.count += 1;
                                    sum = sum + v;
                                    sumsq = sumsq + v * v;
                                    if (r.max == null || v > r.max)
                                        r.max = v;
                                    if (r.min == null || v < r.min)
                                        r.min = v;
                                }
                            }
                        });
                    }
                });
                if (isNaN(sum) || r.count == 0) {
                }
                else {
                    r.mean = sum / r.count;
                    r.varience = sumsq / r.count - r.mean * r.mean;
                    r.sd = Math.sqrt(r.varience);
                }
                if (this.propertyTypeData.hasOwnProperty(property)) {
                    var mid = this.propertyTypeData[property];
                }
                return r;
            };
            LayerService.prototype.updateFilterGroupCount = function (group) {
                if (group.filterResult != null)
                    $('#filtergroupcount_' + group.id).text(group.filterResult.length + ' objecten geselecteerd');
            };
            LayerService.prototype.trackGeometry = function (f, result) {
                var key = "~geometry";
                var log = {
                    ts: new Date().getTime(), prop: key, value: f.geometry
                };
                f.propertiesOld[key] = JSON.parse(JSON.stringify(f.geometry));
                if (!f.logs.hasOwnProperty(key))
                    f.logs[key] = [];
                if (!result.hasOwnProperty(key))
                    result[key] = [];
                f.logs[key].push(log);
                result[key].push(log);
                f.gui["lastUpdate"] = log.ts;
            };
            /**
             * Check for property changes inside a feature, return a set of logs in result
             */
            LayerService.prototype.trackPropertyLog = function (f, key, result) {
                var log = {
                    ts: new Date().getTime(), prop: key, value: f.properties[key]
                };
                f.propertiesOld[key] = JSON.parse(JSON.stringify(f.properties[key]));
                if (!f.logs.hasOwnProperty(key))
                    f.logs[key] = [];
                if (!result.hasOwnProperty(key))
                    result[key] = [];
                f.logs[key].push(log);
                result[key].push(log);
                f.gui["lastUpdate"] = log.ts;
            };
            LayerService.prototype.trackFeature = function (feature) {
                var result = {};
                for (var key in feature.properties) {
                    if (!feature.propertiesOld.hasOwnProperty(key)) {
                        this.trackPropertyLog(feature, key, result);
                    }
                    else if (JSON.stringify(feature.propertiesOld[key]) != JSON.stringify(feature.properties[key])) {
                        this.trackPropertyLog(feature, key, result);
                    }
                }
                if (JSON.stringify(feature.propertiesOld["~geometry"]) != JSON.stringify(feature.geometry))
                    this.trackGeometry(feature, result);
                return result;
            };
            LayerService.prototype.isLocked = function (f) {
                return f.gui.hasOwnProperty('lock') || (f.gui.hasOwnProperty('editMode') && f.gui['editMode']);
            };
            /**
             * Set a lock property on the feature to signal others prevent feature updates
             */
            LayerService.prototype.lockFeature = function (f) {
                if (f.gui.hasOwnProperty('lock')) {
                    return false;
                }
                else {
                    f.gui["lock"] = true;
                    return true;
                }
            };
            LayerService.prototype.unlockFeature = function (f) {
                delete f.gui['lock'];
            };
            LayerService.prototype.saveFeature = function (f, logs) {
                if (logs === void 0) { logs = false; }
                f.properties["updated"] = new Date().getTime();
                // check if feature is in dynamic layer
                if (f.layer.isDynamic) {
                    var l = this.trackFeature(f);
                    if (f.layer.useLog) {
                        var s = new LayerUpdate();
                        s.layerId = f.layerId;
                        s.action = LayerUpdateAction.updateLog;
                        s.item = { featureId: f.id, logs: l };
                        //this.$messageBusService.serverPublish("layer", s);
                        this.$messageBusService.serverSendMessageAction("layer", s);
                    }
                    else {
                        var s = new LayerUpdate();
                        s.layerId = f.layerId;
                        s.action = LayerUpdateAction.updateFeature;
                        s.item = Services.Feature.serialize(f);
                        this.$messageBusService.serverSendMessageAction("layer", s);
                    }
                }
            };
            /***
             * Update map markers in cluster after changing filter
             */
            LayerService.prototype.updateMapFilter = function (group) {
                this.activeMapRenderer.updateMapFilter(group);
                // update timeline list
                this.$messageBusService.publish("timeline", "updateFeatures", group.id);
            };
            LayerService.prototype.resetMapFilter = function (group) {
                var _this = this;
                $.each(group.markers, function (key, marker) {
                    if (group.clustering) {
                        var incluster = group.cluster.hasLayer(marker);
                        if (!incluster)
                            group.cluster.addLayer(marker);
                    }
                    else {
                        var onmap = _this.map.map.hasLayer(marker);
                        if (!onmap)
                            _this.map.map.addLayer(marker);
                    }
                });
            };
            LayerService.$inject = [
                '$location',
                '$compile',
                '$translate',
                'messageBusService',
                'mapService',
                '$rootScope',
                'geoService',
                '$http'
            ];
            return LayerService;
        })();
        Services.LayerService = LayerService;
        /**
         * object for sending layer messages over socket.io channel
         */
        var LayerUpdate = (function () {
            function LayerUpdate() {
            }
            return LayerUpdate;
        })();
        Services.LayerUpdate = LayerUpdate;
        /**
         * List of available action for sending/receiving layer actions over socket.io channel
         */
        (function (LayerUpdateAction) {
            LayerUpdateAction[LayerUpdateAction["updateFeature"] = 0] = "updateFeature";
            LayerUpdateAction[LayerUpdateAction["updateLog"] = 1] = "updateLog";
            LayerUpdateAction[LayerUpdateAction["deleteFeature"] = 2] = "deleteFeature";
        })(Services.LayerUpdateAction || (Services.LayerUpdateAction = {}));
        var LayerUpdateAction = Services.LayerUpdateAction;
        /**
          * Register service
          */
        var moduleName = 'csComp';
        try {
            Services.myModule = angular.module(moduleName);
        }
        catch (err) {
            // named module does not exist, so create one
            Services.myModule = angular.module(moduleName, []);
        }
        Services.myModule.service('layerService', csComp.Services.LayerService);
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        'use strict';
        /*
         * Singleton service that holds a reference to the map.
         * In case other controllers need access to the map, they can inject this service.
         */
        var MapService = (function () {
            function MapService($localStorageService, $timeout, $messageBusService) {
                var _this = this;
                this.$localStorageService = $localStorageService;
                this.$timeout = $timeout;
                this.$messageBusService = $messageBusService;
                this.mapVisible = true;
                this.timelineVisible = false;
                this.rightMenuVisible = true;
                this.initExpertMode();
                this.baseLayers = {};
                this.initMap();
                $messageBusService.subscribe('timeline', function (title, data) {
                    switch (title) {
                        case 'isEnabled':
                            _this.timelineVisible = data;
                            if (_this.timelineVisible) {
                                _this.$timeout(function () { _this.$messageBusService.publish('timeline', 'loadProjectTimeRange'); }, 100);
                            }
                            break;
                    }
                });
                $messageBusService.subscribe('map', function (action, data) {
                    switch (action) {
                        case 'setextent':
                            // console.log(data);
                            _this.map.fitBounds(new L.LatLngBounds(data.southWest, data.northEast));
                            break;
                    }
                });
            }
            /**
          * The expert mode can either be set manually, e.g. using this directive, or by setting the expertMode property in the
          * project.json file. In neither are set, we assume that we are dealing with an expert, so all features should be enabled.
          *
          * Precedence:
          * - when a declaration is absent, assume Expert.
          * - when the mode is set in local storage, take that value.
          * - when the mode is set in the project.json file, take that value.
          */
            MapService.prototype.initExpertMode = function () {
                var _this = this;
                this.expertMode = this.$localStorageService.get(MapService.expertModeKey);
                if (!this.expertMode) {
                    this.expertMode = Services.Expertise.Expert; // Default behaviour
                    // When a project defines the expert mode, overrules default behaviour
                    this.$messageBusService.subscribe('project', function (title, project) {
                        switch (title) {
                            case 'loaded':
                                if (project != null && typeof project.expertMode !== 'undefined')
                                    _this.$messageBusService.publish('expertMode', 'newExpertise', project.expertMode);
                                break;
                        }
                    });
                }
                this.$messageBusService.subscribe('expertMode', function (title, expertMode) {
                    if (title !== 'newExpertise')
                        return;
                    _this.expertMode = expertMode;
                    _this.$localStorageService.set(csComp.Services.MapService.expertModeKey, expertMode); // You first need to set the key
                });
            };
            Object.defineProperty(MapService.prototype, "isExpert", {
                get: function () {
                    return this.expertMode === Services.Expertise.Expert || this.expertMode === Services.Expertise.Admin;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MapService.prototype, "isIntermediate", {
                get: function () {
                    return this.expertMode === Services.Expertise.Expert
                        || this.expertMode === Services.Expertise.Intermediate || this.expertMode === Services.Expertise.Admin;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MapService.prototype, "isAdminExpert", {
                get: function () {
                    return this.expertMode === Services.Expertise.Admin;
                },
                enumerable: true,
                configurable: true
            });
            MapService.prototype.initMap = function () {
                // alert('map service');
                // this.map = L.map("map", {
                //     zoomControl: false,
                //     attributionControl: true
                // });
            };
            MapService.prototype.getBaselayer = function (layer) {
                var layerObj = this.baseLayers[layer];
                return layerObj;
            };
            MapService.prototype.changeBaseLayer = function (layer) {
                var layerObj = this.getBaselayer(layer);
                this.activeBaseLayer = layerObj;
            };
            MapService.prototype.invalidate = function () {
                this.map.invalidateSize(true);
            };
            /**
             * Zoom to a location on the map.
             */
            MapService.prototype.zoomToLocation = function (center, zoomFactor) {
                this.map.setView(center, zoomFactor || 14);
            };
            /**
             * Zoom to a feature on the map.
             */
            MapService.prototype.zoomTo = function (feature, zoomLevel) {
                var _this = this;
                if (zoomLevel === void 0) { zoomLevel = 14; }
                var center;
                if (feature.geometry.type.toUpperCase() == 'POINT') {
                    center = new L.LatLng(feature.geometry.coordinates[1], feature.geometry.coordinates[0]);
                    this.map.setView(center, zoomLevel);
                }
                else {
                    var bb;
                    if (feature.geometry.type.toUpperCase().indexOf("MULTI") < 0)
                        bb = this.getBoundingBox(feature.geometry.coordinates[0]);
                    else {
                        bb = [1000, -1000, 1000, -1000];
                        feature.geometry.coordinates.forEach(function (c) {
                            var b = _this.getBoundingBox(c[0]);
                            bb = [Math.min(bb[0], b[0]), Math.max(bb[1], b[1]), Math.min(bb[2], b[2]), Math.max(bb[3], b[3])];
                        });
                    }
                    var spacingLon = 0.05; // extra spacing left and right, where the menus are.
                    var southWest = L.latLng(Math.min(bb[2], bb[3]), Math.min(bb[0], bb[1]) - spacingLon);
                    var northEast = L.latLng(Math.max(bb[2], bb[3]), Math.max(bb[0], bb[1]) + spacingLon);
                    this.map.fitBounds(new L.LatLngBounds(southWest, northEast));
                }
                this.$messageBusService.publish("sidebar", "show");
                this.$messageBusService.publish("feature", "onFeatureSelect", feature);
            };
            //private getCentroid(arr) {
            //    return arr.reduce((x, y) => [x[0] + y[0] / arr.length, x[1] + y[1] / arr.length], [0, 0]);
            //}
            /**
             * Compute the bounding box.
             * Returns [min_x, max_x, min_y, max_y]
             */
            MapService.prototype.getBoundingBox = function (arr) {
                // p is the previous value of the callback, c the current element of the array.
                return arr.reduce(function (p, c) { return [Math.min(p[0], c[0]), Math.max(p[1], c[0]), Math.min(p[2], c[1]), Math.max(p[3], c[1])]; }, [1000, -1000, 1000, -1000]);
            };
            MapService.prototype.getMap = function () { return this.map; };
            MapService.expertModeKey = 'expertMode';
            MapService.$inject = [
                'localStorageService',
                '$timeout',
                'messageBusService'
            ];
            return MapService;
        })();
        Services.MapService = MapService;
        /**
          * Register service
          */
        var moduleName = 'csComp';
        try {
            Services.myModule = angular.module(moduleName);
        }
        catch (err) {
            // named module does not exist, so create one
            Services.myModule = angular.module(moduleName, []);
        }
        Services.myModule.service('mapService', csComp.Services.MapService);
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

var csComp;
(function (csComp) {
    var Search;
    (function (Search) {
        var SearchFormCtrl = (function () {
            function SearchFormCtrl($scope, $mapService) {
                this.$scope = $scope;
                this.$mapService = $mapService;
                $scope.vm = this;
                $scope.location = new L.LatLng(0, 0);
            }
            SearchFormCtrl.prototype.doSearch = function () {
                if (this.$scope.location.lat === 0 && this.$scope.location.lng === 0) {
                    alert('Directive did not update the location property in parent controller.');
                }
                else {
                    //alert('Yay. Location: ' + this.$scope.location);
                    var center = new L.LatLng(this.$scope.location.lat, this.$scope.location.lng);
                    this.$mapService.zoomToLocation(center);
                }
            };
            // $inject annotation.
            // It provides $injector with information about dependencies to be injected into constructor
            // it is better to have it close to the constructor, because the parameters must match in count and type.
            // See http://docs.angularjs.org/guide/di
            SearchFormCtrl.$inject = [
                '$scope',
                'mapService'
            ];
            return SearchFormCtrl;
        })();
        Search.SearchFormCtrl = SearchFormCtrl;
    })(Search = csComp.Search || (csComp.Search = {}));
})(csComp || (csComp = {}));

var Dashboard;
(function (Dashboard) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Dashboard.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Dashboard.myModule = angular.module(moduleName, []);
    }
    Dashboard.myModule.directive('whenReady', ['$interpolate', function ($interpolate) {
            return {
                restrict: 'A',
                priority: Number.MIN_VALUE,
                link: function ($scope, $element, $attributes) {
                    var expressions = $attributes.whenReady.split(';');
                    var waitForInterpolation = false;
                    var hasReadyCheckExpression = false;
                    function evalExpressions(expressions) {
                        expressions.forEach(function (expression) {
                            $scope.$eval(expression);
                        });
                    }
                    if ($attributes.whenReady.trim().length === 0) {
                        return;
                    }
                    if ($attributes.waitForInterpolation && $scope.$eval($attributes.waitForInterpolation)) {
                        waitForInterpolation = true;
                    }
                    if ($attributes.readyCheck) {
                        hasReadyCheckExpression = true;
                    }
                    if (waitForInterpolation || hasReadyCheckExpression) {
                        requestAnimationFrame(function checkIfReady() {
                            var isInterpolated = false;
                            var isReadyCheckTrue = false;
                            if (waitForInterpolation && $element.text().indexOf($interpolate.startSymbol()) >= 0) {
                                isInterpolated = false;
                            }
                            else {
                                isInterpolated = true;
                            }
                            if (hasReadyCheckExpression && !$scope.$eval($attributes.readyCheck)) {
                                isReadyCheckTrue = false;
                            }
                            else {
                                isReadyCheckTrue = true;
                            }
                            if (isInterpolated && isReadyCheckTrue) {
                                evalExpressions(expressions);
                            }
                            else {
                                requestAnimationFrame(checkIfReady);
                            }
                        });
                    }
                    else {
                        evalExpressions(expressions);
                    }
                }
            };
        }]);
    /**
      * Directive to display the available map layers.
      */
    Dashboard.myModule.directive('dashboardirective', [
        '$window', '$compile',
        function ($window, $compile) {
            return {
                terminal: false,
                restrict: 'E',
                scope: {
                    container: '='
                },
                //template: html, // I use gulp automatian to compile the FeatureProperties.tpl.html to a simple TS file, FeatureProperties.tpl.ts, which contains the html as string. The advantage is that you can use HTML intellisence in the html file.
                templateUrl: 'directives/DashboardDirectives/Dashboard/Dashboard.tpl.html',
                link: function (scope, element, attrs) {
                    // Deal with resizing the element list
                    angular.element($window).bind('resize', function () {
                        //scope.onResizeFunction();
                        scope.$apply();
                    });
                    scope.container = attrs.container;
                    //var s = jQuery.parseJSON(attrs.param);
                    scope.initDashboard();
                },
                replace: false,
                transclude: true,
                controller: Dashboard.DashboardCtrl
            };
        }
    ]);
})(Dashboard || (Dashboard = {}));

var Dashboard;
(function (Dashboard_1) {
    var DashboardCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function DashboardCtrl($scope, $compile, $layerService, $mapService, $messageBusService, $dashboardService, $templateCache, $timeout) {
            //alert('init dashboard ctrl');
            var _this = this;
            this.$scope = $scope;
            this.$compile = $compile;
            this.$layerService = $layerService;
            this.$mapService = $mapService;
            this.$messageBusService = $messageBusService;
            this.$dashboardService = $dashboardService;
            this.$templateCache = $templateCache;
            this.$timeout = $timeout;
            $scope.vm = this;
            $messageBusService.subscribe('project', function (e, f) {
                if (e === "loaded") {
                    $scope.dashboard = null;
                }
            });
            $scope.initDashboard = function () {
                //if (!$scope.container) $scope.container = "main";
                $messageBusService.subscribe("dashboard-" + $scope.container, function (s, d) {
                    _this.project = $layerService.project;
                    _this.project.activeDashboard = d;
                    //alert(this.project.activeDashboard.id);
                    switch (s) {
                        case "activated":
                            $scope.dashboard = d;
                            _this.updateDashboard();
                            break;
                    }
                });
                _this.$messageBusService.subscribe('expertMode', function (title, expertMode) {
                    if (title !== 'newExpertise')
                        return;
                    //Check whether timeline should be visible. Only when at least Intermediate expertise AND dashboard.showTimeline !== false
                    setTimeout(function () {
                        if (_this.project && _this.project.activeDashboard) {
                            var ad = _this.project.activeDashboard;
                            if (_this.$mapService.isIntermediate && (!ad.hasOwnProperty('showTimeline') || ad.showTimeline === true)) {
                                _this.$messageBusService.publish('timeline', 'isEnabled', true);
                            }
                            else {
                                _this.$messageBusService.publish('timeline', 'isEnabled', false);
                            }
                        }
                    }, 50);
                });
                //this.project.activeDashboard.widgets
                //this.updateDashboard();
                //alert($scope.dashboard.name);
            };
        }
        DashboardCtrl.prototype.toggleWidget = function (widget) {
            if (widget.canCollapse) {
                widget.collapse = !widget.collapse;
            }
        };
        DashboardCtrl.prototype.updateWidget = function (w) {
            console.log('updating widget ' + w.directive);
            if (w._initialized && this.$scope.dashboard._initialized)
                return;
            w._initialized = true;
            var widgetElement;
            var newScope = this.$scope;
            newScope.widget = w;
            if (w.template) {
                widgetElement = this.$compile(this.$templateCache.get(w.template))(newScope);
            }
            else if (w.url) {
                widgetElement = this.$compile("<div>url</div>")(this.$scope);
            }
            else if (w.directive) {
                //var newScope : ng.IScope;
                widgetElement = this.$compile("<" + w.directive + "></" + w.directive + ">")(newScope);
            }
            else {
                widgetElement = this.$compile("<h1>hoi</h1>")(this.$scope);
            }
            var resized = function () {
                //alert('resize');
                /* do something */
            };
            if (widgetElement) {
                widgetElement.resize(resized);
                //alert(w.elementId);
                var el = $("#" + w.elementId);
                el.empty();
                el.append(widgetElement);
            }
            if (this.$scope.$root.$$phase != '$apply' && this.$scope.$root.$$phase != '$digest') {
                this.$scope.$apply();
            }
        };
        DashboardCtrl.prototype.toggleInteract = function (widget) {
            widget._interaction = !widget._interaction;
            if (widget._interaction) {
                interact('#' + widget.elementId + '-parent').draggable(true);
            }
            else {
                interact('#' + widget.elementId + '-parent').draggable(false);
            }
        };
        DashboardCtrl.prototype.checkMap = function () {
            if (this.$scope.dashboard.showMap != this.$layerService.visual.mapVisible) {
                if (this.$scope.dashboard.showMap) {
                    this.$layerService.visual.mapVisible = true;
                }
                else {
                    this.$layerService.visual.mapVisible = false;
                }
                if (this.$scope.$root.$$phase != '$apply' && this.$scope.$root.$$phase != '$digest') {
                    this.$scope.$apply();
                }
            }
            if (this.$scope.dashboard.viewBounds) {
                console.log('set bound');
                this.$layerService.activeMapRenderer.fitBounds(this.$scope.dashboard.viewBounds);
            }
            if (this.$scope.dashboard.showMap && this.$scope.dashboard.baselayer) {
                this.$messageBusService.publish("map", "setbaselayer", this.$scope.dashboard.baselayer);
            }
        };
        DashboardCtrl.prototype.checkLayers = function () {
            var _this = this;
            var db = this.$layerService.project.activeDashboard;
            if (db.visiblelayers && db.visiblelayers.length > 0 && this.$layerService.project.groups) {
                this.$layerService.project.groups.forEach(function (g) {
                    g.layers.forEach(function (l) {
                        if (l.enabled && db.visiblelayers.indexOf(l.reference) == -1) {
                            _this.$layerService.removeLayer(l);
                            l.enabled = false;
                        }
                        if (!l.enabled && db.visiblelayers.indexOf(l.reference) >= 0) {
                            _this.$layerService.addLayer(l);
                            l.enabled = true;
                        }
                    });
                });
            }
        };
        DashboardCtrl.prototype.checkViewbound = function () {
            var db = this.$layerService.project.activeDashboard;
            if (db.viewBounds) {
                this.$layerService.activeMapRenderer.fitBounds(db.viewBounds);
            }
        };
        DashboardCtrl.prototype.checkTimeline = function () {
            if (this.$scope.dashboard.showTimeline != this.$mapService.timelineVisible) {
                if (this.$scope.dashboard.showTimeline && this.$mapService.isIntermediate) {
                    this.$mapService.timelineVisible = true;
                }
                else {
                    this.$mapService.timelineVisible = false;
                }
                if (this.$scope.$root.$$phase != '$apply' && this.$scope.$root.$$phase != '$digest') {
                    this.$scope.$apply();
                }
            }
        };
        DashboardCtrl.prototype.setValue = function (diff, value) {
            if (!value || value.indexOf('%') >= 0)
                return value;
            var left = parseInt(value.replace('px', ''));
            left += diff;
            return left + "px";
        };
        DashboardCtrl.prototype.removeWidget = function (widget) {
            this.$scope.dashboard.widgets = this.$scope.dashboard.widgets.filter(function (w) { return w != widget; });
        };
        DashboardCtrl.prototype.isReady = function (widget) {
            var _this = this;
            this.updateWidget(widget);
            setTimeout(function () {
                // select the target node
                // var target = document.querySelector('#' + widget.elementId + '-parent');
                //
                // // create an observer instance
                // var observer = new MutationObserver((mutations) => {
                //     mutations.forEach((mutation) => {
                //         console.log(mutation.type);
                //     });
                // });
                //
                // // configuration of the observer:
                // var config = { attributes: true, childList: true, characterData: true };
                //
                // // pass in the target node, as well as the observer options
                // observer.observe(target, config);
                if (!widget._ijs)
                    widget._ijs = interact('#' + widget.elementId + '-parent')
                        .resizable({ inertia: true })
                        .on('down', function (e) {
                        if (widget._interaction)
                            widget._isMoving = true;
                        if (_this.$dashboardService.activeWidget != widget) {
                        }
                    })
                        .on('up', function (e) { return widget._isMoving = false; })
                        .on('dragmove', function (event) {
                        if (widget.left || (!widget.left && widget.left !== "")) {
                            widget.left = _this.setValue(event.dx, widget.left);
                            if (widget.width && widget.width !== "") {
                                widget.right = "";
                            }
                            else {
                                widget.right = _this.setValue(-event.dx, widget.right);
                            }
                        }
                        else {
                            if (!widget.right || widget.right === "") {
                                widget.right = 1000 + "px";
                            }
                            widget.right = _this.setValue(-event.dx, widget.right);
                        }
                        if (widget.top && widget.top !== "") {
                            widget.top = _this.setValue(event.dy, widget.top);
                            if (widget.bottom) {
                                if (widget.height) {
                                    widget.bottom = "";
                                }
                                else {
                                    widget.bottom = _this.setValue(-event.dy, widget.bottom);
                                }
                            }
                        }
                        else {
                            widget.bottom = _this.setValue(-event.dy, widget.bottom);
                        }
                        if (_this.$scope.$root.$$phase != '$apply' && _this.$scope.$root.$$phase != '$digest') {
                            _this.$scope.$apply();
                        }
                    })
                        .on('resizemove', function (event) {
                        widget.height = _this.setValue(event.dy, widget.height);
                        if (widget.left && widget.right) {
                            widget.right = _this.setValue(-event.dx, widget.right);
                        }
                        else {
                            if (!widget.width)
                                widget.width = "300px";
                            widget.width = _this.setValue(event.dx, widget.width);
                        }
                        if (_this.$scope.$root.$$phase != '$apply' && _this.$scope.$root.$$phase != '$digest') {
                            _this.$scope.$apply();
                        }
                    });
            }, 10);
        };
        // if (!d.widgets) d.widgets = [];
        // if (d.showLegend) {
        //     var legendWidgetPresent = false;
        //     d.widgets.forEach(w => {
        //         if(w.id === 'legend') legendWidgetPresent = true;
        //     });
        //     if (!legendWidgetPresent) {
        //         console.log('Create legend');
        //         var w = <csComp.Services.IWidget>{};
        //         w.directive = 'legend-directive';
        //         w.id = 'legend';
        //         w.title = 'Legenda';
        //         w.data = {mode: 'lastSelectedStyle'};
        //         w.left = '10px';
        //         w.top = '20px';
        //         w.width = '150px';
        //         w.enabled = true;
        //         this.$dashboardService.addNewWidget(w, d);
        //         //this.$dashboardService.selectDashboard(this.$layerService.project.activeDashboard, 'main');
        //     }
        DashboardCtrl.prototype.updateDashboard = function () {
            var _this = this;
            var d = this.$scope.dashboard;
            if (!d)
                return;
            this.checkMap();
            this.checkTimeline();
            this.checkLayers();
            this.checkViewbound();
            //this.$messageBusService.publish("leftmenu",(d.showLeftmenu) ? "show" : "hide");
            if (!this.$mapService.isAdminExpert) {
                this.$layerService.visual.leftPanelVisible = d.showLeftmenu;
                this.$layerService.visual.rightPanelVisible = d.showRightmenu;
            }
            this.$timeout(function () {
                d.widgets.forEach(function (w) {
                    w._initialized = false;
                    _this.updateWidget(w);
                });
                d._initialized = true;
                _this.$scope.$watchCollection('dashboard.widgets', function (da) {
                    _this.$scope.dashboard.widgets.forEach(function (w) {
                        _this.updateWidget(w);
                    });
                });
            }, 100);
            //this.$layerService.rightMenuVisible = d.showLeftmenu;
            //this.$mapService.rightMenuVisible = d.showRightmenu;
            if (this.$scope.$root.$$phase != '$apply' && this.$scope.$root.$$phase != '$digest') {
                this.$scope.$apply();
            }
        };
        //public dashboard: csComp.Services.Dashboard;
        // $inject annotation.
        // It provides $injector with information about dependencies to be in  jected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        DashboardCtrl.$inject = [
            '$scope',
            '$compile',
            'layerService',
            'mapService',
            'messageBusService',
            'dashboardService',
            '$templateCache', '$timeout'
        ];
        return DashboardCtrl;
    })();
    Dashboard_1.DashboardCtrl = DashboardCtrl;
})(Dashboard || (Dashboard = {}));

var DashboarHeaderdSelection;
(function (DashboarHeaderdSelection) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        DashboarHeaderdSelection.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        DashboarHeaderdSelection.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    DashboarHeaderdSelection.myModule.directive('dashboardHeaderSelection', [
        '$window', '$compile',
        function ($window, $compile) {
            return {
                terminal: false,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/DashboardDirectives/DashboardSelection/DashboardHeaderSelection.tpl.html',
                replace: true,
                transclude: true,
                controller: DashboarHeaderdSelection.DashboardHeaderSelectionCtrl
            };
        }
    ]);
})(DashboarHeaderdSelection || (DashboarHeaderdSelection = {}));

var DashboarHeaderdSelection;
(function (DashboarHeaderdSelection) {
    var DashboardHeaderSelectionCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function DashboardHeaderSelectionCtrl($scope, $layerService, $dashboardService, $mapService, $messageBusService) {
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$dashboardService = $dashboardService;
            this.$mapService = $mapService;
            this.$messageBusService = $messageBusService;
            $scope.vm = this;
        }
        DashboardHeaderSelectionCtrl.prototype.childDashboards = function (db) {
            var res = this.$layerService.project.dashboards.filter(function (d) { return (d.parents && d.parents.indexOf(db.id) > -1); });
            return res;
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        DashboardHeaderSelectionCtrl.$inject = [
            '$scope',
            'layerService',
            'dashboardService',
            'mapService',
            'messageBusService'
        ];
        return DashboardHeaderSelectionCtrl;
    })();
    DashboarHeaderdSelection.DashboardHeaderSelectionCtrl = DashboardHeaderSelectionCtrl;
})(DashboarHeaderdSelection || (DashboarHeaderdSelection = {}));

var DashboardSelection;
(function (DashboardSelection) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        DashboardSelection.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        DashboardSelection.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    DashboardSelection.myModule.directive('dashboardSelection', [
        '$window', '$compile',
        function ($window, $compile) {
            return {
                terminal: false,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/DashboardDirectives/DashboardSelection/DashboardSelection.tpl.html',
                //template: html,   // I use gulp automatian to compile the FeatureProperties.tpl.html to a simple TS file, FeatureProperties.tpl.ts, which contains the html as string. The advantage is that you can use HTML intellisence in the html file.
                //compile             : el          => {    // I need to explicitly compile it in order to use interpolation like {{xxx}}
                //    var fn                        = $compile(el);
                //    return scope                  => {
                //        fn(scope);
                //    };
                //},
                link: function (scope, element, attrs) {
                    // Deal with resizing the element list
                    scope.onResizeFunction = function () {
                        var filterHeight = 50;
                        var paginationCtrlHeight = 100;
                        var itemHeight = 60;
                        //scope.windowHeight          = $window.innerHeight;
                        //scope.windowWidth           = $window.innerWidth;
                        scope.numberOfItems = Math.floor(($window.innerHeight - filterHeight - paginationCtrlHeight) / itemHeight);
                    };
                    // Call to the function when the page is first loaded
                    scope.onResizeFunction();
                    angular.element($window).bind('resize', function () {
                        scope.onResizeFunction();
                        scope.$apply();
                    });
                },
                replace: true,
                transclude: true,
                controller: DashboardSelection.DashboardSelectionCtrl
            };
        }
    ]).directive('bsPopover', function () {
        return function (scope, element, attrs) {
            element.find("a[rel=popover]").popover({ placement: 'right', html: 'true' });
        };
    });
})(DashboardSelection || (DashboardSelection = {}));

var DashboardSelection;
(function (DashboardSelection) {
    var DashboardSelectionCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function DashboardSelectionCtrl($scope, $layerService, $dashboardService, $mapService, $messageBusService) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$dashboardService = $dashboardService;
            this.$mapService = $mapService;
            this.$messageBusService = $messageBusService;
            $scope.vm = this;
            this.$messageBusService.subscribe('project', function (s, a) {
                _this.style = "default";
                _this.selectStyle();
            });
        }
        DashboardSelectionCtrl.prototype.initDrag = function (key) {
            var _this = this;
            var transformProp;
            var startx, starty;
            interact('#widgettype-' + key)
                .draggable({ max: Infinity })
                .on('dragstart', function (event) {
                startx = 0;
                starty = 0;
                event.interaction.x = parseInt(event.target.getAttribute('data-x'), 10) || 0;
                event.interaction.y = parseInt(event.target.getAttribute('data-y'), 10) || 0;
                event.target.style.width = "300px";
                event.target.style.height = "300px";
            })
                .on('dragmove', function (event) {
                event.interaction.x += event.dx;
                event.interaction.y += event.dy;
                event.target.style.left = event.interaction.x + 'px';
                event.target.style.top = event.interaction.y + 'px';
            })
                .on('dragend', function (event) {
                setTimeout(function () {
                    var widget = {};
                    widget.directive = key;
                    widget.id = csComp.Helpers.getGuid();
                    widget.left = (event.clientX - 350) + "px"; //(parseInt(event.target.style.left.replace('px', '')) - 150) + "px";
                    widget.top = (event.clientY - 50) + "px"; //(parseInt(event.target.style.top.replace('px', '')) - 150) + "px";
                    widget.data = {};
                    widget.width = '300px';
                    widget.height = '300px';
                    widget.style = _this.style;
                    widget.enabled = true;
                    csComp.Services.Dashboard.addNewWidget(widget, _this.$layerService.project.activeDashboard, _this.$layerService.solution);
                    _this.$dashboardService.editWidget(widget);
                }, 100);
                //this.$dashboardService.mainDashboard.widgets.push(widget);
                event.target.setAttribute('data-x', 0);
                event.target.setAttribute('data-y', 0);
                event.target.style.left = '0px';
                event.target.style.top = '0px';
                event.target.style.width = "75px";
                event.target.style.height = "75px";
                console.log(key);
            });
        };
        DashboardSelectionCtrl.prototype.startWidgetEdit = function (widget) {
            this.$dashboardService.editWidget(widget);
        };
        /***
        Start editing a specific dashboard
        */
        DashboardSelectionCtrl.prototype.startDashboardEdit = function (dashboard) {
            var rpt = new csComp.Services.RightPanelTab();
            rpt.container = "dashboard";
            rpt.data = dashboard;
            rpt.directive = "dashboardedit";
            this.$messageBusService.publish("rightpanel", "activate", rpt);
            this.$layerService.project.dashboards.forEach(function (d) {
                if (d.id !== dashboard.id) {
                    d.editMode = false;
                    d.disabled = true;
                }
            });
            this.$dashboardService.stopEditWidget();
        };
        /***
        Stop editing a specific dashboard
        */
        DashboardSelectionCtrl.prototype.stopDashboardEdit = function (dashboard) {
            this.$layerService.project.dashboards.forEach(function (d) {
                d.disabled = false;
                d.editMode = false;
            });
            this.$dashboardService.stopEditWidget();
        };
        DashboardSelectionCtrl.prototype.stopEdit = function () {
            this.stopDashboardEdit(this.$layerService.project.activeDashboard);
        };
        DashboardSelectionCtrl.prototype.startEdit = function () {
        };
        DashboardSelectionCtrl.prototype.widgetHighlight = function (widget) {
            widget.hover = true;
        };
        DashboardSelectionCtrl.prototype.widgetStopHighlight = function (widget) {
            widget.hover = false;
        };
        /** Add new dashboard */
        DashboardSelectionCtrl.prototype.addDashboard = function (widget) {
            var id = csComp.Helpers.getGuid();
            var d = new csComp.Services.Dashboard();
            d.id = id;
            d.showLeftmenu = true;
            d.showMap = true;
            d.name = "New Dashboard";
            this.$layerService.project.dashboards.push(d);
        };
        /** Remove existing dashboard */
        DashboardSelectionCtrl.prototype.removeDashboard = function (key) {
            this.$layerService.project.dashboards = this.$layerService.project.dashboards.filter(function (s) { return s.id !== key; });
        };
        DashboardSelectionCtrl.prototype.selectStyle = function () {
            this.$scope.widgetStyle = this.$layerService.solution.widgetStyles[this.style];
            console.log(this.$scope.widgetStyle);
        };
        /** publish a message that a new dashboard was selected */
        DashboardSelectionCtrl.prototype.publishDashboardUpdate = function () {
            this.$messageBusService.publish('dashboard', 'onDashboardSelected', this.$layerService.project.activeDashboard);
        };
        /** Select an active dashboard */
        DashboardSelectionCtrl.prototype.selectDashboard = function (dashboard) {
            var _this = this;
            //var res = JSON.stringify(this.$dashboardService.dashboards);
            for (var key in this.$layerService.project.dashboards) {
                this.$layerService.project.dashboards[key].editMode = false;
            }
            if (dashboard) {
                //this.$dashboardService.mainDashboard = dashboard;
                if (this.$scope.$root.$$phase != '$apply' && this.$scope.$root.$$phase != '$digest') {
                    this.$scope.$apply();
                }
                setTimeout(function () {
                    //this.$dashboardService.checkMap();
                    //this.checkTimeline();
                    //this.checkViewbound();
                    _this.publishDashboardUpdate();
                    //this.checkLayers();
                }, 100);
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        DashboardSelectionCtrl.$inject = [
            '$scope',
            'layerService',
            'dashboardService',
            'mapService',
            'messageBusService'
        ];
        return DashboardSelectionCtrl;
    })();
    DashboardSelection.DashboardSelectionCtrl = DashboardSelectionCtrl;
})(DashboardSelection || (DashboardSelection = {}));

var DashboardEdit;
(function (DashboardEdit) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        DashboardEdit.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        DashboardEdit.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a feature's properties in a panel.
      *
      * @seealso          : http://www.youtube.com/watch?v=gjJ5vLRK8R8&list=UUGD_0i6L48hucTiiyhb5QzQ
      * @seealso          : http://plnkr.co/edit/HyBP9d?p=preview
      */
    DashboardEdit.myModule.directive('dashboardedit', ['$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/DashboardDirectives/WidgetEdit/DashboardEdit.tpl.html',
                replace: true,
                transclude: true,
                controller: DashboardEdit.DashboardEditCtrl
            };
        }
    ]);
})(DashboardEdit || (DashboardEdit = {}));

var DashboardEdit;
(function (DashboardEdit) {
    var DashboardEditCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function DashboardEditCtrl($scope, $mapService, $layerService, $messageBusService, $dashboardService) {
            this.$scope = $scope;
            this.$mapService = $mapService;
            this.$layerService = $layerService;
            this.$messageBusService = $messageBusService;
            this.$dashboardService = $dashboardService;
            this.scope = $scope;
            $scope.vm = this;
            this.dashboard = $scope.$parent["data"];
            if (this.dashboard.parents && this.dashboard.parents.length > 0)
                this.parent = this.dashboard.parents[0];
            this.updateHasParent();
            console.log(this.$dashboardService.widgetTypes);
            // setup draggable elements.
        }
        DashboardEditCtrl.prototype.updateHasParent = function () {
            return;
            if (this.parent !== "")
                this.dashboard.parents = [this.parent];
            this.hasParent = this.dashboard.parents && this.dashboard.parents.length > 0;
        };
        DashboardEditCtrl.prototype.toggleTimeline = function () {
            //this.$dashboardService.mainDashboard.showTimeline = !this.$dashboardService.mainDashboard.showTimeline;
            this.checkTimeline();
            this.$layerService.project.dashboards;
        };
        DashboardEditCtrl.prototype.toggleLegend = function () {
            this.checkLegend();
            this.$layerService.project.dashboards;
        };
        DashboardEditCtrl.prototype.setExtent = function () {
            this.dashboard.viewBounds = this.$layerService.activeMapRenderer.getExtent();
            console.log('set extent');
        };
        DashboardEditCtrl.prototype.setVisibleLayers = function () {
            this.dashboard.visiblelayers = [];
            for (var id in this.$layerService.loadedLayers)
                this.dashboard.visiblelayers.push(id);
        };
        DashboardEditCtrl.prototype.toggleMap = function () {
            var _this = this;
            setTimeout(function () {
                _this.checkMap();
            }, 100);
        };
        DashboardEditCtrl.prototype.checkMap = function () {
            var db = this.$layerService.project.activeDashboard;
            if (db.showMap != this.$layerService.visual.mapVisible) {
                if (db.showMap) {
                    this.$layerService.visual.mapVisible = true;
                }
                else {
                    this.$layerService.visual.mapVisible = false;
                }
                if (this.$scope.$root.$$phase != '$apply' && this.$scope.$root.$$phase != '$digest') {
                    this.$scope.$apply();
                }
            }
            if (db.showMap && this.dashboard.baselayer) {
                this.$messageBusService.publish("map", "setbaselayer", this.dashboard.baselayer);
            }
        };
        DashboardEditCtrl.prototype.checkTimeline = function () {
            var db = this.$layerService.project.activeDashboard;
            if (db.timeline) {
                var s = new Date(db.timeline.start);
                var e = new Date();
                if (db.timeline.end)
                    e = new Date(db.timeline.end);
                //this.$messageBusService.publish("timeline", "updateTimerange", { "start": s, "end": e});
                this.$messageBusService.publish("timeline", "updateTimerange", { start: s, end: e });
            }
            if (db.showTimeline != this.$mapService.timelineVisible) {
                if (db.showTimeline) {
                    this.$mapService.timelineVisible = true;
                }
                else {
                    this.$mapService.timelineVisible = false;
                }
                if (this.$scope.$root.$$phase != '$apply' && this.$scope.$root.$$phase != '$digest') {
                    this.$scope.$apply();
                }
            }
        };
        DashboardEditCtrl.prototype.checkLegend = function () {
            var db = this.$layerService.project.activeDashboard;
            if (!db.showLegend) {
                var idxDelete = -1;
                db.widgets.forEach(function (w, idx) {
                    if (w.id === 'legend') {
                        idxDelete = idx;
                    }
                });
                if (idxDelete > -1)
                    db.widgets.splice(idxDelete, 1);
            }
            this.$dashboardService.selectDashboard(db, 'main');
            if (this.$scope.$root.$$phase != '$apply' && this.$scope.$root.$$phase != '$digest') {
                this.$scope.$apply();
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        DashboardEditCtrl.$inject = [
            '$scope',
            'mapService',
            'layerService',
            'messageBusService',
            'dashboardService'
        ];
        return DashboardEditCtrl;
    })();
    DashboardEdit.DashboardEditCtrl = DashboardEditCtrl;
})(DashboardEdit || (DashboardEdit = {}));

var WidgetEdit;
(function (WidgetEdit) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        WidgetEdit.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        WidgetEdit.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a feature's properties in a panel.
      *
      * @seealso          : http://www.youtube.com/watch?v=gjJ5vLRK8R8&list=UUGD_0i6L48hucTiiyhb5QzQ
      * @seealso          : http://plnkr.co/edit/HyBP9d?p=preview
      */
    WidgetEdit.myModule.directive('widgetedit', ['$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/DashboardDirectives/WidgetEdit/WidgetEdit.tpl.html',
                replace: true,
                transclude: true,
                controller: WidgetEdit.WidgetEditCtrl
            };
        }
    ]);
})(WidgetEdit || (WidgetEdit = {}));

var WidgetEdit;
(function (WidgetEdit) {
    var WidgetEditCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function WidgetEditCtrl($scope, mapService, layerService, messageBusService, dashboardService) {
            this.$scope = $scope;
            this.mapService = mapService;
            this.layerService = layerService;
            this.messageBusService = messageBusService;
            this.dashboardService = dashboardService;
            this.scope = $scope;
            $scope.vm = this;
            $scope.widget = dashboardService.activeWidget;
        }
        WidgetEditCtrl.prototype.selectStyle = function () {
            var style = this.$scope.widget.style;
            if (style === "custom") {
                this.$scope.widget.customStyle = JSON.parse(JSON.stringify(this.$scope.widget.effectiveStyle));
                this.$scope.widget.effectiveStyle = this.$scope.widget.customStyle;
            }
            else {
                this.$scope.widget.effectiveStyle = this.layerService.solution.widgetStyles[style];
                this.$scope.widget.customStyle = null;
            }
        };
        WidgetEditCtrl.prototype.removeWidget = function (widget) {
            widget.parentDashboard.widgets = widget.parentDashboard.widgets.filter(function (w) { return widget.id != w.id; });
            this.dashboardService.deactivateTabContainer("widget-content");
            this.dashboardService.deactivateTabContainer("widget");
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        WidgetEditCtrl.$inject = [
            '$scope',
            'mapService',
            'layerService',
            'messageBusService',
            'dashboardService'
        ];
        return WidgetEditCtrl;
    })();
    WidgetEdit.WidgetEditCtrl = WidgetEditCtrl;
})(WidgetEdit || (WidgetEdit = {}));

var FeatureTypeEditor;
(function (FeatureTypeEditor) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        FeatureTypeEditor.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        FeatureTypeEditor.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a feature's properties in a panel.
      *
      * @seealso          : http://www.youtube.com/watch?v=gjJ5vLRK8R8&list=UUGD_0i6L48hucTiiyhb5QzQ
      * @seealso          : http://plnkr.co/edit/HyBP9d?p=preview
      */
    FeatureTypeEditor.myModule.directive('featureTypeEditor', ['$compile',
        function ($compile) {
            return {
                terminal: false,
                restrict: 'E',
                scope: {
                    featureTypeId: '='
                },
                templateUrl: 'directives/Editors/FeatureTypeEditor/FeatureTypeEditor.tpl.html',
                replace: true,
                transclude: true,
                controller: FeatureTypeEditor.FeatureTypeEditorCtrl
            };
        }
    ])
        .directive('errSrc', function () {
        return {
            link: function (scope, element, attrs) {
                element.bind('error', function () {
                    if (attrs.src != attrs.errSrc) {
                        attrs.$set('src', attrs.errSrc);
                    }
                });
            }
        };
    });
})(FeatureTypeEditor || (FeatureTypeEditor = {}));

var FeatureTypeEditor;
(function (FeatureTypeEditor) {
    var FeatureTypeEditorCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function FeatureTypeEditorCtrl($scope, $layerService, $messageBusService) {
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBusService = $messageBusService;
            this.$scope.vm = this;
            if (this.$scope.$root.hasOwnProperty('data')) {
                $scope.featureType = $scope.$parent.$parent.vm.featureType;
                console.log('feature type editor');
                console.log($scope.featureType);
            }
            else {
                console.log('no feature type');
            }
        }
        //** force features to be updated */
        FeatureTypeEditorCtrl.prototype.updateFeatureTypes = function (ft) {
            this.$layerService.updateFeatureTypes(ft);
        };
        ;
        // $inject annotation.
        // It provides $injector with information about dependencies to be in  jected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        FeatureTypeEditorCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService'
        ];
        return FeatureTypeEditorCtrl;
    })();
    FeatureTypeEditor.FeatureTypeEditorCtrl = FeatureTypeEditorCtrl;
})(FeatureTypeEditor || (FeatureTypeEditor = {}));

var FeatureTypes;
(function (FeatureTypes) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        FeatureTypes.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        FeatureTypes.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a feature's properties in a panel.
      *
      * @seealso          : http://www.youtube.com/watch?v=gjJ5vLRK8R8&list=UUGD_0i6L48hucTiiyhb5QzQ
      * @seealso          : http://plnkr.co/edit/HyBP9d?p=preview
      */
    FeatureTypes.myModule.directive('featuretypes', ['$compile',
        function ($compile) {
            return {
                terminal: false,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Editors/FeatureTypeEditor/FeatureTypes.tpl.html',
                replace: true,
                transclude: true,
                controller: FeatureTypes.FeatureTypesCtrl
            };
        }
    ])
        .directive('errSrc', function () {
        return {
            link: function (scope, element, attrs) {
                element.bind('error', function () {
                    if (attrs.src != attrs.errSrc) {
                        attrs.$set('src', attrs.errSrc);
                    }
                });
            }
        };
    });
})(FeatureTypes || (FeatureTypes = {}));

var FeatureTypes;
(function (FeatureTypes) {
    var FeatureTypesCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function FeatureTypesCtrl($scope, $layerService, $messageBusService) {
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBusService = $messageBusService;
            this.$scope.vm = this;
            if (this.$scope.$root.hasOwnProperty('data')) {
                $scope.data = $scope.$root['data'];
                this.selectedResourceUrl = $scope.data.layer.typeUrl;
                this.selectResource();
            }
            console.log(this.$scope);
        }
        //** force features to be updated */
        FeatureTypesCtrl.prototype.updateFeatureTypes = function (ft) {
            this.$layerService.updateFeatureTypes(ft);
        };
        ;
        //** select a typesResource collection from the dropdown */
        FeatureTypesCtrl.prototype.selectResource = function () {
            if (this.$layerService.typesResources.hasOwnProperty(this.selectedResourceUrl)) {
                this.selectedResource = this.$layerService.typesResources[this.selectedResourceUrl];
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be in  jected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        FeatureTypesCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService'
        ];
        return FeatureTypesCtrl;
    })();
    FeatureTypes.FeatureTypesCtrl = FeatureTypesCtrl;
})(FeatureTypes || (FeatureTypes = {}));

var GroupEdit;
(function (GroupEdit) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        GroupEdit.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        GroupEdit.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a feature's properties in a panel.
      *
      * @seealso          : http://www.youtube.com/watch?v=gjJ5vLRK8R8&list=UUGD_0i6L48hucTiiyhb5QzQ
      * @seealso          : http://plnkr.co/edit/HyBP9d?p=preview
      */
    GroupEdit.myModule.directive('groupedit', ['$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Editors/GroupEditor/GroupEdit.tpl.html',
                replace: true,
                transclude: true,
                controller: GroupEdit.GroupEditCtrl
            };
        }
    ]);
})(GroupEdit || (GroupEdit = {}));

var GroupEdit;
(function (GroupEdit) {
    var GroupEditCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function GroupEditCtrl($scope, $mapService, $layerService, $messageBusService, $dashboardService) {
            var _this = this;
            this.$scope = $scope;
            this.$mapService = $mapService;
            this.$layerService = $layerService;
            this.$messageBusService = $messageBusService;
            this.$dashboardService = $dashboardService;
            this.noLayerSelected = true;
            this.scope = $scope;
            $scope.vm = this;
            $scope.group = $scope.$parent["data"];
            console.log($scope.group);
            this.updateLayers();
            this.$messageBusService.subscribe('layer', function () {
                _this.updateLayers();
            });
        }
        GroupEditCtrl.prototype.updateLayers = function () {
            this.noLayerSelected = this.$scope.group.layers.some(function (l) { return l.enabled; });
            //console.log("selected " + this.noLayerSelected)
            //this.$scope.group.oneLayerActive
        };
        GroupEditCtrl.prototype.removeGroup = function () {
            this.$layerService.removeGroup(this.$scope.group);
        };
        GroupEditCtrl.prototype.toggleClustering = function () {
            console.log('toggle clustering');
        };
        GroupEditCtrl.prototype.updateOws = function () {
            this.$scope.group.loadLayersFromOWS();
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        GroupEditCtrl.$inject = [
            '$scope',
            'mapService',
            'layerService',
            'messageBusService',
            'dashboardService'
        ];
        return GroupEditCtrl;
    })();
    GroupEdit.GroupEditCtrl = GroupEditCtrl;
})(GroupEdit || (GroupEdit = {}));

var LayerEdit;
(function (LayerEdit) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        LayerEdit.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        LayerEdit.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a feature's properties in a panel.
      *
      * @seealso          : http://www.youtube.com/watch?v=gjJ5vLRK8R8&list=UUGD_0i6L48hucTiiyhb5QzQ
      * @seealso          : http://plnkr.co/edit/HyBP9d?p=preview
      */
    LayerEdit.myModule.directive('layeredit', ['$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Editors/LayerEditor/LayerEdit.tpl.html',
                replace: false,
                transclude: true,
                controller: LayerEdit.LayerEditCtrl
            };
        }
    ]);
})(LayerEdit || (LayerEdit = {}));

var LayerEdit;
(function (LayerEdit) {
    var LayerEditCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function LayerEditCtrl($scope, $http, $mapService, $layerService, $messageBusService, $dashboardService) {
            this.$scope = $scope;
            this.$http = $http;
            this.$mapService = $mapService;
            this.$layerService = $layerService;
            this.$messageBusService = $messageBusService;
            this.$dashboardService = $dashboardService;
            this.scope = $scope;
            $scope.vm = this;
            this.layer = $scope.$parent["data"];
            this.getTypes();
            var ft = {};
        }
        LayerEditCtrl.prototype.addLayer = function () {
        };
        LayerEditCtrl.prototype.removeLayer = function () {
            this.$layerService.removeLayer(this.layer, true);
        };
        LayerEditCtrl.prototype.addFeatureType = function () {
            var _this = this;
            if (this.layer.typeUrl) {
                this.$layerService.loadTypeResources(this.layer.typeUrl, this.layer.dynamicResource || false, function () {
                    if (_this.$layerService.typesResources.hasOwnProperty(_this.layer.typeUrl)) {
                        var r = _this.$layerService.typesResources[_this.layer.typeUrl];
                        var ft = {};
                        var id = _this.layer.typeUrl + "#" + _this.layer.defaultFeatureType;
                        ft.id = _this.layer.defaultFeatureType;
                        ft.name = ft.id;
                        ft.style = csComp.Helpers.getDefaultFeatureStyle();
                        if (!r.featureTypes.hasOwnProperty(id)) {
                            var ft = {};
                            ft.id = _this.layer.defaultFeatureType;
                            ft.name = ft.id;
                            // EV already called before.
                            //ft.style = csComp.Helpers.getDefaultFeatureStyle();
                            //if (ft.name.toLowerCase().startsWith("http://")) id = ft.name;
                            //if (csComp.Helpers.startsWith(name.toLowerCase(), "http://")) return name;
                            _this.$layerService._featureTypes[id] = ft;
                            r.featureTypes[ft.id] = ft;
                        }
                    }
                });
            }
        };
        LayerEditCtrl.prototype.getTypes = function () {
            var _this = this;
            console.log('its me babe');
            this.$http.get(this.layer.typeUrl)
                .success(function (response) {
                setTimeout(function () {
                    _this.availabeTypes = response.featureTypes;
                    console.log(_this.availabeTypes);
                }, 0);
            })
                .error(function () { console.log('LayerEditCtl: error with $http'); });
        };
        ;
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        LayerEditCtrl.$inject = [
            '$scope',
            '$http',
            'mapService',
            'layerService',
            'messageBusService',
            'dashboardService'
        ];
        return LayerEditCtrl;
    })();
    LayerEdit.LayerEditCtrl = LayerEditCtrl;
})(LayerEdit || (LayerEdit = {}));

var PropertyTypes;
(function (PropertyTypes) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        PropertyTypes.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        PropertyTypes.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a feature's properties in a panel.
      *
      * @seealso          : http://www.youtube.com/watch?v=gjJ5vLRK8R8&list=UUGD_0i6L48hucTiiyhb5QzQ
      * @seealso          : http://plnkr.co/edit/HyBP9d?p=preview
      */
    PropertyTypes.myModule.directive('propertytypes', ['$compile',
        function ($compile) {
            return {
                terminal: false,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Editors/PropertyTypeEditor/PropertyTypes.tpl.html',
                replace: true,
                transclude: true,
                controller: PropertyTypes.PropertyTypesCtrl
            };
        }
    ])
        .directive('ngEnter', function () {
        return function (scope, element, attrs) {
            element.bind("keydown keypress", function (event) {
                if (event.which === 13) {
                    scope.$apply(function () {
                        scope.$eval(attrs.ngEnter);
                    });
                    event.preventDefault();
                }
            });
        };
    });
})(PropertyTypes || (PropertyTypes = {}));

var PropertyTypes;
(function (PropertyTypes) {
    var PropertyTypesCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function PropertyTypesCtrl($scope, $layerService, $messageBusService) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBusService = $messageBusService;
            this.editModeMessageReceived = function (title) {
                switch (title) {
                    case "enable":
                        _this.$messageBusService.publish("sidebar", "showEdit");
                        _this.$scope.vm = _this;
                        _this.$scope.propertyTypes = _this.$layerService.project.propertyTypeData;
                        break;
                    case "disable":
                        _this.$messageBusService.publish("sidebar", "hideEdit");
                        break;
                    default:
                }
                // NOTE EV: You need to call apply only when an event is received outside the angular scope.
                // However, make sure you are not calling this inside an angular apply cycle, as it will generate an error.
                if (_this.$scope.$root.$$phase != '$apply' && _this.$scope.$root.$$phase != '$digest') {
                    _this.$scope.$apply();
                }
            };
            /**
             * Callback function
             * @see {http://stackoverflow.com/questions/12756423/is-there-an-alias-for-this-in-typescript}
             * @see {http://stackoverflow.com/questions/20627138/typescript-this-scoping-issue-when-called-in-jquery-callback}
             * @todo {notice the strange syntax using a fat arrow =>, which is to preserve the this reference in a callback!}
             */
            this.sidebarMessageReceived = function (title) {
                //console.log("sidebarMessageReceived");
                switch (title) {
                    case "toggle":
                        _this.$scope.showMenu = !_this.$scope.showMenu;
                        break;
                    case "show":
                        _this.$scope.showMenu = true;
                        break;
                    case "showEdit":
                        _this.$scope.showMenuEdit = true;
                        break;
                    case "hide":
                        _this.$scope.showMenu = false;
                        break;
                    case "hideEdit":
                        _this.$scope.showMenuEdit = false;
                        break;
                    default:
                }
                // NOTE EV: You need to call apply only when an event is received outside the angular scope.
                // However, make sure you are not calling this inside an angular apply cycle, as it will generate an error.
                if (_this.$scope.$root.$$phase != '$apply' && _this.$scope.$root.$$phase != '$digest') {
                    _this.$scope.$apply();
                }
            };
            console.log('prop editor');
            this.$scope.vm = this;
            this.$scope.showMenu = false;
            this.$scope.showMenuEdit = false;
            if (this.$scope.$root.$$phase != '$apply' && this.$scope.$root.$$phase != '$digest') {
                this.$scope.$apply();
            }
            this.$messageBusService.subscribe("editmode", this.editModeMessageReceived);
            this.$messageBusService.subscribe("sidebar", this.sidebarMessageReceived);
            /**
             * Get all sections from the available PropertyTypes
             */
            $scope.getSections = function () {
                var propertyTypeData = _this.selectedResource.propertyTypeData;
                var newSections = new Array();
                for (var indexData in propertyTypeData) {
                    var add = true;
                    if (propertyTypeData[indexData].section != undefined) {
                        if (newSections.length == 0) {
                            newSections.push(propertyTypeData[indexData].section);
                        }
                        for (var indexNew in newSections) {
                            if (propertyTypeData[indexData].section == newSections[indexNew]) {
                                add = false;
                            }
                        }
                        if (add) {
                            newSections.push(propertyTypeData[indexData].section);
                        }
                    }
                }
                $scope.sections = newSections;
            };
            /**
             * Add a new section to sections array
             */
            $scope.addSection = function (name) {
                var sections = $scope.sections;
                var add = true;
                for (var index in sections) {
                    if (name == sections[index]) {
                        add = false;
                    }
                }
                if (add) {
                    $scope.sections.push(name);
                }
            };
            /**
             * Create an array with all the PropertyTypes for a features (or all features if no feature is selected)
             */
            $scope.filterProperty = function (selectedData) {
                var allPropertyTypes = _this.selectedResource.propertyTypeData;
                var propertyTypes = new Array();
                if (selectedData == undefined) {
                    // All property types are selected
                    for (var index in allPropertyTypes) {
                        propertyTypes.push(allPropertyTypes[index]);
                    }
                    $scope.propertyTypes = propertyTypes;
                }
                else {
                    // Property types of a feature is selected
                    var selectedPropertyTypes;
                    if (selectedData.propertyTypeKeys !== undefined) {
                        selectedPropertyTypes = selectedData.propertyTypeKeys.split(';');
                    }
                    for (var indexSelected in selectedPropertyTypes) {
                        for (var indexAll in allPropertyTypes) {
                            if (allPropertyTypes.hasOwnProperty(indexAll)) {
                                if (selectedPropertyTypes[indexSelected] == allPropertyTypes[indexAll].label) {
                                    propertyTypes.push(allPropertyTypes[indexAll]);
                                }
                            }
                        }
                    }
                    $scope.propertyTypes = propertyTypes;
                }
            };
        }
        //** select a typesResource collection from the dropdown */
        PropertyTypesCtrl.prototype.selectResource = function () {
            if (this.$layerService.typesResources.hasOwnProperty(this.selectedResourceUrl)) {
                this.selectedResource = this.$layerService.typesResources[this.selectedResourceUrl];
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be in  jected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        PropertyTypesCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService'
        ];
        return PropertyTypesCtrl;
    })();
    PropertyTypes.PropertyTypesCtrl = PropertyTypesCtrl;
})(PropertyTypes || (PropertyTypes = {}));

var ChartsWidget;
(function (ChartsWidget) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        ChartsWidget.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        ChartsWidget.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    ChartsWidget.myModule.directive('chartsEdit', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/Charts/Charts-edit.tpl.html',
                replace: true,
                transclude: true,
                controller: ChartsEditCtrl
            };
        }
    ]);
    var ChartsEditCtrl = (function () {
        function ChartsEditCtrl($scope, $timeout, $compile, $layerService, $templateCache, $messageBus, $mapService, $dashboardService) {
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$compile = $compile;
            this.$layerService = $layerService;
            this.$templateCache = $templateCache;
            this.$messageBus = $messageBus;
            this.$mapService = $mapService;
            this.$dashboardService = $dashboardService;
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = par.data;
            $scope.data = this.widget.data;
            this.loadChart();
        }
        ChartsEditCtrl.prototype.setupEditor = function () {
            this.editor = ace.edit("vegaeditor");
            //editor.setTheme("ace/theme/monokai");
            this.editor.getSession().setMode("ace/mode/json");
            this.editor.setValue(JSON.stringify(this.$scope.data.spec, null, '\t'));
            this.editor.clearSelection();
            this.editor.focus();
        };
        ChartsEditCtrl.prototype.loadChart = function () {
            this.$scope.spec = JSON.stringify(this.$scope.data.spec);
        };
        ChartsEditCtrl.prototype.updateChart = function () {
            this.$scope.data.spec = JSON.parse(this.editor.getValue());
            this.refreshChart();
            this.editor.focus();
        };
        ChartsEditCtrl.prototype.refreshChart = function () {
            var _this = this;
            vg.parse.spec(this.$scope.data.spec, function (chart) { chart({ el: "#vis" + _this.$scope.data._id }).update(); });
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        ChartsEditCtrl.$inject = [
            '$scope',
            '$timeout',
            '$compile',
            'layerService',
            '$templateCache',
            'messageBusService',
            'mapService', 'dashboardService'
        ];
        return ChartsEditCtrl;
    })();
    ChartsWidget.ChartsEditCtrl = ChartsEditCtrl;
})(ChartsWidget || (ChartsWidget = {}));

var ChartsWidget;
(function (ChartsWidget) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        ChartsWidget.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        ChartsWidget.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    ChartsWidget.myModule.directive('charts', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/Charts/Charts.tpl.html',
                replace: true,
                transclude: false,
                controller: ChartsWidget.ChartCtrl
            };
        }
    ]);
})(ChartsWidget || (ChartsWidget = {}));

var ChartsWidget;
(function (ChartsWidget) {
    var ChartData = (function () {
        function ChartData() {
        }
        return ChartData;
    })();
    ChartsWidget.ChartData = ChartData;
    var ChartCtrl = (function () {
        function ChartCtrl($scope, $timeout, $layerService, $messageBus, $mapService) {
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.$mapService = $mapService;
            this.defaultSpec = {
                "width": 300,
                "height": 200,
                "padding": { "top": 10, "left": 30, "bottom": 30, "right": 10 },
                "data": [
                    {
                        "name": "table",
                        "values": [
                            { "x": 1, "y": 28 }, { "x": 2, "y": 55 },
                            { "x": 3, "y": 43 }, { "x": 4, "y": 91 },
                            { "x": 5, "y": 81 }, { "x": 6, "y": 53 },
                            { "x": 7, "y": 19 }, { "x": 8, "y": 87 },
                            { "x": 9, "y": 52 }, { "x": 10, "y": 48 },
                            { "x": 11, "y": 24 }, { "x": 12, "y": 49 },
                            { "x": 13, "y": 87 }, { "x": 14, "y": 66 },
                            { "x": 15, "y": 17 }, { "x": 16, "y": 27 },
                            { "x": 17, "y": 68 }, { "x": 18, "y": 16 },
                            { "x": 19, "y": 49 }, { "x": 20, "y": 15 }
                        ]
                    }
                ],
                "scales": [
                    {
                        "name": "x",
                        "type": "ordinal",
                        "range": "width",
                        "domain": { "data": "table", "field": "x" }
                    },
                    {
                        "name": "y",
                        "type": "linear",
                        "range": "height",
                        "domain": { "data": "table", "field": "y" },
                        "nice": true
                    }
                ],
                "axes": [
                    { "type": "x", "scale": "x" },
                    { "type": "y", "scale": "y" }
                ],
                "marks": [
                    {
                        "type": "rect",
                        "from": { "data": "table" },
                        "properties": {
                            "enter": {
                                "x": { "scale": "x", "field": "x" },
                                "width": { "scale": "x", "band": true, "offset": -1 },
                                "y": { "scale": "y", "field": "y" },
                                "y2": { "scale": "y", "value": 0 }
                            },
                            "update": {
                                "fill": { "value": "steelblue" }
                            },
                            "hover": {
                                "fill": { "value": "red" }
                            }
                        }
                    }
                ]
            };
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = par.widget;
            $scope.data = this.widget.data;
            $scope.data._id = this.widget.id;
        }
        ChartCtrl.prototype.startChart = function () {
            var _this = this;
            var d = this.$scope.data;
            if (!d.spec)
                d.spec = this.defaultSpec;
            var res = vg.embed('#vis' + d._id, d.spec, function (view, vega_spec) {
                d._view = view;
                // Callback receiving the View instance and parsed Vega spec...
                // The View resides under the '#vis' element
            });
            if (d.key) {
                this.keyHandle = this.$layerService.$messageBusService.serverSubscribe(d.key, "key", function (topic, msg) {
                    switch (msg.action) {
                        case "key":
                            if (msg.data.item && Object.prototype.toString.call(msg.data.item) === '[object Array]') {
                                d.spec.data = msg.data.item;
                            }
                            else {
                                d.spec.data = [msg.data.item];
                            }
                            vg.parse.spec(_this.$scope.data.spec, function (chart) { chart({ el: "#vis" + d._id }).update(); });
                            d._view.update();
                            break;
                    }
                });
            }
        };
        ChartCtrl.$inject = [
            '$scope',
            '$timeout',
            'layerService',
            'messageBusService',
            'mapService'
        ];
        return ChartCtrl;
    })();
    ChartsWidget.ChartCtrl = ChartCtrl;
})(ChartsWidget || (ChartsWidget = {}));

var AreaFilter;
(function (AreaFilter) {
    var AreaFilterModel = (function () {
        function AreaFilterModel() {
            this.id = 'AreaFilterModel';
        }
        AreaFilterModel.prototype.stop = function () { };
        AreaFilterModel.prototype.addFeature = function (feature) { };
        AreaFilterModel.prototype.removeFeature = function (feature) { };
        AreaFilterModel.prototype.selectFeature = function (feature) { };
        AreaFilterModel.prototype.getFeatureActions = function (feature) {
            if (!feature.geometry.type)
                return;
            switch (feature.geometry.type) {
                case 'MultiPolygon':
                case 'Polygon':
                    var setFilterActionOption = {
                        title: "Set as area filter"
                    };
                    setFilterActionOption.callback = this.setAsFilter;
                    var resetFilterActionOption = {
                        title: "Reset area filter"
                    };
                    resetFilterActionOption.callback = this.resetFilter;
                    return [setFilterActionOption, resetFilterActionOption];
                default:
                    console.log('Feature type name: ' + feature.featureTypeName);
                    return;
            }
        };
        AreaFilterModel.prototype.getFeatureHoverActions = function (feature) {
            return [];
        };
        AreaFilterModel.prototype.deselectFeature = function (feature) { };
        AreaFilterModel.prototype.updateFeature = function (feuture) { };
        AreaFilterModel.prototype.setAsFilter = function (feature, layerService) {
            if (!feature.geometry.type)
                return;
            switch (feature.geometry.type) {
                case 'MultiPolygon':
                case 'Polygon':
                    layerService.setFeatureAreaFilter(feature);
                    break;
            }
        };
        AreaFilterModel.prototype.resetFilter = function (feature, layerService) {
            if (!feature.geometry.type)
                return;
            switch (feature.geometry.type) {
                case 'MultiPolygon':
                case 'Polygon':
                    layerService.resetFeatureAreaFilter();
                    break;
            }
        };
        AreaFilterModel.prototype.init = function (layerService) {
            console.log('init AreaFilterActionService');
            this.layerService = layerService;
        };
        return AreaFilterModel;
    })();
    AreaFilter.AreaFilterModel = AreaFilterModel;
})(AreaFilter || (AreaFilter = {}));

var Filters;
(function (Filters) {
    var AreaFilterCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function AreaFilterCtrl($scope, $layerService, $messageBus, $timeout, $translate) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.$timeout = $timeout;
            this.$translate = $translate;
            $scope.vm = this;
            $translate('REMOVE').then(function (translation) {
                $scope.removeString = translation;
            });
            var par = $scope.$parent.$parent;
            if (par.hasOwnProperty('filter')) {
                $scope.filter = par['filter'];
            }
            else {
            }
            if ($scope && $scope.filter) {
                setTimeout(function () { return _this.initAreaFilter(); });
                //$timeout.call(()=>this.initAreaFilter());
                $scope.options = (function () {
                    var res = [];
                    res.push([$scope.removeString, function () { return _this.remove(); }]);
                    return res;
                });
            }
        }
        AreaFilterCtrl.prototype.setAreaFilter = function (f) {
            if (f.geometry.type === 'Polygon') {
                this.isInsideFunction = csComp.Helpers.GeoExtensions.pointInsidePolygon;
            }
            else if (f.geometry.type === 'MultiPolygon') {
                this.isInsideFunction = csComp.Helpers.GeoExtensions.pointInsideMultiPolygon;
            }
            else {
                this.isInsideFunction = function () { return false; };
            }
        };
        AreaFilterCtrl.prototype.initAreaFilter = function () {
            var _this = this;
            var filter = this.$scope.filter;
            var feature = filter.value;
            var group = filter.group;
            var divid = 'filter_' + filter.id;
            this.setAreaFilter(filter.value);
            this.dcChart = dc.pieChart('#' + divid);
            this.$scope.$apply();
            var dcDim = group.ndx.dimension(function (d) {
                if (d.id && d.layer && d.layer.group && d.layer.group.markers && d.layer.group.markers.hasOwnProperty(d.id)) {
                    var marker = d.layer.group.markers[d.id];
                    return (marker.feature.geometry.coordinates);
                    group.filterResult.push(feature);
                }
                return null;
            });
            filter.dimension = dcDim;
            this.helperDim = crossfilter([
                { title: "inside" },
                { title: "outside" }
            ]).dimension(function (d) { return d.title; });
            this.helperGroup = this.helperDim.group(function (d) {
                return d;
            });
            this.dcChart
                .width(175)
                .height(200)
                .slicesCap(4)
                .innerRadius(0)
                .dimension(this.helperDim)
                .group(this.helperGroup) // by default, pie charts will use group.key as the label
                .legend(dc.legend())
                .renderLabel(true)
                .label(function (d) { return d.value; })
                .on('renderlet', function (e) {
                _this.updateAreaFilter(_this.$scope.filter.value, false);
            });
            this.updateAreaFilter(this.$scope.filter.value);
        };
        AreaFilterCtrl.prototype.updateAreaFilter = function (feat, triggerRender) {
            var _this = this;
            if (triggerRender === void 0) { triggerRender = true; }
            if (!feat)
                return;
            var f = this.$scope.filter;
            if (!f.dimension)
                return;
            var group = f.group;
            this.setAreaFilter(feat);
            f.dimension.filterFunction(function (d) {
                if (d != null) {
                    return (_this.isInsideFunction(d, feat.geometry.coordinates));
                }
                return false;
            });
            this.helperGroup.all().forEach(function (hg) {
                if (hg.key === "inside") {
                    hg.value = f.dimension.top(Infinity).length;
                }
                if (hg.key === "outside") {
                    hg.value = f.dimension.groupAll().value() - f.dimension.top(Infinity).length;
                }
            });
            this.isEmpty = !(this.helperGroup.all().some(function (hg) { return hg.value !== 0; }));
            group.filterResult = f.dimension.top(Infinity);
            if (triggerRender) {
                this.$layerService.updateMapFilter(group);
                dc.renderAll();
            }
        };
        AreaFilterCtrl.prototype.remove = function () {
            if (this.$scope.filter) {
                this.$layerService.removeFilter(this.$scope.filter);
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        AreaFilterCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService',
            '$timeout',
            '$translate'
        ];
        return AreaFilterCtrl;
    })();
    Filters.AreaFilterCtrl = AreaFilterCtrl;
})(Filters || (Filters = {}));

var Filters;
(function (Filters) {
    var BarFilterCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function BarFilterCtrl($scope, $layerService, $messageBus, $timeout, $translate) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.$timeout = $timeout;
            this.$translate = $translate;
            $scope.vm = this;
            $scope.editMode = true;
            $translate('REMOVE').then(function (translation) {
                $scope.removeString = translation;
            });
            $translate('CREATE_SCATTER').then(function (translation) {
                $scope.createScatterString = translation;
            });
            var par = $scope.$parent.$parent;
            if (par.hasOwnProperty('filter')) {
                $scope.filter = par['filter'];
            }
            else {
            }
            if ($scope && $scope.filter) {
                setTimeout(function () { return _this.initBarFilter(); });
                //$timeout.call(()=>this.initBarFilter());
                $scope.options = (function () {
                    var res = [];
                    res.push([$scope.removeString, function () { return _this.remove(); }]);
                    $scope.filter.group.filters.forEach(function (gf) {
                        if (gf.filterType == "bar" && gf.property != $scope.filter.property) {
                            res.push([$scope.createScatterString + ' ' + gf.title, function () { return _this.createScatter(gf); }]);
                        }
                    });
                    return res;
                });
            }
        }
        BarFilterCtrl.prototype.createScatter = function (gf) {
            this.$layerService.createScatterFilter(this.$scope.filter.group, this.$scope.filter.property, gf.property);
        };
        BarFilterCtrl.prototype.displayFilterRange = function (min, max) {
            if ((+min) > (+max)) {
                min = max;
            }
            var filter = this.$scope.filter;
            if (filter.rangex[0] < min) {
                filter.from = min;
            }
            else {
                filter.from = filter.rangex[0];
            }
            if (filter.rangex[1] > max) {
                filter.to = max;
            }
            else {
                filter.to = filter.rangex[1];
            }
            this.$scope.$apply();
        };
        BarFilterCtrl.prototype.initBarFilter = function () {
            var _this = this;
            var filter = this.$scope.filter;
            var group = filter.group;
            var divid = 'filter_' + filter.id;
            this.dcChart = dc.barChart('#' + divid);
            this.$scope.$apply();
            var info = this.$layerService.calculatePropertyInfo(group, filter.property);
            var nBins = 20;
            var min = info.min;
            var max = info.max;
            filter.rangex[0] = min;
            filter.rangex[1] = max;
            filter.from = min;
            filter.to = max;
            var binWidth = (max - min) / nBins;
            var dcDim = group.ndx.dimension(function (d) {
                if (!d.properties.hasOwnProperty(filter.property))
                    return null;
                else {
                    if (d.properties[filter.property] != null) {
                        var a = parseFloat(d.properties[filter.property]);
                        if (a >= min && a <= max) {
                            return Math.floor(a / binWidth) * binWidth;
                        }
                        else {
                            return null;
                        }
                    }
                    return null;
                }
            });
            filter.dimension = dcDim;
            var dcGroup = dcDim.group();
            //var scale =
            this.dcChart.width(275)
                .height(110)
                .dimension(dcDim)
                .group(dcGroup)
                .transitionDuration(10)
                .centerBar(true)
                .gap(5) //d3.scale.quantize().domain([0, 10]).range(d3.range(1, 4));
                .elasticY(true)
                .x(d3.scale.linear().domain([min, max]).range([-1, nBins + 1]))
                .filterPrinter(function (filters) {
                var s = '';
                if (filters.length > 0) {
                    var localFilter = filters[0];
                    _this.displayFilterRange(parseFloat(localFilter[0]).toFixed(2), parseFloat(localFilter[1]).toFixed(2));
                    s += localFilter[0];
                }
                return s;
            })
                .on('renderlet', function (e) {
                var fil = e.hasFilter();
                var s = '';
                if (e.filters.length > 0) {
                    var localFilter = e.filters[0];
                    _this.displayFilterRange(+(localFilter[0]).toFixed(2), (+localFilter[1]).toFixed(2));
                    s += localFilter[0];
                }
                dc.events.trigger(function () {
                    _this.$layerService.updateFilterGroupCount(group);
                }, 0);
                dc.events.trigger(function () {
                    console.log("yes");
                    group.filterResult = dcDim.top(Infinity);
                    _this.$layerService.updateMapFilter(group);
                }, 100);
            });
            this.dcChart.selectAll();
            //this.displayFilterRange(min,max);
            this.dcChart.xUnits(function () { return 13; });
            //this.$scope.$watch('filter.from',()=>this.updateFilter());
            //  this.$scope.$watch('filter.to',()=>this.updateFilter());
            //if (filter.meta != null && filter.meta.minValue != null) {
            //    dcChart.x(d3.scale.linear().domain([filter.meta.minValue, filter.meta.maxValue]));
            //} else {
            //    var propInfo = this.calculatePropertyInfo(group, filter.property);
            //    var dif = (propInfo.max - propInfo.min) / 100;
            //    dcChart.x(d3.scale.linear().domain([propInfo.min - dif, propInfo.max + dif]));
            //}
            this.dcChart.yAxis().ticks(5);
            this.dcChart.xAxis().ticks(5);
            //this.dcChart.mouseZoomable(true);
            dc.renderAll();
            this.updateRange();
            //  this.updateChartRange(this.dcChart,filter);
        };
        BarFilterCtrl.prototype.updateFilter = function () {
            var _this = this;
            setTimeout(function () {
                _this.dcChart.filter([_this.$scope.filter.from, _this.$scope.filter.to]);
                _this.dcChart.render();
                dc.renderAll();
                _this.$layerService.updateMapFilter(_this.$scope.filter.group);
            }, 10);
        };
        BarFilterCtrl.prototype.updateRange = function () {
            var _this = this;
            setTimeout(function () {
                var filter = _this.$scope.filter;
                var group = filter.group;
                _this.displayFilterRange(_this.$scope.filter.from, _this.$scope.filter.to);
                _this.dcChart.filterAll();
                _this.dcChart.filter(dc.filters.RangedFilter(_this.$scope.filter.from, _this.$scope.filter.to));
                _this.dcChart.render();
                dc.redrawAll();
                group.filterResult = filter.dimension.top(Infinity);
                _this.$layerService.updateMapFilter(_this.$scope.filter.group);
                _this.$scope.$apply();
            }, 0);
        };
        BarFilterCtrl.prototype.remove = function () {
            if (this.$scope.filter) {
                this.$layerService.removeFilter(this.$scope.filter);
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        BarFilterCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService',
            '$timeout',
            '$translate'
        ];
        return BarFilterCtrl;
    })();
    Filters.BarFilterCtrl = BarFilterCtrl;
})(Filters || (Filters = {}));

var Filters;
(function (Filters) {
    var BoolFilterCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function BoolFilterCtrl($scope, $layerService, $messageBus) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            $scope.vm = this;
            var par = $scope.$parent.$parent;
            if (par.hasOwnProperty('filter')) {
                $scope.filter = par['filter'];
            }
            else {
            }
            if ($scope && $scope.filter) {
                this.initBoolFilter();
                //this.updateTextFilter();
                //this.widget = (par.widget); 
                $scope.$watch('filter.value', function () {
                    _this.updateBoolFilter();
                });
            }
        }
        BoolFilterCtrl.prototype.initBoolFilter = function () {
            var filter = this.$scope.filter;
            var group = filter.group;
            var dcDim = group.ndx.dimension(function (d) {
                if (d.properties.hasOwnProperty(filter.property)) {
                    return d.properties[filter.property];
                }
                else
                    return null;
            });
            filter.dimension = dcDim;
            filter.group = group;
            dcDim.filterFunction(function (d) {
                return false;
            });
        };
        BoolFilterCtrl.prototype.updateBoolFilter = function () {
            var f = this.$scope.filter;
            if (!f.dimension)
                return;
            var group = f.group;
            f.dimension.filterFunction(function (d) {
                if (d != null)
                    return (d = f.value);
                return false;
            });
            group.filterResult = f.dimension.top(Infinity);
            this.$layerService.updateMapFilter(group);
            dc.renderAll();
        };
        BoolFilterCtrl.prototype.remove = function () {
            if (this.$scope.filter) {
                this.$layerService.removeFilter(this.$scope.filter);
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        BoolFilterCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService'
        ];
        return BoolFilterCtrl;
    })();
    Filters.BoolFilterCtrl = BoolFilterCtrl;
})(Filters || (Filters = {}));

var Filters;
(function (Filters) {
    var DateFilterCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function DateFilterCtrl($scope, $layerService, $messageBus) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.switch = "after";
            $scope.vm = this;
            var par = $scope.$parent.$parent;
            if (par.hasOwnProperty('filter')) {
                $scope.filter = par['filter'];
            }
            else {
            }
            if ($scope && $scope.filter) {
                this.initTextFilter();
                //this.updateTextFilter();
                //this.widget = (par.widget);
                //$messageBus.subscribe('')
                this.subHandle = $messageBus.subscribe('timeline', function (trigger) {
                    switch (trigger) {
                        case 'focusChange':
                            _this.updateTextFilter();
                            break;
                    }
                });
                $scope.$watch('vm.switch', function () { _this.updateTextFilter(); });
            }
        }
        DateFilterCtrl.prototype.select = function () {
            //  console.log('select:' + this.switch);
        };
        DateFilterCtrl.prototype.check = function (d) {
            if (d != null) {
                var dt = Date.parse(d);
                switch (this.switch) {
                    case "before":
                        return dt >= this.$layerService.project.timeLine.focus;
                        break;
                    case "after":
                        return dt <= this.$layerService.project.timeLine.focus;
                        break;
                    case "range":
                        return dt >= this.$layerService.project.timeLine.start && dt <= this.$layerService.project.timeLine.end;
                        break;
                }
            }
            return false;
        };
        DateFilterCtrl.prototype.initTextFilter = function () {
            var _this = this;
            var filter = this.$scope.filter;
            var group = filter.group;
            var dcDim = group.ndx.dimension(function (d) {
                if (d.properties.hasOwnProperty(filter.property)) {
                    return d.properties[filter.property];
                }
                else
                    return null;
            });
            filter.dimension = dcDim;
            filter.group = group;
            this.$layerService.project.timeLine.focusDate;
            dcDim.filterFunction(function (d) {
                return _this.check(d);
            });
        };
        DateFilterCtrl.prototype.updateTextFilter = function () {
            var _this = this;
            var f = this.$scope.filter;
            if (!f.dimension)
                return;
            var group = f.group;
            f.dimension.filterFunction(function (d) {
                return _this.check(d);
            });
            group.filterResult = f.dimension.top(Infinity);
            this.$layerService.updateMapFilter(group);
            dc.renderAll();
        };
        DateFilterCtrl.prototype.remove = function () {
            if (this.$scope.filter) {
                this.$layerService.removeFilter(this.$scope.filter);
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        DateFilterCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService'
        ];
        return DateFilterCtrl;
    })();
    Filters.DateFilterCtrl = DateFilterCtrl;
})(Filters || (Filters = {}));

var Filters;
(function (Filters) {
    var LocationFilterCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function LocationFilterCtrl($scope, $layerService, $messageBus, $timeout, $translate) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.$timeout = $timeout;
            this.$translate = $translate;
            $scope.vm = this;
            $translate('REMOVE').then(function (translation) {
                $scope.removeString = translation;
            });
            var par = $scope.$parent.$parent;
            if (par.hasOwnProperty('filter')) {
                $scope.filter = par['filter'];
            }
            else {
            }
            if ($scope && $scope.filter) {
                setTimeout(function () { return _this.initLocationFilter(); });
                //$timeout.call(()=>this.initLocationFilter());
                $scope.options = (function () {
                    var res = [];
                    res.push([$scope.removeString, function () { return _this.remove(); }]);
                    return res;
                });
            }
        }
        LocationFilterCtrl.prototype.setLocationFilter = function () {
            var _this = this;
            if (!this.locationFilter) {
                var bounds = this.$layerService.map.map.getBounds();
                bounds = bounds.pad(-0.75);
                this.locationFilter = new L.LocationFilter({ bounds: bounds }).addTo(this.$layerService.map.map);
                this.$scope.filter.value = bounds;
                this.locationFilter.on('change', function (e) {
                    _this.updateLocationFilter(e.bounds);
                });
                this.locationFilter.on('enabled', function (e) {
                    _this.updateLocationFilter(e.bounds);
                });
                this.locationFilter.on('disabled', function (e) {
                });
                this.locationFilter.enable();
                this.updateLocationFilter(this.locationFilter.getBounds());
            }
            else if (this.locationFilter.isEnabled()) {
                this.locationFilter.disable();
            }
            else {
                this.locationFilter.enable();
            }
        };
        LocationFilterCtrl.prototype.initLocationFilter = function () {
            var _this = this;
            var filter = this.$scope.filter;
            var group = filter.group;
            var divid = 'filter_' + filter.id;
            this.setLocationFilter();
            this.dcChart = dc.pieChart('#' + divid);
            this.$scope.$apply();
            var dcDim = group.ndx.dimension(function (d) {
                if (d.id && d.layer && d.layer.group && d.layer.group.markers && d.layer.group.markers.hasOwnProperty(d.id)) {
                    var marker = d.layer.group.markers[d.id];
                    if (marker.getBounds) {
                        return marker.getBounds();
                    }
                    else if (marker.getLatLng) {
                        return (new L.LatLngBounds(marker.getLatLng(), marker.getLatLng()));
                    }
                    else {
                        //what else?
                        null;
                    }
                }
                return null;
            });
            filter.dimension = dcDim;
            this.helperDim = crossfilter([
                { title: "inside" },
                { title: "outside" }
            ]).dimension(function (d) { return d.title; });
            this.helperGroup = this.helperDim.group(function (d) {
                return d;
            });
            this.dcChart
                .width(175)
                .height(200)
                .slicesCap(4)
                .innerRadius(0)
                .dimension(this.helperDim)
                .group(this.helperGroup) // by default, pie charts will use group.key as the label
                .legend(dc.legend())
                .renderLabel(true)
                .label(function (d) { return d.value; })
                .on('renderlet', function (e) {
                _this.updateLocationFilter(_this.locationFilter.getBounds(), false);
            });
            this.updateLocationFilter(this.$scope.filter.value);
        };
        LocationFilterCtrl.prototype.updateLocationFilter = function (bounds, triggerRender) {
            if (triggerRender === void 0) { triggerRender = true; }
            var f = this.$scope.filter;
            if (!f.dimension || !this.locationFilter.isEnabled())
                return;
            var group = f.group;
            f.dimension.filterFunction(function (d) {
                if (d != null) {
                    return (bounds.contains(d));
                }
                return false;
            });
            this.helperGroup.all().forEach(function (hg) {
                if (hg.key === "inside") {
                    hg.value = f.dimension.top(Infinity).length;
                }
                if (hg.key === "outside") {
                    hg.value = f.dimension.groupAll().value() - f.dimension.top(Infinity).length;
                }
            });
            this.isEmpty = !(this.helperGroup.all().some(function (hg) { return hg.value !== 0; }));
            group.filterResult = f.dimension.top(Infinity);
            if (triggerRender) {
                this.$layerService.updateMapFilter(group);
                dc.renderAll();
            }
        };
        LocationFilterCtrl.prototype.remove = function () {
            if (this.$scope.filter) {
                this.locationFilter.disable();
                this.$layerService.removeFilter(this.$scope.filter);
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        LocationFilterCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService',
            '$timeout',
            '$translate'
        ];
        return LocationFilterCtrl;
    })();
    Filters.LocationFilterCtrl = LocationFilterCtrl;
})(Filters || (Filters = {}));

var Filters;
(function (Filters) {
    var RowFilterCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function RowFilterCtrl($scope, $layerService, $messageBus, $timeout) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.$timeout = $timeout;
            $scope.vm = this;
            var par = $scope.$parent.$parent;
            if (par.hasOwnProperty('filter')) {
                $scope.filter = par['filter'];
            }
            else {
            }
            if ($scope && $scope.filter) {
                setTimeout(function () { return _this.initRowFilter(); });
                //$timeout.call(()=>this.initBarFilter());
                $scope.options = (function () {
                    var res = [];
                    res.push(['remove', function () { return _this.remove(); }]);
                    $scope.filter.group.filters.forEach(function (gf) {
                        if (gf.filterType == "bar" && gf.property != $scope.filter.property) {
                            res.push(['create scatter with ' + gf.title, function () { return _this.createScatter(gf); }]);
                        }
                    });
                    return res;
                });
            }
        }
        RowFilterCtrl.prototype.createScatter = function (gf) {
            this.$layerService.createScatterFilter(this.$scope.filter.group, this.$scope.filter.property, gf.property);
        };
        RowFilterCtrl.prototype.displayFilterRange = function (min, max) {
            var filter = this.$scope.filter;
            filter.from = min;
            filter.to = max;
            this.$scope.$apply();
        };
        RowFilterCtrl.prototype.initRowFilter = function () {
            var _this = this;
            var filter = this.$scope.filter;
            var group = filter.group;
            var divid = 'filter_' + filter.id;
            this.dcChart = dc.rowChart('#' + divid);
            this.$scope.$apply();
            // var filterFrom = $('#fsfrom_' + filter.id);
            // var filterTo = $('#fsto_' + filter.id);
            // var info = this.$layerService.calculatePropertyInfo(group, filter.property);
            //
            // var nBins = 20;
            // var min = info.sdMin;
            // var max = info.sdMax + (info.sdMax - info.sdMin) * 0.01;
            //
            // var binWidth = (max - min) / nBins;
            var dcDim = group.ndx.dimension(function (d) {
                if (!d.properties.hasOwnProperty(filter.property))
                    return null;
                else {
                    if (d.properties[filter.property] != null) {
                        return d.properties[filter.property];
                    }
                    return null;
                }
            });
            filter.dimension = dcDim;
            var dcGroup = dcDim.group().reduceCount();
            //var scale =
            this.dcChart.width(275)
                .height(110)
                .dimension(dcDim)
                .group(dcGroup)
                .transitionDuration(100)
                .gap(5) //d3.scale.quantize().domain([0, 10]).range(d3.range(1, 4));
                .on('filtered', function (e) {
                var fil = e.hasFilter();
                if (fil) {
                }
                else {
                }
                dc.events.trigger(function () {
                    group.filterResult = dcDim.top(Infinity);
                    _this.$layerService.updateFilterGroupCount(group);
                }, 0);
                dc.events.trigger(function () {
                    _this.$layerService.updateMapFilter(group);
                }, 100);
            });
            //this.displayFilterRange(min,max);
            //
            //
            // filterFrom.on('change', () => {
            //     if ($.isNumeric(filterFrom.val())) {
            //         var min = parseInt(filterFrom.val());
            //         var filters = this.dcChart.filters();
            //         if (filters.length > 0) {
            //             filters[0][0] = min;
            //             this.dcChart.filter(filters[0]);
            //             this.dcChart.render();
            //             //dcDim.filter(filters[0]);
            //             dc.redrawAll();
            //             //dc.renderAll();
            //         }
            //     }
            // });
            // filterTo.on('change', () => {
            //     if ($.isNumeric(filterTo.val())) {
            //         var max = parseInt(filterTo.val());
            //         var filters = this.dcChart.filters();
            //         if (filters.length > 0) {
            //             filters[0][1] = max;
            //             this.dcChart.filter(filters[0]);
            //             dcDim.filter(filters[0]);
            //             dc.renderAll();
            //         }
            //         //dc.redrawAll();
            //     }
            //     //dcDim.filter([min, min + 100]);
            // });
            //this.$scope.$watch('filter.from',()=>this.updateFilter());
            //  this.$scope.$watch('filter.to',()=>this.updateFilter());
            //if (filter.meta != null && filter.meta.minValue != null) {
            //    dcChart.x(d3.scale.linear().domain([filter.meta.minValue, filter.meta.maxValue]));
            //} else {
            //    var propInfo = this.calculatePropertyInfo(group, filter.property);
            //    var dif = (propInfo.max - propInfo.min) / 100;
            //    dcChart.x(d3.scale.linear().domain([propInfo.min - dif, propInfo.max + dif]));
            //}
            // this.dcChart.yAxis().ticks(5);
            // this.dcChart.xAxis().ticks(5);
            //this.dcChart.mouseZoomable(true);
            dc.renderAll();
            //  this.updateChartRange(this.dcChart,filter);
        };
        RowFilterCtrl.prototype.updateFilter = function () {
            var _this = this;
            setTimeout(function () {
                _this.dcChart.filter([_this.$scope.filter.from, _this.$scope.filter.to]);
                _this.dcChart.render();
                dc.renderAll();
                _this.$layerService.updateMapFilter(_this.$scope.filter.group);
                console.log('update filter');
            }, 10);
        };
        RowFilterCtrl.prototype.updateRange = function () {
            var _this = this;
            setTimeout(function () {
                _this.dcChart.filter([_this.$scope.filter.from, _this.$scope.filter.to]);
                _this.dcChart.render();
                _this.$layerService.updateMapFilter(_this.$scope.filter.group);
                console.log('update filter');
            }, 10);
        };
        RowFilterCtrl.prototype.remove = function () {
            if (this.$scope.filter) {
                this.$layerService.removeFilter(this.$scope.filter);
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        RowFilterCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService',
            '$timeout'
        ];
        return RowFilterCtrl;
    })();
    Filters.RowFilterCtrl = RowFilterCtrl;
})(Filters || (Filters = {}));

var Filters;
(function (Filters) {
    var ScatterFilterCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function ScatterFilterCtrl($scope, $layerService, $messageBus, $timeout) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.$timeout = $timeout;
            $scope.vm = this;
            var par = $scope.$parent.$parent;
            if (par.hasOwnProperty('filter')) {
                $scope.filter = par['filter'];
            }
            else {
            }
            if ($scope && $scope.filter) {
                setTimeout(function () { return _this.addScatterFilter(); });
                //$timeout.call(()=>this.initBarFilter());
                $scope.options = (function () {
                    var res = [];
                    res.push(['remove', function () { return _this.remove(); }]);
                    $scope.filter.group.filters.forEach(function (gf) {
                        if (gf.filterType == "bar" && gf.property != $scope.filter.property) {
                            res.push(['create scatter with ' + gf.title, function () { return _this.remove(); }]);
                        }
                    });
                    return res;
                });
            }
        }
        ScatterFilterCtrl.prototype.displayFilterRange = function (min, max) {
            var filter = this.$scope.filter;
            filter.from = min;
            filter.to = max;
            this.$scope.$apply();
        };
        ScatterFilterCtrl.prototype.initBarFilter = function () {
            var _this = this;
            var filter = this.$scope.filter;
            var group = filter.group;
            var divid = 'filter_' + filter.id;
            this.dcChart = dc.barChart('#' + divid);
            this.$scope.$apply();
            var filterFrom = $('#fsfrom_' + filter.id);
            var filterTo = $('#fsto_' + filter.id);
            var info = this.$layerService.calculatePropertyInfo(group, filter.property);
            var nBins = 20;
            var min = info.min;
            var max = info.max + (info.max - info.min) * 0.01;
            var binWidth = (max - min) / nBins;
            var dcDim = group.ndx.dimension(function (d) {
                if (!d.properties.hasOwnProperty(filter.property))
                    return null;
                else {
                    if (d.properties[filter.property] != null) {
                        var a = parseFloat(d.properties[filter.property]);
                        if (a >= min && a <= max) {
                            return Math.floor(a / binWidth) * binWidth;
                        }
                        else {
                            return null;
                        }
                    }
                    return null;
                }
            });
            filter.dimension = dcDim;
            var dcGroup = dcDim.group();
            //var scale =
            this.dcChart.width(275)
                .height(110)
                .dimension(dcDim)
                .group(dcGroup)
                .transitionDuration(100)
                .centerBar(true)
                .gap(5) //d3.scale.quantize().domain([0, 10]).range(d3.range(1, 4));
                .elasticY(true)
                .x(d3.scale.linear().domain([min, max]).range([-1, nBins + 1]))
                .filterPrinter(function (filters) {
                var s = '';
                if (filters.length > 0) {
                    var localFilter = filters[0];
                    _this.displayFilterRange(localFilter[0].toFixed(2), localFilter[1].toFixed(2));
                    //  $("#filterfrom_" + filter.id).empty();
                    //$("#filterfrom_" + filter.id).text(localFilter[0].toFixed(2));
                    s += localFilter[0];
                }
                return s;
            })
                .on('filtered', function (e) {
                var fil = e.hasFilter();
                if (fil) {
                }
                else {
                }
                dc.events.trigger(function () {
                    group.filterResult = dcDim.top(Infinity);
                    _this.$layerService.updateFilterGroupCount(group);
                }, 0);
                dc.events.trigger(function () {
                    _this.$layerService.updateMapFilter(group);
                }, 100);
            });
            //this.displayFilterRange(min,max);
            this.dcChart.xUnits(function () { return 13; });
            filterFrom.on('change', function () {
                if ($.isNumeric(filterFrom.val())) {
                    var min = parseFloat(filterFrom.val());
                    var filters = _this.dcChart.filters();
                    if (filters.length > 0) {
                        filters[0][0] = min;
                        _this.dcChart.filter(filters[0]);
                        _this.dcChart.render();
                        //dcDim.filter(filters[0]);
                        dc.redrawAll();
                    }
                }
            });
            filterTo.on('change', function () {
                if ($.isNumeric(filterTo.val())) {
                    var max = parseFloat(filterTo.val());
                    var filters = _this.dcChart.filters();
                    if (filters.length > 0) {
                        filters[0][1] = max;
                        _this.dcChart.filter(filters[0]);
                        dcDim.filter(filters[0]);
                        dc.renderAll();
                    }
                }
                //dcDim.filter([min, min + 100]);
            });
            //this.$scope.$watch('filter.from',()=>this.updateFilter());
            //  this.$scope.$watch('filter.to',()=>this.updateFilter());
            //if (filter.meta != null && filter.meta.minValue != null) {
            //    dcChart.x(d3.scale.linear().domain([filter.meta.minValue, filter.meta.maxValue]));
            //} else {
            //    var propInfo = this.calculatePropertyInfo(group, filter.property);
            //    var dif = (propInfo.max - propInfo.min) / 100;
            //    dcChart.x(d3.scale.linear().domain([propInfo.min - dif, propInfo.max + dif]));
            //}
            this.dcChart.yAxis().ticks(5);
            this.dcChart.xAxis().ticks(5);
            //this.dcChart.mouseZoomable(true);
            dc.renderAll();
            //  this.updateChartRange(this.dcChart,filter);
        };
        ScatterFilterCtrl.prototype.addScatterFilter = function () {
            var _this = this;
            var filter = this.$scope.filter;
            var group = filter.group;
            var info = this.$layerService.calculatePropertyInfo(group, filter.property);
            var info2 = this.$layerService.calculatePropertyInfo(group, filter.property2);
            var divid = 'filter_' + filter.id;
            //this.dcChart = <any>dc.barChart('#' + divid);
            var divid = 'filter_' + filter.id;
            //$("<h4>" + filter.title + "</h4><div id='" + divid + "'></div><a class='btn' id='remove" + filter.id + "'>remove</a>").appendTo("#filters_" + group.id);
            //$("<h4>" + filter.title + "</h4><div id='" + divid + "'></div><div style='display:none' id='fdrange_" + filter.id + "'>from <input type='text' style='width:75px' id='fsfrom_" + filter.id + "'> to <input type='text' style='width:75px' id='fsto_" + filter.id + "'></div><a class='btn' id='remove" + filter.id + "'>remove</a>").appendTo("#filterChart");
            // $('<h4>' + filter.title + '</h4><div id=\'' + divid + '\'></div><div style=\'display:none\' id=\'fdrange_' + filter.id + '\'>from <span id=\'fsfrom_' + filter.id + '\'/> to <span id=\'fsto_' + filter.id + '\'/></div><a class=\'btn\' id=\'remove' + filter.id + '\'>remove</a>').appendTo('#filterChart');
            //
            // $('#remove' + filter.id).on('click', () => {
            //     var pos = group.filters.indexOf(filter);
            //     if (pos !== -1) group.filters.splice(pos, 1);
            //     filter.dimension.dispose();
            //
            //     this.$layerService.resetMapFilter(group);
            // });
            this.dcChart = dc.scatterPlot('#' + divid);
            var prop1 = group.ndx.dimension(function (d) {
                if (!d.properties.hasOwnProperty(filter.property))
                    return null;
                else {
                    if (d.properties[filter.property] != null) {
                        var a = parseFloat(d.properties[filter.property]);
                        var b = parseFloat(d.properties[filter.property2]);
                        if (a >= info.min && a <= info.max) {
                            return [a, b];
                        }
                        else {
                        }
                    }
                    return [0, 0];
                }
            });
            filter.dimension = prop1;
            var dcGroup1 = prop1.group();
            //var scale =
            this.dcChart.width(275)
                .height(190)
                .dimension(prop1)
                .group(dcGroup1)
                .x(d3.scale.linear().domain([info.min, info.max]))
                .yAxisLabel(filter.property2)
                .xAxisLabel(filter.property)
                .on('filtered', function (e) {
                var fil = e.hasFilter();
                dc.events.trigger(function () {
                    group.filterResult = prop1.top(Infinity);
                    _this.$layerService.updateFilterGroupCount(group);
                }, 0);
                dc.events.trigger(function () {
                    _this.$layerService.updateMapFilter(group);
                }, 100);
            });
            this.dcChart.xUnits(function () { return 13; });
            //if (filter.meta != null && filter.meta.minValue != null) {
            //    dcChart.x(d3.scale.linear().domain([filter.meta.minValue, filter.meta.maxValue]));
            //} else {
            //    var propInfo = this.calculatePropertyInfo(group, filter.property);
            //    var dif = (propInfo.max - propInfo.min) / 100;
            //    dcChart.x(d3.scale.linear().domain([propInfo.min - dif, propInfo.max + dif]));
            //}
            this.dcChart.yAxis().ticks(15);
            this.dcChart.xAxis().ticks(15);
            this.dcChart.render();
            //this.updateChartRange(dcChart, filter);
            //.x(d3.scale.quantile().domain(dcGroup.all().map(function (d) {
            //return d.key;
            //   }))
            //.range([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]));
        };
        ScatterFilterCtrl.prototype.updateFilter = function () {
            var _this = this;
            setTimeout(function () {
                _this.dcChart.filter([_this.$scope.filter.from, _this.$scope.filter.to]);
                _this.dcChart.render();
                dc.renderAll();
                _this.$layerService.updateMapFilter(_this.$scope.filter.group);
                console.log('update filter');
            }, 10);
        };
        ScatterFilterCtrl.prototype.updateRange = function () {
            var _this = this;
            setTimeout(function () {
                _this.dcChart.filter([_this.$scope.filter.from, _this.$scope.filter.to]);
                _this.dcChart.render();
                _this.$layerService.updateMapFilter(_this.$scope.filter.group);
                console.log('update filter');
            }, 10);
        };
        ScatterFilterCtrl.prototype.remove = function () {
            if (this.$scope.filter) {
                this.$layerService.removeFilter(this.$scope.filter);
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        ScatterFilterCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService',
            '$timeout'
        ];
        return ScatterFilterCtrl;
    })();
    Filters.ScatterFilterCtrl = ScatterFilterCtrl;
})(Filters || (Filters = {}));

var Filters;
(function (Filters) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Filters.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Filters.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display a legend in a widget.
      */
    Filters.myModule.directive('txt2', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/Filters/TextFilter.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    //console.log('this is the compile function of legendDirective');
                    return function (scope) {
                        fn(scope);
                    };
                },
                replace: true,
                transclude: true,
                controller: Filters.TextFilterCtrl
            };
        }
    ])
        .directive('boolFilter', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/Filters/BoolFilter.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    //console.log('this is the compile function of legendDirective');
                    return function (scope) {
                        fn(scope);
                    };
                },
                replace: true,
                transclude: true,
                controller: Filters.BoolFilterCtrl
            };
        }
    ])
        .directive('barFilter', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/Filters/BarFilter.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    //console.log('this is the compile function of legendDirective');
                    return function (scope) {
                        fn(scope);
                    };
                },
                replace: true,
                transclude: true,
                controller: Filters.BarFilterCtrl
            };
        }
    ])
        .directive('scatterFilter', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/Filters/ScatterFilter.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    //console.log('this is the compile function of legendDirective');
                    return function (scope) {
                        fn(scope);
                    };
                },
                replace: true,
                transclude: true,
                controller: Filters.ScatterFilterCtrl
            };
        }
    ])
        .directive('dateFilter', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/Filters/DateFilter.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    //console.log('this is the compile function of legendDirective');
                    return function (scope) {
                        fn(scope);
                    };
                },
                replace: true,
                transclude: true,
                controller: Filters.DateFilterCtrl
            };
        }
    ])
        .directive('locationFilter', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/Filters/LocationFilter.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    //console.log('this is the compile function of legendDirective');
                    return function (scope) {
                        fn(scope);
                    };
                },
                replace: true,
                transclude: true,
                controller: Filters.LocationFilterCtrl
            };
        }
    ])
        .directive('areaFilter', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/Filters/AreaFilter.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    //console.log('this is the compile function of legendDirective');
                    return function (scope) {
                        fn(scope);
                    };
                },
                replace: true,
                transclude: true,
                controller: Filters.AreaFilterCtrl
            };
        }
    ]);
})(Filters || (Filters = {}));

var Filters;
(function (Filters) {
    var TextFilterCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function TextFilterCtrl($scope, $layerService, $messageBus) {
            var _this = this;
            this.$scope = $scope;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            $scope.vm = this;
            var par = $scope.$parent.$parent;
            if (par.hasOwnProperty('filter')) {
                $scope.filter = par['filter'];
            }
            else {
            }
            if ($scope && $scope.filter) {
                this.initTextFilter();
                //this.updateTextFilter();
                //this.widget = (par.widget);
                $scope.$watch('filter.stringValue', function () {
                    _this.updateTextFilter();
                });
            }
        }
        TextFilterCtrl.prototype.initTextFilter = function () {
            var filter = this.$scope.filter;
            var group = filter.group;
            var dcDim = group.ndx.dimension(function (d) {
                if (d.properties.hasOwnProperty(filter.property)) {
                    return d.properties[filter.property];
                }
                else
                    return null;
            });
            filter.dimension = dcDim;
            filter.group = group;
            dcDim.filterFunction(function (d) {
                if (d != null && typeof d.toLowerCase === 'function')
                    return (d.toLowerCase().indexOf(filter.stringValue.toLowerCase()) > -1);
                return false;
            });
        };
        TextFilterCtrl.prototype.updateTextFilter = function () {
            var f = this.$scope.filter;
            if (!f.dimension)
                return;
            var group = f.group;
            if (f.stringValue == null || f.stringValue === '') {
                f.dimension.filterAll();
            }
            else {
                f.dimension.filterFunction(function (d) {
                    if (d != null && typeof d.toLowerCase === 'function')
                        return (d.toLowerCase().indexOf(f.stringValue.toLowerCase()) > -1);
                    return false;
                });
            }
            group.filterResult = f.dimension.top(Infinity);
            this.$layerService.updateMapFilter(group);
            //dc.renderAll();
            dc.redrawAll();
        };
        TextFilterCtrl.prototype.remove = function () {
            if (this.$scope.filter) {
                this.$layerService.removeFilter(this.$scope.filter);
            }
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        TextFilterCtrl.$inject = [
            '$scope',
            'layerService',
            'messageBusService'
        ];
        return TextFilterCtrl;
    })();
    Filters.TextFilterCtrl = TextFilterCtrl;
})(Filters || (Filters = {}));

var Indicators;
(function (Indicators) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Indicators.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Indicators.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    Indicators.myModule.directive('indicatorsEdit', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/Indicators/Indicators-edit.tpl.html',
                replace: true,
                transclude: true,
                controller: IndicatorsEditCtrl
            };
        }
    ]);
    var IndicatorsEditCtrl = (function () {
        function IndicatorsEditCtrl($scope, $timeout, $compile, $layerService, $templateCache, $messageBus, $mapService, $dashboardService) {
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$compile = $compile;
            this.$layerService = $layerService;
            this.$templateCache = $templateCache;
            this.$messageBus = $messageBus;
            this.$mapService = $mapService;
            this.$dashboardService = $dashboardService;
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = par.data;
            this.propertyTypes = [];
            $scope.data = this.widget.data;
            this.indicatorVisuals = {};
            this.indicatorVisuals["bullet"] = { id: "bullet", title: "Bullet chart", input: {} };
            this.indicatorVisuals["circular"] = { id: "circular", title: "Circular", input: { value: { type: "expression", default: "~['value']" }, min: { type: "expression", default: 0 }, max: { type: "expression", default: 0 } } };
            this.indicatorVisuals["sparkline"] = { id: "sparkline", title: "Sparkline", input: { property: { type: "string", default: "value" }, height: { type: "string", default: "50" } } };
            this.indicatorVisuals["bar"] = { id: "bar", title: "Bar chart", input: {} };
            this.indicatorVisuals["singlevalue"] = { id: "singlevalue", title: "Value", input: { value: { type: "expression", default: "~['value']" } } };
        }
        //
        // //** select a typesResource collection from the dropdown */
        IndicatorsEditCtrl.prototype.colorUpdated = function (c, i) {
            i.color = c;
        };
        IndicatorsEditCtrl.prototype.updatePropertyTypes = function (indic) {
            var fType = this.$layerService._featureTypes[indic.featureTypeName];
            if (fType)
                this.propertyTypeData = csComp.Helpers.getPropertyTypes(fType, this.$layerService.propertyTypeData);
        };
        IndicatorsEditCtrl.prototype.moveUp = function (i) {
            var pos = this.$scope.data.indicators.indexOf(i);
            //this.$scope.data.indicators.move()
        };
        IndicatorsEditCtrl.prototype.deleteIndicator = function (i) {
            this.$scope.data.indicators = this.$scope.data.indicators.filter(function (ind) { return ind.id != i; });
        };
        IndicatorsEditCtrl.prototype.updateIndicator = function (i) {
            i.propertyTypes = [];
            i.propertyTypeTitles = [];
            this.propertyTypes.forEach(function (pt) {
                i.propertyTypes.push(pt.label);
                i.propertyTypeTitles.push(pt.title);
            });
            if (this.$layerService.lastSelectedFeature && i.source === "feature") {
                this.$messageBus.publish('feature', 'onUpdateWithLastSelected', { indicator: i, feature: undefined });
            }
            i._toggleUpdate = !i._toggleUpdate;
            this.updateVisual(i);
            if (this.$scope.$root.$$phase != '$apply' && this.$scope.$root.$$phase != '$digest') {
                this.$scope.$apply();
            }
            ;
        };
        IndicatorsEditCtrl.prototype.initIndicator = function (i) {
            this.updateVisual(i);
        };
        IndicatorsEditCtrl.prototype.updateVisual = function (i) {
            if (!i.inputs)
                i.inputs = {};
            var r = {};
            for (var key in this.indicatorVisuals[i.visual].input) {
                if (i.inputs && i.inputs.hasOwnProperty(key)) {
                    r[key] = i.inputs[key];
                }
                else {
                    var v = this.indicatorVisuals[i.visual].input;
                    r[key] = v[key].default;
                }
            }
            i.inputs = r;
        };
        IndicatorsEditCtrl.prototype.addIndicator = function () {
            var newIndicator = new Indicators.indicator();
            newIndicator.title = "New Indicator";
            newIndicator.visual = "circular";
            newIndicator.sensor = "";
            newIndicator.source = "feature";
            newIndicator.featureTypeName = "";
            newIndicator.propertyTypes = [];
            this.updateVisual(newIndicator);
            if (!this.$scope.data.indicators)
                this.$scope.data.indicators = [];
            this.$scope.data.indicators.push(newIndicator);
            if (this.$scope.$root.$$phase != '$apply' && this.$scope.$root.$$phase != '$digest') {
                this.$scope.$apply();
            }
            ;
        };
        IndicatorsEditCtrl.prototype.sensorChanged = function (i) {
            var sourceString = i.sensor.split('/');
            if (sourceString.length > 1) {
                this.$layerService.project.datasources.forEach(function (ds) {
                    if (ds.id === sourceString[0]) {
                        if (ds.sensors.hasOwnProperty(sourceString[1])) {
                            i._sensorSet = ds.sensors[sourceString[1]];
                        }
                    }
                });
            }
            i._toggleUpdate = !i._toggleUpdate;
            if (this.$scope.$root.$$phase != '$apply' && this.$scope.$root.$$phase != '$digest') {
                this.$scope.$apply();
            }
            ;
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        IndicatorsEditCtrl.$inject = [
            '$scope',
            '$timeout',
            '$compile',
            'layerService',
            '$templateCache',
            'messageBusService',
            'mapService', 'dashboardService'
        ];
        return IndicatorsEditCtrl;
    })();
    Indicators.IndicatorsEditCtrl = IndicatorsEditCtrl;
})(Indicators || (Indicators = {}));

var Indicators;
(function (Indicators) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Indicators.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Indicators.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    Indicators.myModule.directive('indicators', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/Indicators/Indicators.tpl.html',
                compile: function (el) {
                    var fn = $compile(el);
                    return function (scope) {
                        fn(scope);
                    };
                },
                replace: true,
                transclude: true,
                controller: Indicators.IndicatorsCtrl
            };
        }
    ]).filter('datasource', function () {
        return function (input, scope) {
            if (!input)
                return "";
            var r = scope.$parent.$eval(input.replace('~', 'i._value'));
            return r;
        };
    });
})(Indicators || (Indicators = {}));

var Indicators;
(function (Indicators) {
    var indicatorData = (function () {
        function indicatorData() {
            this.orientation = "vertical";
        }
        return indicatorData;
    })();
    Indicators.indicatorData = indicatorData;
    var indicator = (function () {
        function indicator() {
            this.inputs = {};
            this._result = {};
            this._toggleUpdate = true;
            this.indicatorWidth = 200;
        }
        return indicator;
    })();
    Indicators.indicator = indicator;
    var IndicatorsCtrl = (function () {
        function IndicatorsCtrl($scope, $timeout, $layerService, $messageBus, $mapService, $dashboardService, $translate) {
            var _this = this;
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.$mapService = $mapService;
            this.$dashboardService = $dashboardService;
            this.$translate = $translate;
            $scope.vm = this;
            var par = $scope.$parent;
            if (!par.widget)
                return;
            this.widget = par.widget;
            this.widget._ctrl = this;
            this.checkLayers();
            this.$messageBus.subscribe("layer", function (s) {
                _this.checkLayers();
            });
            $scope.data = this.widget.data;
            // $scope.$watchCollection('data.indicators', () => {
            //     console.log('update data');
            //     if ($scope.data.indicators && !$scope.data.indicators[$scope.data.indicators.length - 1].id) {
            //         var i = $scope.data.indicators[$scope.data.indicators.length - 1];
            //         i.id = csComp.Helpers.getGuid();
            //         this.$messageBus.subscribe('feature', (action: string, feature: any) => {
            //             switch (action) {
            //                 case 'onFeatureSelect':
            //                     this.selectFeature(feature, i);
            //                     break;
            //                 case 'onUpdateWithLastSelected':
            //                     var indic = <indicator> feature.indicator; //variable called feature is actually an object containing the indicator and an (empty) feature
            //                     var realFeature;
            //                     if (this.$layerService.lastSelectedFeature) { realFeature = this.$layerService.lastSelectedFeature; };
            //                     this.selectFeature(realFeature, indic);
            //                     break;
            //                 default:
            //                     break;
            //             }
            //         });
            //     }
            // })
            if (typeof $scope.data.indicators !== 'undefined') {
                $scope.data.indicators.forEach(function (i) {
                    i.id = "circ-" + csComp.Helpers.getGuid();
                });
            }
            $timeout(function () { return _this.checkLayers(); });
        }
        IndicatorsCtrl.prototype.forceUpdateIndicator = function (i, value) {
            var _this = this;
            setTimeout(function () {
                i._value = value;
                i._result = {};
                _this.$scope.$apply();
                for (var k in i.inputs)
                    i._result[k] = i.inputs[k];
                _this.$scope.$apply();
            }, 0);
        };
        IndicatorsCtrl.prototype.updateIndicator = function (i) {
            var focusTime = this.$layerService.project.timeLine.focus;
            this.$layerService.findSensorSet(i.sensor, function (ss) {
                i._sensorSet = ss;
                i._focusTime = focusTime;
                if (i._sensorSet.propertyType && i._sensorSet.propertyType.legend) {
                    i.color = csComp.Helpers.getColorFromLegend(i._sensorSet.activeValue, i._sensorSet.propertyType.legend);
                }
            });
        };
        IndicatorsCtrl.prototype.startEdit = function () {
            //alert('start edit');
        };
        IndicatorsCtrl.prototype.checkLayers = function () {
            var _this = this;
            if (!this.$layerService.visual.mapVisible)
                return;
            var focusTime = this.$layerService.project.timeLine.focus;
            if (!this.$scope.data || !this.$scope.data.indicators)
                return;
            this.$scope.data.indicators.forEach(function (i) {
                i._focusTime = focusTime;
                if (i.layer != null) {
                    var ss = i.layer.split('/');
                    var l = _this.$layerService.findLayer(ss[0]);
                    if (l != null) {
                        if (ss.length > 1) {
                            i.isActive = l.enabled && l.group.styles.some(function (gs) {
                                return gs.property == ss[1];
                            });
                        }
                        else {
                            i.isActive = l.enabled;
                        }
                    }
                }
            });
        };
        IndicatorsCtrl.prototype.selectIndicator = function (i) {
            if (i.dashboard != 'undefined') {
                var db = this.$layerService.project.dashboards.filter(function (d) { return d.id === i.dashboard; });
                if (db.length > 0)
                    this.$dashboardService.selectDashboard(db[0], 'main');
            }
            if (!this.$layerService.visual.mapVisible)
                return;
            if (i.layer != null) {
                var ss = i.layer.split('/');
                var l = this.$layerService.findLayer(ss[0]);
                if (l != null) {
                    if (l.enabled) {
                        this.$layerService.checkLayerLegend(l, ss[1]);
                    }
                    else {
                        if (ss.length > 1)
                            l.defaultLegendProperty = ss[1];
                        this.$layerService.addLayer(l);
                    }
                }
            }
            this.checkLayers();
            //console.log(i.title);
        };
        IndicatorsCtrl.prototype.indicatorInit = function (i, scope) {
            var _this = this;
            scope.Math = Math;
            switch (i.source) {
                case "feature":
                    this.$messageBus.subscribe('feature', function (action, feature) {
                        switch (action) {
                            case 'onFeatureSelect':
                                _this.selectFeature(feature, i);
                                break;
                            case 'onUpdateWithLastSelected':
                                var indic = feature.indicator; //variable called feature is actually an object containing the indicator and an (empty) feature
                                var realFeature;
                                if (_this.$layerService.lastSelectedFeature) {
                                    realFeature = _this.$layerService.lastSelectedFeature;
                                }
                                ;
                                _this.selectFeature(realFeature, indic);
                                break;
                            default:
                                break;
                        }
                    });
                    break;
                case "sensor":
                    if (i.sensor != null) {
                        this.$layerService.$messageBusService.serverSubscribe(i.sensor, "key", function (topic, msg) {
                            switch (msg.action) {
                                case "key":
                                    _this.forceUpdateIndicator(i, i._sensorSet.activeValue);
                                    break;
                            }
                        });
                        this.updateIndicator(i);
                    }
                    break;
            }
        };
        IndicatorsCtrl.prototype.selectFeature = function (f, i) {
            console.log('select feature called');
            console.log(f);
            if (!i._sensorSet) {
                var ss = new csComp.Services.SensorSet();
                ss.propertyType = { title: '' };
                i._sensorSet = ss;
            }
            if (i.hasOwnProperty('featureTypeName')) {
                if (f.featureTypeName === i.featureTypeName) {
                    var propTypes = i.propertyTypes;
                    var propTitles = [];
                    var propValues = [];
                    this.forceUpdateIndicator(i, f.properties);
                    // propTypes.forEach((pt: string) => {
                    //     if (f.properties.hasOwnProperty(pt)) {
                    //         propValues.push(f.properties[pt]);
                    //     }
                    //     if (this.$layerService.propertyTypeData.hasOwnProperty(pt)) {
                    //         propTitles.push(this.$layerService.propertyTypeData[pt].title);
                    //     } else {
                    //         propTitles.push(pt);
                    //     }
                    // });
                    //
                    // i.sensorSet.activeValue = propValues[0];
                    // i.sensorSet.propertyType.title = propTitles[0];
                    // var propInfo = this.$layerService.calculatePropertyInfo(f.layer.group, propTypes[0]);
                    // i.sensorSet.min = propInfo.min;
                    // i.sensorSet.max = propInfo.max * 1.05;
                    //
                    // if (i.visual === 'bullet') {
                    //     var dataInJson = [];
                    //     for (var count = 0; count < propTypes.length; count++) {
                    //         var pinfo = this.$layerService.calculatePropertyInfo(f.layer.group, propTypes[count]);
                    //
                    //         //TODO: Just for fixing the impact ranges to [-5, 5], better solution is to be implemented...
                    //         if (propTypes[count].substr(0, 3) === 'IMP') {
                    //             if (pinfo.sdMax < 0) {
                    //                 pinfo.min = -5;
                    //                 pinfo.max = -5;
                    //             } else {
                    //                 pinfo.min = 5;
                    //                 pinfo.max = 5;
                    //
                    //             }
                    //         }
                    //         var item = {
                    //             'title': propTitles[count],
                    //             'subtitle': '',
                    //             'ranges': [pinfo.max, pinfo.max],
                    //             'measures': [propValues[count]],
                    //             'markers': [propValues[count]],
                    //             'barColor': (propValues[count] <= 0) ? 'green' : 'red'
                    //         };
                    //         dataInJson.push(item);
                    //     }
                    //     i.indicatorWidth = 200;
                    //     i.data = JSON.stringify(dataInJson);
                    // };
                    // if (i.title === 'Blootgestelden') {
                    //     var property: string = propTypes[0];
                    //     var dataInJson = [];
                    //     this.$layerService.project.features.forEach(
                    //         (f: csComp.Services.IFeature) => {
                    //             if (f.layerId === f.layer.id && f.properties.hasOwnProperty(property)) {
                    //                 var s = f.properties[property];
                    //                 var v = Number(s);
                    //                 //  if (!isNaN(v)) {
                    //                 //  }
                    //                 var item = {
                    //                     //                                        'title': propTitles[0],
                    //                     'title': f.properties["WIJKNAAM"],
                    //                     'subtitle': 'norm',
                    //                     'ranges': [4000, 12500],
                    //                     'measures': [v],
                    //                     'markers': [v],
                    //                     'barColor': (v <= 0) ? 'green' : 'red'
                    //                 };
                    //                 dataInJson.push(item);
                    //             }
                    //         }
                    //         );
                    //     i.indicatorWidth = 400;
                    //     i.data = JSON.stringify(dataInJson);
                    // }
                    i._toggleUpdate = !i._toggleUpdate; //Redraw the widget
                }
            }
            if (this.$scope.$root.$$phase != '$apply' && this.$scope.$root.$$phase != '$digest') {
                this.$scope.$apply();
            }
            ;
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        IndicatorsCtrl.$inject = [
            '$scope',
            '$timeout',
            'layerService',
            'messageBusService',
            'mapService',
            'dashboardService',
            '$translate'
        ];
        return IndicatorsCtrl;
    })();
    Indicators.IndicatorsCtrl = IndicatorsCtrl;
})(Indicators || (Indicators = {}));

var Markdown;
(function (Markdown) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        Markdown.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        Markdown.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    Markdown.myModule.directive('markdownwidgetEdit', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/MarkdownWidget/Markdown-edit.tpl.html',
                replace: true,
                transclude: true,
                controller: MarkdownEditCtrl
            };
        }
    ]);
    var MarkdownEditCtrl = (function () {
        function MarkdownEditCtrl($scope, $timeout, $compile, $layerService, $templateCache, $messageBus, $mapService, $dashboardService) {
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$compile = $compile;
            this.$layerService = $layerService;
            this.$templateCache = $templateCache;
            this.$messageBus = $messageBus;
            this.$mapService = $mapService;
            this.$dashboardService = $dashboardService;
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = par.data;
            $scope.data = this.widget.data;
        }
        MarkdownEditCtrl.prototype.updateText = function () {
            this.$scope.data.mdText = this.$scope.data.content;
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        MarkdownEditCtrl.$inject = [
            '$scope',
            '$timeout',
            '$compile',
            'layerService',
            '$templateCache',
            'messageBusService',
            'mapService', 'dashboardService'
        ];
        return MarkdownEditCtrl;
    })();
    Markdown.MarkdownEditCtrl = MarkdownEditCtrl;
})(Markdown || (Markdown = {}));

var MarkdownWidget;
(function (MarkdownWidget) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        MarkdownWidget.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        MarkdownWidget.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    MarkdownWidget.myModule.directive('markdownwidget', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/MarkdownWidget/MarkdownWidget.tpl.html',
                replace: true,
                transclude: false,
                controller: MarkdownWidget.MarkdownWidgetCtrl
            };
        }
    ]);
})(MarkdownWidget || (MarkdownWidget = {}));

var MarkdownWidget;
(function (MarkdownWidget) {
    var MarkdownWidgetData = (function () {
        function MarkdownWidgetData() {
        }
        return MarkdownWidgetData;
    })();
    MarkdownWidget.MarkdownWidgetData = MarkdownWidgetData;
    var MarkdownWidgetCtrl = (function () {
        function MarkdownWidgetCtrl($scope, $timeout, $layerService, $messageBus, $mapService) {
            var _this = this;
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.$mapService = $mapService;
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = par.widget;
            $scope.data = this.widget.data;
            $scope.data.mdText = $scope.data.content;
            if (typeof $scope.data.featureTypeName !== 'undefined' && typeof $scope.data.dynamicProperties !== 'undefined' && $scope.data.dynamicProperties.length > 0) {
                // Hide widget
                this.parentWidget = $("#" + this.widget.elementId).parent();
                this.parentWidget.hide();
                this.$messageBus.subscribe('feature', function (action, feature) {
                    switch (action) {
                        case 'onFeatureDeselect':
                        case 'onFeatureSelect':
                            _this.selectFeature(feature);
                            break;
                        default:
                            break;
                    }
                });
            }
            if (typeof $scope.data.url === 'undefined')
                return;
            $.get($scope.data.url, function (md) {
                $timeout(function () {
                    $scope.data.content = $scope.data.mdText = md;
                }, 0);
            });
        }
        MarkdownWidgetCtrl.prototype.escapeRegExp = function (str) {
            return str.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
        };
        MarkdownWidgetCtrl.prototype.replaceAll = function (str, find, replace) {
            return str.replace(new RegExp(this.escapeRegExp(find), 'g'), replace);
        };
        MarkdownWidgetCtrl.prototype.selectFeature = function (feature) {
            var _this = this;
            if (!feature || !feature.isSelected || feature.featureTypeName !== this.$scope.data.featureTypeName) {
                this.parentWidget.hide();
                return;
            }
            this.$timeout(function () {
                var md = _this.$scope.data.content;
                var i = 0;
                _this.$scope.data.dynamicProperties.forEach(function (p) {
                    var searchPattern = '{{' + i++ + '}}';
                    var displayText = '';
                    if (feature.properties.hasOwnProperty(p)) {
                        var pt = _this.$layerService.getPropertyType(feature, p);
                        displayText = csComp.Helpers.convertPropertyInfo(pt, feature.properties[p]);
                    }
                    md = _this.replaceAll(md, searchPattern, displayText);
                });
                _this.parentWidget.show();
                _this.$scope.data.mdText = md;
            }, 0);
        };
        MarkdownWidgetCtrl.$inject = [
            '$scope',
            '$timeout',
            'layerService',
            'messageBusService',
            'mapService'
        ];
        return MarkdownWidgetCtrl;
    })();
    MarkdownWidget.MarkdownWidgetCtrl = MarkdownWidgetCtrl;
})(MarkdownWidget || (MarkdownWidget = {}));

var IFrameWidget;
(function (IFrameWidget) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        IFrameWidget.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        IFrameWidget.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    IFrameWidget.myModule.directive('iframewidgetEdit', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/IFrameWidget/IFrame-edit.tpl.html',
                replace: true,
                transclude: true,
                controller: IFrameEditCtrl
            };
        }
    ]);
    var IFrameEditCtrl = (function () {
        function IFrameEditCtrl($scope, $sce) {
            this.$scope = $scope;
            this.$sce = $sce;
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = par.data;
            $scope.data = this.widget.data;
            this.update();
        }
        IFrameEditCtrl.prototype.update = function () {
            this.$scope.data._safeurl = this.$sce.trustAsResourceUrl(this.$scope.data.url);
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        IFrameEditCtrl.$inject = [
            '$scope',
            '$sce'
        ];
        return IFrameEditCtrl;
    })();
    IFrameWidget.IFrameEditCtrl = IFrameEditCtrl;
})(IFrameWidget || (IFrameWidget = {}));

var IFrameWidget;
(function (IFrameWidget) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        IFrameWidget.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        IFrameWidget.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    IFrameWidget.myModule.directive('iframewidget', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/IFrameWidget/IFrameWidget.tpl.html',
                replace: true,
                transclude: false,
                controller: IFrameWidget.IFrameWidgetCtrl
            };
        }
    ]);
})(IFrameWidget || (IFrameWidget = {}));

var IFrameWidget;
(function (IFrameWidget) {
    var IFrameWidgetData = (function () {
        function IFrameWidgetData() {
        }
        return IFrameWidgetData;
    })();
    IFrameWidget.IFrameWidgetData = IFrameWidgetData;
    var IFrameWidgetCtrl = (function () {
        function IFrameWidgetCtrl($scope, $sce) {
            this.$scope = $scope;
            this.$sce = $sce;
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = par.widget;
            $scope.data = this.widget.data;
        }
        IFrameWidgetCtrl.prototype.update = function () {
            this.$scope.data._safeurl = this.$sce.trustAsResourceUrl(this.$scope.data.url);
        };
        IFrameWidgetCtrl.$inject = [
            '$scope',
            '$sce'
        ];
        return IFrameWidgetCtrl;
    })();
    IFrameWidget.IFrameWidgetCtrl = IFrameWidgetCtrl;
})(IFrameWidget || (IFrameWidget = {}));

var MCAWidget;
(function (MCAWidget) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        MCAWidget.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        MCAWidget.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    MCAWidget.myModule.directive('mcawidget', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/MCAWidget/MCAWidget.tpl.html',
                replace: true,
                transclude: false,
                controller: MCAWidget.MCAWidgetCtrl
            };
        }
    ]);
})(MCAWidget || (MCAWidget = {}));

var MCAWidget;
(function (MCAWidget) {
    var MCAWidgetData = (function () {
        function MCAWidgetData() {
        }
        return MCAWidgetData;
    })();
    MCAWidget.MCAWidgetData = MCAWidgetData;
    var MCAWidgetCtrl = (function () {
        function MCAWidgetCtrl($scope, $timeout, $controller, $layerService, $messageBus, $mapService) {
            var _this = this;
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$controller = $controller;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.$mapService = $mapService;
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = par.widget;
            $scope.data = this.widget.data;
            if (typeof $scope.data.layerId !== 'undefined') {
                // Hide widget
                this.parentWidget = $("#" + this.widget.elementId).parent();
                this.parentWidget.hide();
                this.$messageBus.subscribe('layer', function (action, layer) {
                    switch (action) {
                        case 'activated':
                        case 'deactivate':
                            _this.activateLayer(layer);
                            break;
                        default:
                            break;
                    }
                });
            }
        }
        MCAWidgetCtrl.prototype.activateLayer = function (layer) {
            var _this = this;
            this.mcaScope = this.getMcaScope();
            if (!this.mcaScope)
                return;
            if (layer.id !== this.$scope.data.layerId || (layer.id === this.$scope.data.layerId && !layer.enabled)) {
                this.parentWidget.hide();
                return;
            }
            this.$timeout(function () {
                _this.parentWidget.show();
            }, 0);
        };
        MCAWidgetCtrl.prototype.getMcaScope = function () {
            var mcaElm = angular.element('div[id="mca"]');
            if (!mcaElm) {
                console.log('Mca element not found.');
                return;
            }
            var mcaScope = mcaElm.scope();
            if (!mcaScope) {
                console.log('Mca controller scope not found.');
                return;
            }
            else {
                this.$scope.data.availableMcas = mcaScope.vm.availableMcas;
                return mcaScope;
            }
        };
        MCAWidgetCtrl.prototype.setMcaAsStyle = function (mcaNr) {
            if (!this.mcaScope || !this.mcaScope.vm.mca) {
                console.log('Mca controller scope not found.');
                return;
            }
            else {
                var vm = this.mcaScope.vm;
                if (!vm.showFeature) {
                    this.$messageBus.notifyWithTranslation('SELECT_A_FEATURE', 'SELECT_FEATURE_FOR_STYLE');
                    return;
                }
                if (vm.properties.length > 0) {
                    var availableMcas = vm.availableMcas.length;
                    if (mcaNr <= availableMcas) {
                        vm.mca = vm.availableMcas[mcaNr];
                        vm.updateMca();
                    }
                    console.log('Set mca style.');
                    vm.setStyle(vm.properties[0]);
                }
            }
        };
        MCAWidgetCtrl.$inject = [
            '$scope',
            '$timeout',
            '$controller',
            'layerService',
            'messageBusService',
            'mapService'
        ];
        return MCAWidgetCtrl;
    })();
    MCAWidget.MCAWidgetCtrl = MCAWidgetCtrl;
})(MCAWidget || (MCAWidget = {}));

var PostMan;
(function (PostMan) {
    /** Config */
    var moduleName = 'csComp';
    try {
        PostMan.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        PostMan.myModule = angular.module(moduleName, []);
    }
    /**
     * Directive (editor) to send a message to a REST endpoint. Similar in goal to the Chrome plugin POSTMAN.
     * Since this is an editor, the name of the directive is a convention: always use main directive name, plus Edit!
     */
    PostMan.myModule.directive('postmanEdit', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/PostMan/PostMan-edit.tpl.html',
                replace: true,
                transclude: false,
                controller: PostMan.PostManEditCtrl
            };
        }
    ]);
})(PostMan || (PostMan = {}));

var PostMan;
(function (PostMan) {
    /** Config */
    var moduleName = 'csComp';
    try {
        PostMan.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        PostMan.myModule = angular.module(moduleName, []);
    }
    /** Directive to send a message to a REST endpoint. Similar in goal to the Chrome plugin POSTMAN. */
    PostMan.myModule.directive('postman', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/PostMan/PostMan.tpl.html',
                replace: true,
                transclude: false,
                controller: PostMan.PostManCtrl
            };
        }
    ]);
})(PostMan || (PostMan = {}));

var PostMan;
(function (PostMan) {
    var PostManCtrl = (function () {
        function PostManCtrl($scope, $http, messageBusService, $timeout) {
            this.$scope = $scope;
            this.$http = $http;
            this.messageBusService = messageBusService;
            this.$timeout = $timeout;
            $scope.vm = this;
            var par = $scope.$parent;
            $scope.data = par.widget.data;
            if ($scope.data.messages) {
                $scope.selectedMessage = $scope.data.messages[0];
            }
        }
        PostManCtrl.prototype.execute = function () {
            var _this = this;
            if (!this.$scope.selectedMessage)
                return;
            var msg = this.$scope.selectedMessage;
            this.result = '';
            switch (msg.httpMethod.name.toUpperCase()) {
                case 'POST':
                    this.$http.post(msg.url, msg.message)
                        .success(function () { _this.result = 'OK'; })
                        .error(function (err) { _this.result = "Error: " + err; });
                    break;
                case 'PUT':
                    this.$http.put(msg.url, msg.message)
                        .success(function () { _this.result = 'OK'; })
                        .error(function (err) { _this.result = "Error: " + err; });
                    break;
                case 'GET':
                    this.$http.get(msg.url, msg.message)
                        .success(function (data) { _this.result = "Result: " + data; })
                        .error(function (err) { _this.result = "Error: " + err; });
                    break;
                case 'DELETE':
                    this.$http.delete(msg.url, msg.message)
                        .success(function () { _this.result = 'OK'; })
                        .error(function (err) { _this.result = "Error: " + err; });
                    break;
            }
        };
        PostManCtrl.$inject = [
            '$scope',
            '$http',
            'messageBusService',
            '$timeout'
        ];
        return PostManCtrl;
    })();
    PostMan.PostManCtrl = PostManCtrl;
})(PostMan || (PostMan = {}));

var PostMan;
(function (PostMan) {
    var PostManEditCtrl = (function () {
        function PostManEditCtrl($scope, $timeout, $messageBus, $dashboardService) {
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$messageBus = $messageBus;
            this.$dashboardService = $dashboardService;
            $scope.vm = this;
            $scope.methods = [
                { name: 'GET' },
                { name: 'PUT' },
                { name: 'POST' },
                { name: 'DELETE' }
            ];
            var par = $scope.$parent;
            this.widget = par.data;
            $scope.data = this.widget.data;
            if (!$scope.data.messages) {
                $scope.data.messages = [];
                this.addMessage();
            }
            else {
                $scope.selectedMessage = $scope.data.messages[0];
            }
        }
        PostManEditCtrl.prototype.addMessage = function () {
            this.$scope.selectedMessage = {
                name: 'New message...',
                httpMethod: this.$scope.methods[2]
            };
            this.$scope.data.messages.push(this.$scope.selectedMessage);
        };
        PostManEditCtrl.prototype.deleteMessage = function () {
            if (!this.$scope.selectedMessage)
                return;
            var index = this.$scope.data.messages.indexOf(this.$scope.selectedMessage);
            if (index < 0)
                return;
            this.$scope.data.messages.slice(index, 1);
            if (this.$scope.data.messages.length === 0)
                this.addMessage();
            else
                this.$scope.selectedMessage = this.$scope.data.messages[0];
        };
        // $inject annotation.
        PostManEditCtrl.$inject = [
            '$scope',
            '$timeout',
            'messageBusService',
            'dashboardService'
        ];
        return PostManEditCtrl;
    })();
    PostMan.PostManEditCtrl = PostManEditCtrl;
})(PostMan || (PostMan = {}));

var SimState;
(function (SimState) {
    /** Config */
    var moduleName = 'csComp';
    try {
        SimState.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        SimState.myModule = angular.module(moduleName, []);
    }
    /** Directive to send a message to a REST endpoint. Similar in goal to the Chrome plugin POSTMAN. */
    SimState.myModule.directive('simstateEdit', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/SimState/SimState.tpl.html',
                replace: true,
                transclude: false,
                controller: SimStateEditCtrl
            };
        }
    ]);
    var SimStateEditCtrl = (function () {
        function SimStateEditCtrl($scope, $http, messageBusService, $timeout) {
            this.$scope = $scope;
            this.$http = $http;
            this.messageBusService = messageBusService;
            this.$timeout = $timeout;
            $scope.vm = this;
            //var par = <any>$scope.$parent;
            //$scope.data = <PostManEditorData>par.widget.data;
        }
        SimStateEditCtrl.$inject = [
            '$scope',
            '$http',
            'messageBusService',
            '$timeout'
        ];
        return SimStateEditCtrl;
    })();
    SimState.SimStateEditCtrl = SimStateEditCtrl;
})(SimState || (SimState = {}));

var SimState;
(function (SimState) {
    /** Config */
    var moduleName = 'csComp';
    try {
        SimState.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        SimState.myModule = angular.module(moduleName, []);
    }
    /** Directive to send a message to a REST endpoint. Similar in goal to the Chrome plugin POSTMAN. */
    SimState.myModule.directive('simstate', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/SimState/SimState.tpl.html',
                replace: true,
                transclude: false,
                controller: SimStateCtrl
            };
        }
    ]);
    var SimStateCtrl = (function () {
        function SimStateCtrl($scope, $http, messageBusService, $timeout) {
            var _this = this;
            this.$scope = $scope;
            this.$http = $http;
            this.messageBusService = messageBusService;
            this.$timeout = $timeout;
            this.states = {};
            $scope.vm = this;
            messageBusService.serverSubscribe('Sim.SimState.', 'key', function (title, msg) {
                if (!msg || !msg.hasOwnProperty('data') || !msg.data.hasOwnProperty('item'))
                    return;
                //console.log(`Server subscription received: ${title}, ${JSON.stringify(msg, null, 2) }.`);
                _this.$timeout(function () {
                    var state = msg.data.item;
                    if (state.state === 'Exit')
                        delete _this.states[state.id];
                    else
                        _this.states[state.name] = state; // Although id would be better, we could end up with the remains of restarted services.
                }, 0);
            });
        }
        SimStateCtrl.$inject = [
            '$scope',
            '$http',
            'messageBusService',
            '$timeout'
        ];
        return SimStateCtrl;
    })();
    SimState.SimStateCtrl = SimStateCtrl;
})(SimState || (SimState = {}));

var NavigatorWidget;
(function (NavigatorWidget) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        NavigatorWidget.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        NavigatorWidget.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    NavigatorWidget.myModule.directive('markdownwidgetEdit', [
        '$compile',
        function ($compile) {
            return {
                terminal: true,
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/MarkdownWidget/Markdown-edit.tpl.html',
                replace: true,
                transclude: true,
                controller: MarkdownEditCtrl
            };
        }
    ]);
    var MarkdownEditCtrl = (function () {
        function MarkdownEditCtrl($scope, $timeout, $compile, $layerService, $templateCache, $messageBus, $mapService, $dashboardService) {
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$compile = $compile;
            this.$layerService = $layerService;
            this.$templateCache = $templateCache;
            this.$messageBus = $messageBus;
            this.$mapService = $mapService;
            this.$dashboardService = $dashboardService;
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = par.data;
            $scope.data = this.widget.data;
        }
        MarkdownEditCtrl.prototype.updateText = function () {
            this.$scope.data.mdText = this.$scope.data.content;
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        MarkdownEditCtrl.$inject = [
            '$scope',
            '$timeout',
            '$compile',
            'layerService',
            '$templateCache',
            'messageBusService',
            'mapService', 'dashboardService'
        ];
        return MarkdownEditCtrl;
    })();
    NavigatorWidget.MarkdownEditCtrl = MarkdownEditCtrl;
})(NavigatorWidget || (NavigatorWidget = {}));

var NavigatorWidget;
(function (NavigatorWidget) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        NavigatorWidget.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        NavigatorWidget.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    NavigatorWidget.myModule.directive('navigatorwidget', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/Navigator/NavigatorWidget.tpl.html',
                replace: true,
                transclude: false,
                controller: NavigatorWidget.NavigatorWidgetCtrl
            };
        }
    ]);
})(NavigatorWidget || (NavigatorWidget = {}));

var NavigatorWidget;
(function (NavigatorWidget) {
    var NavigatorWidgetData = (function () {
        function NavigatorWidgetData() {
        }
        return NavigatorWidgetData;
    })();
    NavigatorWidget.NavigatorWidgetData = NavigatorWidgetData;
    var NavigatorWidgetCtrl = (function () {
        function NavigatorWidgetCtrl($scope, $timeout, $layerService, $messageBus, $mapService) {
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$layerService = $layerService;
            this.$messageBus = $messageBus;
            this.$mapService = $mapService;
            $scope.vm = this;
            var par = $scope.$parent;
            this.widget = par.widget;
            if (this.widget.data)
                $scope.data = this.widget.data;
            if (typeof $scope.data.featureTypeName !== 'undefined' && typeof $scope.data.dynamicProperties !== 'undefined' && $scope.data.dynamicProperties.length > 0) {
                // Hide widget
                this.parentWidget = $("#" + this.widget.elementId).parent();
                this.parentWidget.hide();
            }
        }
        NavigatorWidgetCtrl.$inject = [
            '$scope',
            '$timeout',
            'layerService',
            'messageBusService',
            'mapService'
        ];
        return NavigatorWidgetCtrl;
    })();
    NavigatorWidget.NavigatorWidgetCtrl = NavigatorWidgetCtrl;
})(NavigatorWidget || (NavigatorWidget = {}));

var SimTimeController;
(function (SimTimeController) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        SimTimeController.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        SimTimeController.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    SimTimeController.myModule.directive('simtimecontrollerEdit', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/SimTimeController/SimTimeController-edit.tpl.html',
                replace: true,
                transclude: false,
                controller: SimTimeController.SimTimeControllerEditCtrl
            };
        }
    ]);
})(SimTimeController || (SimTimeController = {}));

var SimTimeController;
(function (SimTimeController) {
    /**
      * Config
      */
    var moduleName = 'csComp';
    try {
        SimTimeController.myModule = angular.module(moduleName);
    }
    catch (err) {
        // named module does not exist, so create one
        SimTimeController.myModule = angular.module(moduleName, []);
    }
    /**
      * Directive to display the available map layers.
      */
    SimTimeController.myModule.directive('simtimecontroller', [function () {
            return {
                restrict: 'E',
                scope: {},
                templateUrl: 'directives/Widgets/SimTimeController/SimTimeController.tpl.html',
                replace: true,
                transclude: false,
                controller: SimTimeController.SimTimeControllerCtrl
            };
        }
    ]);
})(SimTimeController || (SimTimeController = {}));

var SimTimeController;
(function (SimTimeController) {
    (function (PlayState) {
        PlayState[PlayState["Stopped"] = 0] = "Stopped";
        PlayState[PlayState["Playing"] = 1] = "Playing";
        PlayState[PlayState["Paused"] = 2] = "Paused";
    })(SimTimeController.PlayState || (SimTimeController.PlayState = {}));
    var PlayState = SimTimeController.PlayState;
    (function (SimCommand) {
        SimCommand[SimCommand["Start"] = 0] = "Start";
        SimCommand[SimCommand["Pause"] = 1] = "Pause";
        SimCommand[SimCommand["Stop"] = 2] = "Stop";
        SimCommand[SimCommand["Run"] = 3] = "Run";
        SimCommand[SimCommand["Finish"] = 4] = "Finish";
        SimCommand[SimCommand["Exit"] = 5] = "Exit";
    })(SimTimeController.SimCommand || (SimTimeController.SimCommand = {}));
    var SimCommand = SimTimeController.SimCommand;
    var SimTimeControllerCtrl = (function () {
        // dependencies are injected via AngularJS $injector
        // controller's name is registered in Application.ts and specified from ng-controller attribute in index.html
        function SimTimeControllerCtrl($scope, $http, messageBusService, $timeout) {
            var _this = this;
            this.$scope = $scope;
            this.$http = $http;
            this.messageBusService = messageBusService;
            this.$timeout = $timeout;
            this.speed = 1;
            /** Start time, e.g. when restarting */
            this.startTime = new Date();
            /** Current time */
            this.time = this.startTime;
            // DateTimePicker
            this.isOpen = false;
            this.timeOptions = {
                readonlyInput: false,
                showMeridian: false
            };
            // For the view's status
            this.isPlaying = false;
            this.isPaused = false;
            this.isStopped = true;
            $scope.vm = this;
            var par = $scope.$parent;
            this.editorData = par.widget.data;
            this.httpMethod = 'POST';
            if (this.editorData.hasOwnProperty('httpMethod') && this.editorData.httpMethod.hasOwnProperty('name'))
                this.httpMethod = this.editorData.httpMethod.name.toUpperCase();
            this.url = this.editorData.url || 'api/keys/simTime';
            this.fsm = new FSM.FiniteStateMachine(PlayState.Stopped);
            this.fsm.from(PlayState.Stopped).to(PlayState.Playing).on(SimCommand.Start);
            this.fsm.from(PlayState.Playing).to(PlayState.Stopped).on(SimCommand.Stop);
            this.fsm.from(PlayState.Playing).to(PlayState.Paused).on(SimCommand.Pause);
            this.fsm.from(PlayState.Paused).to(PlayState.Stopped).on(SimCommand.Stop);
            this.fsm.from(PlayState.Paused).to(PlayState.Playing).on(SimCommand.Start);
            this.fsm.onTransition = function (fromState, toState) {
                console.log("Moving from " + PlayState[fromState] + " to " + PlayState[toState] + ".");
            };
            this.fsm.onEnter(PlayState.Stopped, function (from) {
                _this.$timeout(function () {
                    _this.isStopped = true;
                    _this.isPlaying = false;
                    _this.isPaused = false;
                }, 0);
                _this.sendSimTimeMessage(SimCommand.Stop);
                return true;
            });
            this.fsm.onEnter(PlayState.Playing, function (from) {
                _this.$timeout(function () {
                    _this.isPlaying = true;
                    _this.isStopped = false;
                    _this.isPaused = false;
                }, 0);
                _this.sendSimTimeMessage(SimCommand.Start);
                return true;
            });
            this.fsm.onEnter(PlayState.Paused, function (from) {
                _this.$timeout(function () {
                    _this.isPaused = true;
                    _this.isStopped = false;
                    _this.isPlaying = false;
                }, 0);
                _this.sendSimTimeMessage(SimCommand.Pause);
                return true;
            });
            messageBusService.serverSubscribe('Sim.SimTime', 'key', function (title, msg) {
                console.log("Server subscription received: " + title + ", " + JSON.stringify(msg, null, 2) + ".");
                if (!msg
                    || !msg.hasOwnProperty('data')
                    || !msg.data.hasOwnProperty('item')
                    || !msg.data.item)
                    return;
                _this.$timeout(function () {
                    if (msg.data.item.hasOwnProperty('simTime'))
                        _this.time = new Date(+msg.data.item.simTime);
                    else
                        _this.time = new Date(msg.data.item);
                    if (!isNaN(_this.time.getTime())) {
                        messageBusService.publish('timeline', 'setFocus', _this.time);
                    }
                    else {
                        console.log("ERROR processing Sim.SimTime message! Received: (input: " + JSON.stringify(msg.data.item, null, 2));
                    }
                    //console.log(`TIME: ${this.time} (input: ${JSON.stringify(data.data.item, null, 2)})`);
                }, 0);
            });
            $http.get(this.url)
                .then(function (msg) {
                // TODO Why does this always return an empty msg.data element
                // console.log('Received message: ');
                // console.log(msg);
                // console.log(JSON.stringify(msg, null, 2));
            });
            // var handle = messageBusService.serverSubscribe('Sim.SimState.SimulationManager', 'key', (title: string, msg: any) => {
            //     if (!msg
            //         || !msg.hasOwnProperty('data')
            //         || !msg.data.hasOwnProperty('item')) return;
            //     var state = <SimState.ISimState> msg.data.item;
            //     switch (state.state) {
            //         case 'Ready':
            //             this.fsm.currentState = PlayState.Playing;
            //             break;
            //         case 'Stopped':
            //             this.fsm.currentState = PlayState.Stopped;
            //             break;
            //         case 'Paused':
            //             this.fsm.currentState = PlayState.Paused;
            //             break;
            //     }
            //     this.messageBusService.serverUnsubscribe(handle);
            //     //if (this.fsm.currentState !== PlayState.Playing) this.fsm.trigger(SimCommand.Start);
            // })
            // messageBusService.publish('timeline', 'setFocus', this.time);
            // messageBusService.subscribe('Sim', (action: string, data: any) => {
            //     console.log(`action: ${action}, data: ${JSON.stringify(data, null, 2) }`);
            // });
        }
        SimTimeControllerCtrl.prototype.play = function () {
            this.fsm.trigger(SimCommand.Start);
        };
        SimTimeControllerCtrl.prototype.pause = function () {
            this.fsm.trigger(SimCommand.Pause);
        };
        SimTimeControllerCtrl.prototype.stop = function () {
            this.fsm.trigger(SimCommand.Stop);
        };
        SimTimeControllerCtrl.prototype.increaseSpeed = function () {
            this.speed *= 2;
            this.speedChanged();
        };
        SimTimeControllerCtrl.prototype.decreaseSpeed = function () {
            this.speed /= 2;
            this.speedChanged();
        };
        SimTimeControllerCtrl.prototype.setSpeed = function (newSpeed) {
            this.speed = newSpeed;
            this.speedChanged();
        };
        SimTimeControllerCtrl.prototype.setTime = function (newTime) {
            if (this.fsm.currentState !== PlayState.Stopped)
                return;
            this.startTime = this.time = new Date(newTime);
        };
        SimTimeControllerCtrl.prototype.openCalendar = function (e) {
            e.preventDefault();
            e.stopPropagation();
            this.isOpen = true;
        };
        ;
        SimTimeControllerCtrl.prototype.speedChanged = function () {
            if (this.fsm.currentState === PlayState.Playing)
                this.sendSimTimeMessage(SimCommand.Start);
        };
        SimTimeControllerCtrl.prototype.sendSimTimeMessage = function (cmd) {
            var msg = {
                simTime: this.time.valueOf().toString(),
                simSpeed: this.speed.toString(),
                simCmd: SimCommand[cmd],
                type: 'simTime'
            };
            switch (this.httpMethod) {
                case 'POST':
                    this.$http.post(this.url, msg)
                        .error(function (err) { return alert("Failed to deliver message: " + JSON.stringify({ err: err })); });
                    break;
                case 'PUT':
                    this.$http.put(this.url, msg)
                        .error(function (err) { return alert("Failed to deliver message: " + JSON.stringify({ err: err })); });
                    break;
            }
            //
            // this.$http.post( '/api/keys/simTime', msg)
            //     .error((err) => alert( "Failed to deliver message: " + JSON.stringify({err: err})));
        };
        // $inject annotation.
        // It provides $injector with information about dependencies to be in  jected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        SimTimeControllerCtrl.$inject = [
            '$scope',
            '$http',
            'messageBusService',
            '$timeout'
        ];
        return SimTimeControllerCtrl;
    })();
    SimTimeController.SimTimeControllerCtrl = SimTimeControllerCtrl;
})(SimTimeController || (SimTimeController = {}));

var SimTimeController;
(function (SimTimeController) {
    /** Controller class for the SimTimeController editor */
    var SimTimeControllerEditCtrl = (function () {
        function SimTimeControllerEditCtrl($scope, $timeout, $messageBus, $dashboardService) {
            this.$scope = $scope;
            this.$timeout = $timeout;
            this.$messageBus = $messageBus;
            this.$dashboardService = $dashboardService;
            $scope.vm = this;
            $scope.methods = [
                { name: 'GET' },
                { name: 'PUT' },
                { name: 'POST' },
                { name: 'DELETE' }
            ];
            var par = $scope.$parent;
            this.widget = par.data;
            $scope.data = this.widget.data;
            if (!$scope.data.httpMethod)
                $scope.data.httpMethod = $scope.methods[2];
            if (!$scope.data.url)
                $scope.data.url = 'api/keys/simTime';
        }
        // $inject annotation.
        // It provides $injector with information about dependencies to be injected into constructor
        // it is better to have it close to the constructor, because the parameters must match in count and type.
        // See http://docs.angularjs.org/guide/di
        SimTimeControllerEditCtrl.$inject = [
            '$scope',
            '$timeout',
            'messageBusService',
            'dashboardService'
        ];
        return SimTimeControllerEditCtrl;
    })();
    SimTimeController.SimTimeControllerEditCtrl = SimTimeControllerEditCtrl;
})(SimTimeController || (SimTimeController = {}));

var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        'use strict';
        var DatabaseSource = (function () {
            function DatabaseSource(service) {
                this.service = service;
                this.title = "database";
                this.requiresLayer = false;
            }
            DatabaseSource.prototype.refreshLayer = function (layer) {
                this.service.removeLayer(layer);
                this.service.addLayer(layer);
            };
            DatabaseSource.prototype.addLayer = function (layer, callback) {
                this.baseAddLayer(layer, callback);
            };
            /** zoom to boundaries of layer */
            DatabaseSource.prototype.fitMap = function (layer) {
                var b = csComp.Helpers.GeoExtensions.getBoundingBox(this.layer.data);
                this.service.$messageBusService.publish("map", "setextent", b);
            };
            DatabaseSource.prototype.layerMenuOptions = function (layer) {
                var _this = this;
                return [
                    ["Fit map", (function ($itemScope) { return _this.fitMap(layer); })],
                    null,
                    ['Refresh', (function ($itemScope) { return _this.refreshLayer(layer); })]
                ];
            };
            DatabaseSource.prototype.baseAddLayer = function (layer, callback) {
                var _this = this;
                this.layer = layer;
                if (!layer.data || !layer.data.features || layer.BBOX) {
                    async.series([
                        function (cb) {
                            layer.renderType = "geojson";
                            // Open a layer URL
                            layer.isLoading = true;
                            if (layer.BBOX)
                                delete layer.BBOX;
                            var corners;
                            if (_this.service.$mapService.map.getZoom() < 16) {
                                console.log('Zoom level too low, zoom in to show contours');
                                corners = new L.LatLngBounds(new L.LatLng(99.00000, 99.00000), new L.LatLng(99.00001, 99.00001));
                            }
                            else {
                                corners = _this.service.$mapService.map.getBounds();
                            }
                            var coords = [[[corners.getSouthWest().lng, corners.getSouthWest().lat], [corners.getNorthWest().lng, corners.getNorthWest().lat], [corners.getNorthEast().lng, corners.getNorthEast().lat], [corners.getSouthEast().lng, corners.getSouthEast().lat], [corners.getSouthWest().lng, corners.getSouthWest().lat]]];
                            var bounds = JSON.stringify({ type: "Polygon", coordinates: coords, crs: { type: "name", properties: { "name": "EPSG:4326" } } });
                            // get data
                            var bagRequestData = {
                                bounds: bounds,
                                layer: Services.ProjectLayer.serializeableData(layer)
                            };
                            $.ajax({
                                type: 'POST',
                                url: layer.url,
                                data: JSON.stringify(bagRequestData),
                                contentType: "application/json",
                                dataType: 'json',
                                success: (function (data) {
                                    console.log('Requested bag contours');
                                }),
                                error: function () { _this.service.$messageBusService.publish('layer', 'error', layer); }
                            });
                        },
                        // Callback
                        // Callback
                        function () {
                            callback(layer);
                        }
                    ]);
                }
                else {
                    layer.count = 0;
                    layer.isLoading = false;
                    var projLayer = this.service.findLayer(layer.id);
                    if (projLayer) {
                        projLayer.isLoading = false;
                        projLayer.enabled = true;
                    }
                    layer.data.features.forEach(function (f) {
                        _this.service.initFeature(f, layer, false, false);
                    });
                    if (this.service.$rootScope.$root.$$phase != '$apply' && this.service.$rootScope.$root.$$phase != '$digest') {
                        this.service.$rootScope.$apply();
                    }
                    callback(layer);
                }
            };
            DatabaseSource.prototype.removeLayer = function (layer) {
                var projLayer = this.service.findLayer(layer.id);
                if (projLayer)
                    projLayer.enabled = false;
                layer.data.features = {};
                //alert('remove layer');
            };
            return DatabaseSource;
        })();
        Services.DatabaseSource = DatabaseSource;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var GeoJsonSource = (function () {
            function GeoJsonSource(service, $http) {
                this.service = service;
                this.title = "geojson";
                this.requiresLayer = false;
                this.$http = $http;
            }
            GeoJsonSource.prototype.refreshLayer = function (layer) {
                var isEnabled = layer.enabled;
                this.service.removeLayer(layer);
                this.service.addLayer(layer);
                layer.enabled = isEnabled;
            };
            GeoJsonSource.prototype.addLayer = function (layer, callback) {
                this.baseAddLayer(layer, callback);
            };
            /** zoom to boundaries of layer */
            GeoJsonSource.prototype.fitMap = function (layer) {
                var b = csComp.Helpers.GeoExtensions.getBoundingBox(this.layer.data);
                this.service.$messageBusService.publish("map", "setextent", b);
            };
            GeoJsonSource.prototype.layerMenuOptions = function (layer) {
                var _this = this;
                return [
                    ["Fit map", (function ($itemScope) { return _this.fitMap(layer); })],
                    null,
                    ['Refresh', (function ($itemScope) { return _this.refreshLayer(layer); })]
                ];
            };
            GeoJsonSource.prototype.baseAddLayer = function (layer, callback) {
                var _this = this;
                this.layer = layer;
                async.series([
                    function (cb) {
                        layer.renderType = "geojson";
                        // Open a layer URL
                        layer.isLoading = true;
                        // get data
                        var u = layer.url.replace('[BBOX]', layer.BBOX);
                        _this.$http.get(u)
                            .success(function (data) {
                            layer.count = 0;
                            layer.isLoading = false;
                            layer.enabled = true;
                            _this.initLayer(data, layer);
                            cb(null, null);
                        })
                            .error(function () {
                            layer.count = 0;
                            layer.isLoading = false;
                            layer.enabled = false;
                            layer.isConnected = false;
                            _this.service.$messageBusService.notify('ERROR loading ' + layer.title, '\nwhile loading: ' + u);
                            // this.service.$messageBusService.publish('layer', 'error', layer);
                            cb(null, null);
                        });
                    },
                    // Callback
                    // Callback
                    function () {
                        callback(layer);
                    }
                ]);
            };
            GeoJsonSource.prototype.initLayer = function (data, layer) {
                var _this = this;
                // if this is a topojson layer, convert to geojson first
                if (layer.type.toLowerCase() === 'topojson') {
                    data = csComp.Helpers.GeoExtensions.convertTopoToGeoJson(data);
                }
                if (layer.id.toLowerCase() === 'accessibility' || layer.id.toLowerCase() === 'tripplanner') {
                    layer.disableMoveSelectionToFront = true;
                    this.processAccessibilityReply(data, layer, function (processedLayer) {
                        data = layer.data;
                        layer = processedLayer;
                    });
                }
                // add featuretypes to global featuretype list
                if (data.featureTypes)
                    for (var featureTypeName in data.featureTypes) {
                        if (!data.featureTypes.hasOwnProperty(featureTypeName))
                            continue;
                        var featureType = data.featureTypes[featureTypeName];
                        // give it a unique name
                        featureTypeName = layer.url + '#' + featureTypeName;
                        this.service._featureTypes[featureTypeName] = featureType;
                    }
                if (data.timestamps)
                    layer.timestamps = data.timestamps;
                // store raw result in layer
                layer.data = data;
                if (layer.data.geometries && !layer.data.features) {
                    layer.data.features = layer.data.geometries;
                }
                layer.data.features.forEach(function (f) {
                    _this.service.initFeature(f, layer, false, false);
                });
                this.service.$messageBusService.publish("timeline", "updateFeatures");
            };
            GeoJsonSource.prototype.removeLayer = function (layer) {
                //alert('remove layer');
            };
            GeoJsonSource.prototype.processAccessibilityReply = function (data, layer, clbk) {
                if (data.hasOwnProperty('error')) {
                    console.log('Error in opentripplanner: ' + data['error'].msg);
                    clbk(layer);
                    return;
                }
                var latlng;
                var urlParameters = csComp.Helpers.parseUrlParameters(layer.url, '?', '&', '=');
                if (urlParameters.hasOwnProperty('fromPlace')) {
                    var coords = urlParameters['fromPlace'].split('%2C');
                    if (isNaN(+coords[0]) || isNaN(+coords[1]))
                        clbk(layer);
                    latlng = new L.LatLng(+coords[0], +coords[1]);
                }
                var parsedData = data;
                if (parsedData.hasOwnProperty('features')) {
                    //Add arrival times when leaving now
                    var startTime = new Date(Date.now());
                    parsedData.features.forEach(function (f) {
                        f.properties['seconds'] = f.properties['time'];
                        f.properties['time'] = f.properties['seconds'] * 1000;
                        f.properties['arriveTime'] = (new Date(startTime.getTime() + f.properties['time'])).toISOString();
                        f.properties['latlng'] = [latlng.lat, latlng.lng];
                    });
                    if (layer.hasOwnProperty('data') && layer.data.hasOwnProperty('features')) {
                        for (var index = 0; index < layer.data.features.length; index++) {
                            var f = layer.data.features[index];
                            if (f.properties.hasOwnProperty('latlng') && f.properties['latlng'][0] === latlng.lat && f.properties['latlng'][1] === latlng.lng) {
                                layer.data.features.splice(index--, 1);
                            }
                        }
                        parsedData.features.forEach(function (f) {
                            layer.data.features.push(f);
                        });
                    }
                    else {
                        layer.count = 0;
                        layer.data = parsedData;
                    }
                }
                else {
                    var fromLoc = parsedData.plan.from;
                    var toLoc = parsedData.plan.to;
                    layer.data = {};
                    layer.data.type = 'FeatureCollection';
                    layer.data.features = [];
                    parsedData.plan.itineraries.forEach(function (it) {
                        var route = new L.Polyline([]);
                        var legs = [];
                        var transfers = -1;
                        it.legs.forEach(function (leg) {
                            var polyLeg = L.Polyline.fromEncoded(leg.legGeometry.points);
                            polyLeg.getLatLngs().forEach(function (ll) {
                                route.addLatLng(ll);
                            });
                            var legDetails = {
                                mode: leg.mode,
                                start: new Date(leg.startTime).toISOString(),
                                arrive: new Date(leg.endTime).toISOString(),
                                duration: csComp.Helpers.convertPropertyInfo({ type: "duration" }, (+leg.duration) * 1000)
                            };
                            (leg.agencyName) ? legDetails.agency = leg.agencyName : null;
                            (leg.routeShortName) ? legDetails.route = leg.routeShortName : null;
                            (leg.routeLongName) ? legDetails.routeName = leg.routeLongName : null;
                            if (leg.mode !== 'WALK' && leg.mode !== 'BICYCLE')
                                transfers = transfers + 1;
                            legs.push(legDetails);
                        });
                        var geoRoute = route.toGeoJSON();
                        layer.data.features.push(csComp.Helpers.GeoExtensions.createLineFeature(geoRoute.geometry.coordinates, {
                            fromLoc: fromLoc.name,
                            toLoc: toLoc.name,
                            duration: (+it.duration) * 1000,
                            startTime: new Date(it.startTime).toISOString(),
                            arriveTime: new Date(it.endTime).toISOString(),
                            legs: legs,
                            transfers: (transfers >= 0) ? transfers : 0
                        }));
                    });
                }
                clbk(layer);
            };
            return GeoJsonSource;
        })();
        Services.GeoJsonSource = GeoJsonSource;
        var DynamicGeoJsonSource = (function (_super) {
            __extends(DynamicGeoJsonSource, _super);
            function DynamicGeoJsonSource(service, $http) {
                _super.call(this, service, $http);
                this.service = service;
                this.title = "dynamicgeojson";
                // subscribe
            }
            DynamicGeoJsonSource.prototype.updateFeatureByProperty = function (key, id, value, layer) {
                var _this = this;
                if (layer === void 0) { layer = null; }
                try {
                    var features = this.layer.data.features;
                    if (features == null)
                        return;
                    var done = false;
                    features.some(function (f) {
                        if (f.hasOwnProperty(key) && f[key] === id) {
                            f.properties = value.properties;
                            f.geometry = value.geometry;
                            _this.service.calculateFeatureStyle(f);
                            _this.service.updateFeature(f);
                            done = true;
                            _this.service.$messageBusService.notify(_this.layer.title, value.properties['Name'] + " updated");
                            //  console.log('updating feature');
                            return true;
                        }
                        else {
                            return false;
                        }
                    });
                    if (!done) {
                        // console.log('adding feature');
                        if (layer && layer.data && layer.data.features) {
                            layer.data.features.push(value);
                            this.service.initFeature(value, layer, false);
                            var m = this.service.activeMapRenderer.addFeature(value);
                            if (layer.showFeatureNotifications)
                                this.service.$messageBusService.notify(layer.title, value.properties['Name'] + " added");
                        }
                        else {
                            features.push(value);
                            this.service.initFeature(value, this.layer);
                            var m = this.service.activeMapRenderer.addFeature(value);
                            if (layer.showFeatureNotifications)
                                this.service.$messageBusService.notify(this.layer.title, value.properties['Name'] + " added");
                        }
                    }
                }
                catch (e) {
                    console.log('error');
                }
            };
            DynamicGeoJsonSource.prototype.deleteFeatureByProperty = function (key, id, value) {
                var _this = this;
                try {
                    var features = this.layer.data.features;
                    if (features == null)
                        return;
                    var done = false;
                    features.some(function (f) {
                        if (f.properties != null && f.properties.hasOwnProperty(key) && f.properties[key] === id) {
                            f.properties = value.properties;
                            f.geometry = value.geometry;
                            _this.service.calculateFeatureStyle(f);
                            _this.service.updateFeature(f);
                            done = true;
                            //  console.log('updating feature');
                            return true;
                        }
                        else {
                            return false;
                        }
                    });
                    if (!done) {
                        // console.log('adding feature');
                        features.push(value);
                        this.service.initFeature(value, this.layer);
                        var m = this.service.activeMapRenderer.createFeature(value);
                    }
                }
                catch (e) {
                    console.log('error');
                }
            };
            DynamicGeoJsonSource.prototype.initSubscriptions = function (layer) {
                var _this = this;
                layer.serverHandle = this.service.$messageBusService.serverSubscribe(layer.id, "layer", function (topic, msg) {
                    console.log("action:" + msg.action);
                    switch (msg.action) {
                        case "unsubscribed":
                            _this.service.$rootScope.$apply(function () {
                                layer.isConnected = false;
                            });
                            break;
                        case "subscribed":
                            layer.isConnected = true;
                            //console.log('sucesfully subscribed');
                            break;
                        case "layer":
                            if (msg.data != null) {
                                try {
                                    var lu = msg.data;
                                    switch (lu.action) {
                                        case Services.LayerUpdateAction.updateLog:
                                            // find feature
                                            var fId = lu.featureId;
                                            var logs = lu.item;
                                            var ff = _this.layer.data.features;
                                            ff.forEach(function (f) {
                                                if (f.id === fId) {
                                                    if (!f.logs)
                                                        f.logs = {};
                                                    for (var k in logs) {
                                                        if (!f.logs.hasOwnProperty(k))
                                                            f.logs[k] = [];
                                                        logs[k].forEach(function (li) { return f.logs[k].push(li); });
                                                    }
                                                    // update logs
                                                    _this.service.$rootScope.$apply(function () {
                                                        _this.service.updateLog(f);
                                                    });
                                                    return true;
                                                }
                                                return false;
                                            });
                                            break;
                                        case Services.LayerUpdateAction.updateFeature:
                                            var f = lu.item;
                                            if (layer.id === lu.layerId) {
                                                _this.service.$rootScope.$apply(function () {
                                                    _this.updateFeatureByProperty("id", f.id, f, layer);
                                                });
                                            }
                                            break;
                                        case Services.LayerUpdateAction.deleteFeature:
                                            var feature = _this.service.findFeature(layer, lu.featureId);
                                            if (feature) {
                                                _this.service.$messageBusService.notify(_this.layer.title, feature.properties['Name'] + " removed");
                                                _this.service.removeFeature(feature, false);
                                            }
                                            lu.featureId;
                                            // lu.object.forEach((f) => {
                                            //
                                            //     //this.service.removeFeature(f);
                                            // });
                                            break;
                                    }
                                }
                                catch (e) {
                                    console.warn('Error updating feature: ' + JSON.stringify(e, null, 2));
                                }
                            }
                            break;
                    }
                });
            };
            DynamicGeoJsonSource.prototype.addLayer = function (layer, callback) {
                var _this = this;
                layer.isDynamic = true;
                this.baseAddLayer(layer, function (layer) {
                    callback(layer);
                    if (layer.enabled) {
                        _this.initSubscriptions(layer);
                    }
                });
            };
            DynamicGeoJsonSource.prototype.removeLayer = function (layer) {
                layer.isConnected = false;
                if (layer.gui['editing'])
                    this.stopAddingFeatures(layer);
                this.service.$messageBusService.serverUnsubscribe(layer.serverHandle);
            };
            DynamicGeoJsonSource.prototype.layerMenuOptions = function (layer) {
                var _this = this;
                var res = [
                    ["Fit map", (function ($itemScope) { return _this.fitMap(layer); })]
                ];
                return res;
            };
            DynamicGeoJsonSource.prototype.startAddingFeatures = function (layer) {
                this.service.project.groups.forEach(function (g) {
                    var v = false;
                    g.layers.forEach(function (l) {
                        if (l === layer) {
                            v = true;
                            l.gui['editing'] = true;
                        }
                        else {
                            l.gui['editing'] = false;
                        }
                    });
                    g.gui.editing = v;
                });
                this.service.editing = true;
                this.initAvailableFeatureTypes(layer);
            };
            DynamicGeoJsonSource.prototype.initAvailableFeatureTypes = function (layer) {
                var featureTypes = {};
                if (layer) {
                    if (layer.typeUrl && this.service.typesResources.hasOwnProperty(layer.typeUrl)) {
                        for (var ft in this.service.typesResources[this.layer.typeUrl].featureTypes) {
                            var t = this.service.typesResources[this.layer.typeUrl].featureTypes[ft];
                            if (t.style.drawingMode.toLowerCase() === "point") {
                                featureTypes[ft] = this.service.typesResources[this.layer.typeUrl].featureTypes[ft];
                                featureTypes[ft].u = csComp.Helpers.getImageUri(ft);
                            }
                        }
                    }
                }
                layer.gui["featureTypes"] = featureTypes;
            };
            DynamicGeoJsonSource.prototype.stopAddingFeatures = function (layer) {
                delete layer.gui["featureTypes"];
                this.service.project.groups.forEach(function (g) {
                    delete g.gui['editing'];
                    g.layers.forEach(function (l) {
                        l.gui['editing'] = false;
                    });
                });
                this.service.editing = false;
            };
            return DynamicGeoJsonSource;
        })(GeoJsonSource);
        Services.DynamicGeoJsonSource = DynamicGeoJsonSource;
        var EsriJsonSource = (function (_super) {
            __extends(EsriJsonSource, _super);
            function EsriJsonSource(service, $http) {
                _super.call(this, service, $http);
                this.service = service;
                this.title = "esrijson";
                // subscribe
            }
            EsriJsonSource.prototype.addLayer = function (layer, callback) {
                var _this = this;
                layer.renderType = "geojson";
                // Open a layer URL
                layer.isLoading = true;
                this.$http({
                    url: '/api/proxy',
                    method: "GET",
                    params: { url: layer.url }
                }).success(function (data) {
                    var s = new esriJsonConverter.esriJsonConverter();
                    var geojson = s.toGeoJson(JSON.parse(data));
                    console.log(geojson);
                    layer.data = geojson; //csComp.Helpers.GeoExtensions.createFeatureCollection(features);
                    if (layer.data.geometries && !layer.data.features) {
                        layer.data.features = layer.data.geometries;
                    }
                    layer.data.features.forEach(function (f) {
                        _this.service.initFeature(f, layer, false, false);
                    });
                    _this.service.$messageBusService.publish("timeline", "updateFeatures");
                    layer.isLoading = false;
                    callback(layer);
                })
                    .error(function () {
                    console.log('EsriJsonSource called $HTTP with errors...');
                });
            };
            return EsriJsonSource;
        })(GeoJsonSource);
        Services.EsriJsonSource = EsriJsonSource;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        /**
         * A GRID data source is a raster or grid in which the grid cells are delimited by spaces
         * and each newline indicates a new row of data.
         */
        var GridDataSource = (function (_super) {
            __extends(GridDataSource, _super);
            function GridDataSource(service, $http) {
                _super.call(this, service, $http);
                this.service = service;
                this.title = "grid";
            }
            GridDataSource.prototype.addLayer = function (layer, callback) {
                var _this = this;
                this.layer = layer;
                if (typeof layer.dataSourceParameters === 'undefined') {
                    throw new Error("Undefined IGridData data property in GridDataSource.");
                    return;
                }
                this.gridParams = layer.dataSourceParameters;
                // Select the appropriate converter for converting points to features:
                if (this.gridParams.useContour) {
                    this.convertDataToFeatureCollection = this.convertDataToIsoLines;
                }
                else {
                    this.convertDataToFeatureCollection = this.convertDataToPolygonGrid;
                }
                // Open a layer URL
                layer.isLoading = true;
                // get data
                $.get(layer.url, function (result, status) {
                    // https://github.com/caolan/async#seriestasks-callback
                    async.series([
                        function (cb) {
                            layer.count = 0;
                            if (typeof _this.gridParams.gridType !== 'undefined' && _this.gridParams.gridType === 'esri') {
                                _this.convertEsriHeaderToGridParams(result);
                            }
                            if (layer.renderType === 'gridlayer') {
                                layer.data = _this.convertDataToGrid(result, _this.gridParams);
                                ;
                                layer.isLoading = false;
                                cb(null, null);
                                return;
                            }
                            var data = _this.convertDataToFeatureCollection(result, _this.gridParams);
                            if (data.fc.features.length > 10000) {
                                console.warn('Grid is very big! Number of features: ' + data.fc.features.length);
                            }
                            if (data.fc.features.length === 0) {
                                _this.service.$messageBusService.notify('Warning', 'Data loaded successfully, but all points are outside the specified range.', csComp.Services.NotifyLocation.TopRight, csComp.Services.NotifyType.Error);
                                layer.isLoading = false;
                                cb(null, null);
                                return;
                            }
                            // store raw result in layer
                            layer.data = data.fc;
                            //layer.description = data.desc;
                            if (layer.data.geometries && !layer.data.features) {
                                layer.data.features = layer.data.geometries;
                            }
                            var count = 0;
                            var last = layer.data.features.length - 1;
                            layer.data.features.forEach(function (f) {
                                _this.service.initFeature(f, layer, false, false);
                            });
                            layer.isLoading = false;
                            cb(null, null);
                        },
                        function () {
                            callback(layer);
                        }
                    ]);
                }).fail(function (err) {
                    layer.isLoading = false;
                    console.log("Failed loading layer " + layer.title + " due to " + err + ".");
                });
            };
            /**
             * Convert the ESRI ASCII GRID header to grid parameters.
             *
                ESRI ASCII Raster format
                The ESRI ASCII raster format can be used to transfer information to or from other cell-based or raster systems. When an existing raster is output to an ESRI ASCII format raster, the file will begin with header information that defines the properties of the raster such as the cell size, the number of rows and columns, and the coordinates of the origin of the raster. The header information is followed by cell value information specified in space-delimited row-major order, with each row seperated by a carraige return.
                In order to convert an ASCII file to a raster, the data must be in this same format. The parameters in the header part of the file must match correctly with the structure of the data values.
                The basic structure of the ESRI ASCII raster has the header information at the beginning of the file followed by the cell value data:
                    NCOLS xxx
                    NROWS xxx
                    XLLCENTER xxx | XLLCORNER xxx
                    YLLCENTER xxx | YLLCORNER xxx
                    CELLSIZE xxx
                    NODATA_VALUE xxx
                    row 1
                    row 2
                    ...
                    row n
                *
                Row 1 of the data is at the top of the raster, row 2 is just under row 1, and so on.
                Header format
                The syntax of the header information is a keyword paired with the value of that keyword. The definitions of the kewords are:
                *
                Parameter	Description	Requirements
                NCOLS	Number of cell columns.	Integer greater than 0.
                NROWS	Number of cell rows.	Integer greater than 0.
                XLLCENTER or XLLCORNER	X coordinate of the origin (by center or lower left corner of the cell).	Match with Y coordinate type.
                YLLCENTER or YLLCORNER	Y coordinate of the origin (by center or lower left corner of the cell).	Match with X coordinate type.
                CELLSIZE	Cell size.	Greater than 0.
                NODATA_VALUE	The input values to be NoData in the output raster.	Optional. Default is -9999.
                Data format
                The data component of the ESRI ASCII raster follows the header information.
                Cell values should be delimited by spaces.
                No carriage returns are necessary at the end of each row in the raster. The number of columns in the header determines when a new row begins.
                Row 1 of the data is at the top of the raster, row 2 is just under row 1, and so on.
             */
            GridDataSource.prototype.convertEsriHeaderToGridParams = function (input) {
                var _this = this;
                var regex = /(\S*)\s*([\d-.]*)/;
                var data = this.getData(input);
                if (!data)
                    return;
                var lines = data.split('\n', 6);
                var x, y;
                var isCenter = false;
                this.gridParams.skipLines = 0;
                lines.forEach(function (line) {
                    var matches = line.match(regex);
                    if (matches.length !== 3)
                        return;
                    _this.gridParams.skipLines++;
                    var value = +matches[2];
                    switch (matches[1].toLowerCase()) {
                        case 'ncols':
                            // Number of cell columns. Integer greater than 0.
                            _this.gridParams.columns = value;
                            break;
                        case 'nrows':
                            // Number of cell rows. Integer greater than 0.
                            _this.gridParams.rows = value;
                            break;
                        case 'xllcorner':
                            x = value;
                            // X coordinate of the origin (by lower left corner of the cell).
                            break;
                        case 'yllcorner':
                            y = value;
                            // Y coordinate of the origin (by lower left corner of the cell).
                            break;
                        case 'xllcenter':
                            // X coordinate of the origin (by center corner of the cell).
                            x = value;
                            isCenter = true;
                            break;
                        case 'yllcenter':
                            // Y coordinate of the origin (by center corner of the cell).
                            y = value;
                            isCenter = true;
                            break;
                        case 'cellsize':
                            // Cell size. Greater than 0.
                            _this.gridParams.deltaLon = value;
                            _this.gridParams.deltaLat = -value;
                            break;
                        case 'nodata_value':
                            // The input values to be NoData in the output raster. Optional. Default is -9999.
                            _this.gridParams.noDataValue = value;
                            break;
                    }
                });
                if (isCenter) {
                    this.gridParams.startLon = x;
                    this.gridParams.startLat = y;
                }
                else {
                    this.gridParams.startLon = x + this.gridParams.deltaLon / 2;
                    this.gridParams.startLat = y - this.gridParams.deltaLat / 2;
                }
                /* WARNING: The below RD projection is NOT correct!!! To convert an RD grid to a WGS84 grid requires a complex
                 * translation using shearing and approximating pixels. It's better to use gdal (standalone, or with QGIS).
                 *
                 * For example, execute the following in a batch file:
                 * First, convert the input data to vrt, reprojecting from RD to wgs84, and replacing the nodata value at the same time.
                 * As gdalwarp does not support AAIGrid as output, we first convert it to VRT, and use gdal_translate to translate it to an ESRI ASCII GRID file.
                 *
                 * for %%f in (*.asc) do (
                 * 		echo Processing %%f
                 * 		"c:/Program Files/QGIS Pisa/bin/gdalwarp.exe" --config GDAL_DATA "c:/OSGeo4W64/share/gdal" -srcnodata -999.0 -dstnodata -1 -t_srs EPSG:4296 -s_srs EPSG:28992 -of VRT -r average %%f %%f_intermediate.vrt
                 * 		"c:/Program Files/QGIS Pisa/bin/gdal_translate.exe" -of AAIGrid %%f_intermediate.vrt %%f.out
                 * 		del %%f_intermediate.vrt
                 * 	)
                 */
                switch (this.gridParams.projection || 'wgs84') {
                    case 'rd':
                    case 'RD':
                        var startLoc = csComp.Helpers.GeoExtensions.convertRDToWGS84(this.gridParams.startLon, this.gridParams.startLat - (this.gridParams.rows - 1) * this.gridParams.deltaLat);
                        var endLoc = csComp.Helpers.GeoExtensions.convertRDToWGS84(this.gridParams.startLon + (this.gridParams.columns - 1) * this.gridParams.deltaLon, this.gridParams.startLat);
                        this.gridParams.deltaLon = (endLoc.longitude - startLoc.longitude) / (this.gridParams.columns - 1);
                        this.gridParams.deltaLat = (endLoc.latitude - startLoc.latitude) / (this.gridParams.rows - 1);
                        this.gridParams.startLon = startLoc.longitude;
                        this.gridParams.startLat = startLoc.latitude;
                        break;
                    case 'WGS84':
                    case 'wgs84':
                        this.gridParams.startLat -= (this.gridParams.rows - 1) * this.gridParams.deltaLat;
                        break;
                    default:
                        throw new Error('Current projection is not supported!');
                        break;
                }
            };
            /** Extract the grid data from the input */
            GridDataSource.prototype.getData = function (input) {
                if (typeof input === 'string') {
                    return input;
                }
                else if (input.hasOwnProperty('data') && typeof input['data'] === 'string') {
                    return input['data'];
                }
                else {
                    console.log('GridDataSource error: could not read grid data!');
                    return '';
                }
            };
            /**
             * Convert the incoming data to a matrix grid.
             * The incoming data can be in two formats: either it is a string, representing the ASCII grid data,
             * or it is an (ILayer) object, in which case the data should be in the input.data property.
             */
            GridDataSource.prototype.convertDataToGrid = function (input, gridParams) {
                var data = this.getData(input);
                if (!data)
                    return;
                var propertyName = gridParams.propertyName || "v";
                var noDataValue = gridParams.noDataValue || -9999;
                var skipLinesAfterComment = gridParams.skipLinesAfterComment, skipSpacesFromLine = gridParams.skipSpacesFromLine, skipFirstRow = gridParams.skipFirstRow || false, skipFirstColumn = gridParams.skipFirstColumn || false;
                var separatorCharacter = gridParams.separatorCharacter || ' ', splitCellsRegex = new RegExp("[^" + separatorCharacter + "]+", "g");
                var deltaLon = gridParams.deltaLon, deltaLat = gridParams.deltaLat, lat = gridParams.startLat, lon = gridParams.startLon;
                var max = gridParams.maxThreshold || -Number.MAX_VALUE, min = gridParams.minThreshold || Number.MAX_VALUE;
                var lines = data.split('\n'), i = 0, gridData = [];
                if (gridParams.skipLines)
                    lines.splice(0, gridParams.skipLines);
                var rowsToProcess = gridParams.rows || Number.MAX_VALUE;
                lines.forEach(function (line) {
                    if (gridParams.commentCharacter)
                        if (line.substr(0, 1) === gridParams.commentCharacter) {
                            console.log(line);
                            return;
                        }
                    if (skipLinesAfterComment && skipLinesAfterComment > 0) {
                        skipLinesAfterComment--;
                        return;
                    }
                    if (skipFirstRow) {
                        skipFirstRow = false;
                        return;
                    }
                    rowsToProcess--;
                    if (rowsToProcess < 0)
                        return gridData;
                    var cells;
                    if (skipSpacesFromLine)
                        cells = line.substr(skipSpacesFromLine).match(splitCellsRegex);
                    else
                        cells = line.match(splitCellsRegex);
                    if (skipFirstColumn && cells.length > 1)
                        cells = cells.splice(1);
                    if (!cells || (!gridParams.skipFirstColumn && cells.length < gridParams.columns))
                        return;
                    gridData[i] = [];
                    cells.forEach(function (c) { return gridData[i].push(+c); });
                    max = Math.max.apply(Math, [max].concat(gridData[i]));
                    min = Math.min.apply(Math, [min].concat(gridData[i]));
                    i++;
                });
                gridParams.maxThreshold = max;
                gridParams.minThreshold = min;
                return gridData;
            };
            /**
             * Convert data to a set of isolines.
             */
            GridDataSource.prototype.convertDataToIsoLines = function (data, gridParams) {
                var gridData = this.convertDataToGrid(data, gridParams);
                var propertyName = gridParams.propertyName || "v";
                var longitudes = [], latitudes = [];
                var lat = gridParams.startLat, lon = gridParams.startLon, deltaLat = gridParams.deltaLat, deltaLon = gridParams.deltaLon;
                var max = gridParams.maxThreshold, min = gridParams.minThreshold;
                gridData.forEach(function (row) {
                    latitudes.push(lat);
                    lat += deltaLat;
                });
                gridData[0].forEach(function (col) {
                    longitudes.push(lon);
                    lon += deltaLon;
                    if (lon > 180)
                        lon -= 360;
                });
                var features = [];
                var conrec = new csComp.Helpers.Conrec(), nrIsoLevels, isoLevels;
                if (typeof gridParams.contourLevels === 'undefined')
                    nrIsoLevels = 10;
                else {
                    var cl = gridParams.contourLevels;
                    if (typeof cl === 'number') {
                        nrIsoLevels = cl;
                    }
                    else {
                        isoLevels = cl;
                        nrIsoLevels = cl.length;
                    }
                }
                if (typeof isoLevels === 'undefined') {
                    isoLevels = [];
                    var dl = (max - min) / nrIsoLevels;
                    for (var l = min + dl / 2; l < max; l += dl)
                        isoLevels.push(Math.round(l * 10) / 10); // round to nearest decimal.
                }
                conrec.contour(gridData, 0, gridData.length - 1, 0, gridData[0].length - 1, latitudes, longitudes, nrIsoLevels, isoLevels, gridParams.noDataValue || -9999);
                var contourList = conrec.contourList;
                contourList.forEach(function (contour) {
                    var result = {};
                    result[propertyName] = contour.level;
                    var feature = {
                        type: 'Feature',
                        geometry: {
                            type: 'Polygon'
                        },
                        properties: result
                    };
                    var ring = [];
                    feature.geometry.coordinates = [ring];
                    contour.forEach(function (p) {
                        ring.push([p.y, p.x]);
                    });
                    features.push(feature);
                });
                var desc = "# Number of features above the threshold: " + features.length + ".\r\n";
                return {
                    fc: csComp.Helpers.GeoExtensions.createFeatureCollection(features),
                    desc: desc
                };
            };
            /**
             * Convert data to a grid of square GeoJSON polygons, so each drawable point is converted to a square polygon.
             */
            GridDataSource.prototype.convertDataToPolygonGrid = function (data, gridParams) {
                var propertyName = gridParams.propertyName || "v";
                var gridData = this.convertDataToGrid(data, gridParams);
                var lat = gridParams.startLat, deltaLat = gridParams.deltaLat, deltaLon = gridParams.deltaLon, noDataValue = gridParams.noDataValue;
                var minThreshold = gridParams.minThreshold || -Number.MAX_VALUE, maxThreshold = gridParams.maxThreshold || Number.MAX_VALUE;
                var features = [];
                gridData.forEach(function (row) {
                    var lon = gridParams.startLon;
                    row.forEach(function (n) {
                        var value = +n;
                        if (value !== noDataValue && minThreshold <= value && value <= maxThreshold) {
                            var result = {};
                            result[propertyName] = value;
                            var tl = [lon, lat + deltaLat], tr = [lon + deltaLon, lat + deltaLat], bl = [lon, lat], br = [lon + deltaLon, lat];
                            var pg = csComp.Helpers.GeoExtensions.createPolygonFeature([[tl, tr, br, bl, tl]], result);
                            features.push(pg);
                        }
                        lon += deltaLon;
                        if (lon > 180)
                            lon -= 360;
                    });
                    lat += deltaLat;
                });
                //
                // var propertyName = gridParams.propertyName || "v";
                // var noDataValue = gridParams.noDataValue || -9999;
                //
                // var skipLinesAfterComment = gridParams.skipLinesAfterComment,
                //     skipSpacesFromLine = gridParams.skipSpacesFromLine,
                //     skipFirstRow = gridParams.skipFirstRow || false,
                //     skipFirstColumn = gridParams.skipFirstColumn || false;
                //
                // var separatorCharacter = gridParams.separatorCharacter || ' ',
                //     splitCellsRegex = new RegExp("[^" + separatorCharacter + "]+", "g");
                //
                // var deltaLon = gridParams.deltaLon,
                //     deltaLat = gridParams.deltaLat,
                //     lat = gridParams.startLat,
                //     lon = gridParams.startLon;
                //
                // var features: csComp.Helpers.IGeoFeature[] = [];
                //
                // var lines = data.split('\n');
                // if (gridParams.skipLines) lines.splice(0, gridParams.skipLines);
                //
                // var rowsToProcess = gridParams.rows || Number.MAX_VALUE;
                // lines.forEach((line) => {
                //     if (gridParams.commentCharacter)
                //         if (line.substr(0, 1) === gridParams.commentCharacter) {
                //             console.log(line);
                //             return;
                //         }
                //
                //     if (skipLinesAfterComment && skipLinesAfterComment > 0) {
                //         skipLinesAfterComment--;
                //         return;
                //     }
                //
                //     if (skipFirstRow) {
                //         skipFirstRow = false;
                //         return;
                //     }
                //     rowsToProcess--;
                //     if (rowsToProcess < 0) return;
                //
                //     var cells: RegExpMatchArray;
                //     if (skipSpacesFromLine)
                //         cells = line.substr(skipSpacesFromLine).match(splitCellsRegex);
                //     else
                //         cells = line.match(splitCellsRegex);
                //
                //     if (skipFirstColumn && cells.length > 1) cells = cells.splice(1);
                //
                //     if (!cells || (!gridParams.skipFirstColumn && cells.length < gridParams.columns)) return;
                //
                //     lon = gridParams.startLon;
                //     var minThreshold = gridParams.minThreshold || -Number.MAX_VALUE,
                //         maxThreshold = gridParams.maxThreshold || Number.MAX_VALUE;
                //     cells.forEach((n) => {
                //         var value = +n;
                //         if (value !== noDataValue && minThreshold <= value && value <= maxThreshold) {
                //             var result: IProperty = {};
                //             result[propertyName] = value;
                //             var tl = [lon, lat + deltaLat],
                //                 tr = [lon + deltaLon, lat + deltaLat],
                //                 bl = [lon, lat],
                //                 br = [lon + deltaLon, lat];
                //
                //             var pg = csComp.Helpers.GeoExtensions.createPolygonFeature([[tl, tr, br, bl, tl]], result);
                //             features.push(pg);
                //         }
                //         lon += deltaLon;
                //         if (lon > 180) lon -= 360;
                //     });
                //     lat += deltaLat;
                // });
                var desc = "# Number of features above the threshold: " + features.length + ".\r\n";
                return {
                    fc: csComp.Helpers.GeoExtensions.createFeatureCollection(features),
                    desc: desc
                };
            }; // convertDataToGeoJSON
            return GridDataSource;
        })(csComp.Services.GeoJsonSource);
        Services.GridDataSource = GridDataSource;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        'use strict';
        var HeatmapSource = (function () {
            function HeatmapSource(service) {
                this.service = service;
                this.title = "heatmap";
                this.requiresLayer = true;
                //service: LayerService;
                this.heatmapModel = new Heatmap.HeatmapModel("ProjectHeatmap");
            }
            //public init(service: LayerService) {
            //    this.service = service;
            //}
            HeatmapSource.prototype.refreshLayer = function (layer) {
                this.generateHeatmap(layer);
            };
            HeatmapSource.prototype.layerMenuOptions = function (layer) {
                return null;
            };
            HeatmapSource.prototype.addLayer = function (layer, callback) {
                var _this = this;
                async.series([
                    function (cb) {
                        layer.renderType = "heatmap";
                        layer.isLoading = true;
                        if (layer.quickRefresh && layer.quickRefresh == true) {
                            // In case the map has not moved, the heatmap cells do not need to be calculated again, only the style of the markers need to be updated.
                            _this.heatmapModel.deserialize(layer);
                            _this.heatmapModel.id = layer.id;
                            _this.heatmapModel.updateWeights();
                            if (layer.heatmapItems) {
                                var hiWeights = {};
                                _this.heatmapModel.heatmapItems.forEach(function (hi) {
                                    hiWeights[hi.toString()] = hi.weight;
                                });
                                var weightedIntensityScale = ((_this.heatmapModel.heatmapSettings.intensityScale / 3) * (_this.heatmapModel.heatmapSettings.intensityScale / 3)); // Convert intensityscale from [1,...,5] to ~[0.1, 0.5, 1, 2, 3]
                                _this.service.project.features.forEach(function (f) {
                                    if (f.properties.hasOwnProperty('intensities') && f.properties.hasOwnProperty('contributors')) {
                                        var intensities = JSON.parse(f.properties['intensities']);
                                        var totalIntensity = 0;
                                        for (var key in intensities) {
                                            if (intensities.hasOwnProperty(key)) {
                                                totalIntensity += intensities[key] * hiWeights[key] * weightedIntensityScale;
                                            }
                                        }
                                        f.properties['totalIntensity'] = totalIntensity;
                                        _this.service.calculateFeatureStyle(f);
                                        _this.service.activeMapRenderer.updateFeature(f);
                                    }
                                });
                            }
                        }
                        else {
                            // In all other occasions, (re)calculate the complete heatmap
                            _this.generateHeatmap(layer);
                            layer.enabled = true;
                            _this.enableProjectLayer(layer);
                        }
                        layer.isLoading = false;
                        cb(null, null);
                    },
                    // Callback
                    // Callback
                    function () {
                        callback(layer);
                    }
                ]);
            };
            HeatmapSource.prototype.removeLayer = function (layer) {
                delete (this.heatmapModel);
                this.heatmapModel = new Heatmap.HeatmapModel("ProjectHeatmap");
                layer.enabled = false;
                layer.data = JSON;
                this.enableProjectLayer(layer); // Set project layer to disabled
                //this.updateLayer(layer);
            };
            /* Enables the project layer if the 'layer' parameter has the same id as a project layer */
            HeatmapSource.prototype.enableProjectLayer = function (layer) {
                if (layer.id) {
                    this.service.project.groups.forEach(function (group) {
                        group.layers.forEach(function (l) {
                            if (l.id == layer.id) {
                                l.enabled = layer.enabled;
                                if (l.enabled == false) {
                                    layer.data = JSON;
                                }
                            }
                        });
                    });
                }
            };
            HeatmapSource.prototype.getRequiredLayers = function (layer) {
                var _this = this;
                var requiredLayers = [];
                if (layer.heatmapSettings && layer.heatmapSettings.referenceList) {
                    layer.heatmapSettings.referenceList.forEach(function (ref) {
                        _this.service.project.groups.forEach(function (group) {
                            group.layers.forEach(function (l) {
                                if (l.reference == ref) {
                                    requiredLayers.push(l);
                                }
                            });
                        });
                    });
                }
                return requiredLayers;
            };
            HeatmapSource.prototype.getFeatureTypes = function (layer) {
                var featureTypes = [];
                layer.heatmapItems.forEach(function (hi) {
                    featureTypes.push(hi.featureType.name);
                });
                return featureTypes;
            };
            HeatmapSource.prototype.generateHeatmap = function (layer) {
                var _this = this;
                console.log('Generating heatmap');
                var geoLayer = L.geoJson([]);
                this.heatmapModel.deserialize(layer);
                this.heatmapModel.id = layer.id;
                var currentZoom = this.service.$mapService.getMap().getZoom();
                if (currentZoom < this.heatmapModel.heatmapSettings.minZoom || currentZoom > this.heatmapModel.heatmapSettings.maxZoom) {
                    return;
                }
                else {
                    this.heatmapModel.updateWeights();
                    this.heatmapModel.calculate(this.service, this.service.$mapService, geoLayer);
                    var time = new Date().getTime();
                    layer.data = geoLayer.toGeoJSON();
                }
                if ((layer.data) && (layer.data).features) {
                    (layer.data).features.forEach(function (f) {
                        _this.service.initFeature(f, layer, false, false);
                        _this.service.activeMapRenderer.addFeature(f);
                    });
                    // Set default style for the heatmap:
                    if ((layer.data).features[0]) {
                        var calloutProp = new FeatureProps.CallOutProperty("totalIntensity", "0", "totalIntensity", true, true, (layer.data).features[0], false, false);
                        var propinfo = new Services.PropertyInfo();
                        // Tweak the group style info to keep constant min/max color values on panning and zooming.
                        propinfo.count = (layer.data).features.length;
                        propinfo.max = 1;
                        propinfo.min = -1;
                        //propinfo.sdMax = propinfo.max;
                        //propinfo.sdMin = propinfo.min;
                        propinfo.mean = 0;
                        propinfo.varience = 0.67;
                        propinfo.sd = Math.sqrt(propinfo.varience);
                        this.service.setStyle(calloutProp, false, propinfo); // Set the style
                    }
                }
                var time2 = new Date().getTime();
                console.log('Init and style features in ' + (time2 - time).toFixed(1) + ' ms');
            };
            return HeatmapSource;
        })();
        Services.HeatmapSource = HeatmapSource;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        'use strict';
        var HierarchySource = (function () {
            function HierarchySource(service, $http) {
                this.service = service;
                this.title = "hierarchy";
                this.requiresLayer = true;
                this.$http = $http;
            }
            HierarchySource.prototype.refreshLayer = function (layer) {
                this.service.removeLayer(layer);
                this.service.addLayer(layer);
            };
            HierarchySource.prototype.addLayer = function (layer, callback) {
                this.baseAddLayer(layer, callback);
            };
            HierarchySource.prototype.fitMap = function (layer) {
                var b = csComp.Helpers.GeoExtensions.getBoundingBox(this.layer.data);
                this.service.$messageBusService.publish("map", "setextent", b);
            };
            HierarchySource.prototype.layerMenuOptions = function (layer) {
                var _this = this;
                return [
                    ["Fit map", (function ($itemScope) { return _this.fitMap(layer); })],
                    null,
                    ['Refresh', (function ($itemScope) { return _this.refreshLayer(layer); })]
                ];
            };
            HierarchySource.prototype.getRequiredLayers = function (layer) {
                var _this = this;
                var requiredLayers = [];
                if (layer.hierarchySettings && layer.hierarchySettings.referenceList) {
                    layer.hierarchySettings.referenceList.forEach(function (ref) {
                        _this.service.project.groups.forEach(function (group) {
                            group.layers.forEach(function (l) {
                                if (l.reference == ref) {
                                    requiredLayers.push(l);
                                }
                            });
                        });
                    });
                }
                return requiredLayers;
            };
            HierarchySource.prototype.baseAddLayer = function (layer, callback) {
                var _this = this;
                this.layer = layer;
                async.series([
                    function (cb) {
                        layer.renderType = "geojson";
                        // Open a layer URL
                        layer.isLoading = true;
                        // get data
                        _this.$http.get(layer.url)
                            .success(function (data) {
                            layer.count = 0;
                            layer.isLoading = false;
                            // if this is a topojson layer, convert to geojson first
                            if (layer.type.toLowerCase() === 'topojson') {
                                data = csComp.Helpers.GeoExtensions.convertTopoToGeoJson(data);
                            }
                            // add featuretypes to global featuretype list
                            if (data.featureTypes)
                                for (var featureTypeName in data.featureTypes) {
                                    if (!data.featureTypes.hasOwnProperty(featureTypeName))
                                        continue;
                                    var featureType = data.featureTypes[featureTypeName];
                                    // give it a unique name
                                    featureTypeName = layer.id + '_' + featureTypeName;
                                    _this.service._featureTypes[featureTypeName] = featureType;
                                }
                            if (data.timestamps)
                                layer.timestamps = data.timestamps;
                            // store raw result in layer
                            layer.data = data;
                            if (layer.data.geometries && !layer.data.features) {
                                layer.data.features = layer.data.geometries;
                            }
                            layer.data.features.forEach(function (f) {
                                _this.service.initFeature(f, layer, false, false);
                            });
                            _this.service.$messageBusService.publish("timeline", "updateFeatures");
                            cb(null, null);
                        })
                            .error(function () {
                            layer.count = 0;
                            layer.isLoading = false;
                            _this.service.$messageBusService.notify('ERROR loading ' + layer.title, '\nwhile loading: ' + layer.url);
                            _this.service.$messageBusService.publish('layer', 'error', layer);
                            cb(null, null);
                        });
                    },
                    // Callback
                    // Callback
                    function () {
                        callback(layer);
                    }
                ]);
            };
            HierarchySource.prototype.removeLayer = function (layer) {
                //alert('remove layer');
            };
            return HierarchySource;
        })();
        Services.HierarchySource = HierarchySource;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var KmlDataSource = (function (_super) {
            __extends(KmlDataSource, _super);
            function KmlDataSource(service, $http) {
                _super.call(this, service, $http);
                this.service = service;
                this.title = "kml";
            }
            KmlDataSource.prototype.get = function (x, y) { return x.getElementsByTagName(y); };
            KmlDataSource.prototype.attr = function (x, y) { return x.getAttribute(y); };
            KmlDataSource.prototype.addLayer = function (layer, callback) {
                var _this = this;
                this.layer = layer;
                layer.renderType = "geojson";
                // Open a layer URL
                layer.isLoading = true;
                // get data
                $.ajax(layer.url)
                    .done(function (xml) {
                    layer.count = 0;
                    layer.isLoading = false;
                    switch (layer.type.toLowerCase()) {
                        case "kml":
                            _this.convertKmlToGeoJSON(layer, xml);
                            break;
                        case "gpx":
                            _this.convertGpxToGeoJSON(layer, xml);
                            break;
                    }
                    callback(layer);
                })
                    .fail(function (error) {
                    layer.isLoading = false;
                    _this.service.$messageBusService.notify('ERROR loading ' + layer.title, error);
                    _this.service.$messageBusService.publish('layer', 'error', layer);
                    callback(layer);
                });
            };
            KmlDataSource.prototype.convertGpxToGeoJSON = function (layer, gpx) {
                var data = toGeoJSON.gpx(gpx);
                this.initLayer(data, layer);
            };
            KmlDataSource.prototype.convertKmlToGeoJSON = function (layer, kml) {
                var _this = this;
                // Convert kml to geojson
                var data = toGeoJSON.kml(kml);
                // Extract style information: first, get all styles
                var styleIndex = {}, styles = this.get(kml, 'Style'), styleMaps = this.get(kml, 'StyleMap');
                for (var k = 0; k < styles.length; k++) {
                    styleIndex['#' + this.attr(styles[k], 'id')] = styles[k];
                }
                // Next, get all stylemaps (and link the normal version to its style)
                for (var k = 0; k < styleMaps.length; k++) {
                    var styleMap = styleMaps[k];
                    var pairs = this.get(styleMap, 'Pair');
                    if (!pairs)
                        continue;
                    for (var i = 0; i < pairs.length; i++) {
                        var p = pairs[i];
                        var key = this.get(p, 'key');
                        if (!key || key.length === 0 || key[0].childNodes[0].nodeValue !== 'normal')
                            continue;
                        var styleNames = this.get(p, 'styleUrl');
                        if (styleNames && styleNames.length > 0) {
                            var styleMapName = '#' + this.attr(styleMap, 'id');
                            var styleName = styleNames[0].childNodes[0].nodeValue;
                            styleIndex[styleMapName] = styleIndex[styleName];
                        }
                        break;
                    }
                }
                // Create the style and add it to the service._featureTypes.
                data.features.forEach(function (f) {
                    if (!f.properties.hasOwnProperty('styleUrl'))
                        return;
                    var styleUrl = f.properties['styleUrl'], styleName = layer.typeUrl + styleUrl;
                    // Strip the # from the style name and copy it to the featureTypeId
                    f.properties['featureTypeId'] = styleUrl.substring(1);
                    // Remove the styleUrl and styleHash
                    delete f.properties['styleUrl'];
                    delete f.properties['styleHash'];
                    if (_this.service._featureTypes.hasOwnProperty(styleName))
                        return;
                    var style = styleIndex[styleUrl];
                    _this.service._featureTypes[styleName] = {
                        name: styleName,
                        showAllProperties: false,
                        style: {
                            fillColor: _this.getFillColor(style),
                            strokeColor: _this.getLineColor(style),
                            strokeWidth: _this.getLineWidth(style),
                            stroke: true,
                            iconUri: _this.getIcon(layer, style)
                        }
                    };
                    //console.log(toGeoJSON.xml2str(styleIndex[f.properties['featureTypeId']]));
                });
                this.initLayer(data, layer);
            };
            KmlDataSource.prototype.getIcon = function (layer, style) {
                try {
                    var url = style.getElementsByTagName('href')[0].childNodes[0].nodeValue;
                    return (url.match(/^http/i))
                        ? url
                        : layer.url.substr(0, layer.url.lastIndexOf('/') + 1) + url;
                }
                catch (error) {
                    return '';
                }
            };
            KmlDataSource.prototype.getLineColor = function (style) {
                try {
                    return '#' + style
                        .getElementsByTagName('LineStyle')[0]
                        .getElementsByTagName('color')[0]
                        .childNodes[0].nodeValue;
                }
                catch (error) {
                    return '#000000';
                }
            };
            KmlDataSource.prototype.getLineWidth = function (style) {
                try {
                    return +style
                        .getElementsByTagName('LineStyle')[0]
                        .getElementsByTagName('width')[0]
                        .childNodes[0].nodeValue;
                }
                catch (error) {
                    return 1;
                }
            };
            KmlDataSource.prototype.getFillColor = function (style) {
                try {
                    return '#' + style
                        .getElementsByTagName('PolyStyle')[0]
                        .getElementsByTagName('color')[0]
                        .childNodes[0].nodeValue;
                }
                catch (error) {
                    return '#ff0000';
                }
            };
            return KmlDataSource;
        })(csComp.Services.GeoJsonSource);
        Services.KmlDataSource = KmlDataSource;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

/* Terminator.js -- Overlay day/night region on a Leaflet map
 * Source: https://github.com/joergdietrich/Leaflet.Terminator/blob/master/L.Terminator.js
 * See also: http://joergdietrich.github.io/Leaflet.Terminator/
 http://www.lizard-tail.com/isana/lab/astro_calc/terminator.html,
 http://stackoverflow.com/questions/7100718/calculating-an-overlay-of-day-night-for-google-maps,
 https://github.com/rossengeorgiev/nite-overlay,
 http://mathematica.stackexchange.com/questions/3326/composition-how-to-make-a-day-and-night-world-map
*/
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
L.Terminator = L.Polygon.extend({
    options: {
        color: '#00',
        opacity: 0.5,
        fillColor: '#00',
        fillOpacity: 0.5,
        resolution: 2,
        showNight: true
    },
    initialize: function (options) {
        this.version = '0.1.0';
        this._R2D = 180 / Math.PI;
        this._D2R = Math.PI / 180;
        L.Util.setOptions(this, options);
        var latLng = this._compute(this.options.showNight, this.options.time || null);
        this.setLatLngs(latLng);
    },
    setTime: function (date) {
        this.options.time = date;
        var latLng = this._compute(this.options.showNight, date || null);
        this.setLatLngs(latLng);
    },
    _sunEclipticPosition: function (julianDay) {
        /* Compute the position of the Sun in ecliptic coordinates at
           julianDay.  Following
           http://en.wikipedia.org/wiki/Position_of_the_Sun */
        // Days since start of J2000.0
        var n = julianDay - 2451545.0;
        // mean longitude of the Sun
        var L = 280.460 + 0.9856474 * n;
        L %= 360;
        // mean anomaly of the Sun
        var g = 357.528 + 0.9856003 * n;
        g %= 360;
        // ecliptic longitude of Sun
        var lambda = L + 1.915 * Math.sin(g * this._D2R) +
            0.02 * Math.sin(2 * g * this._D2R);
        // distance from Sun in AU
        var R = 1.00014 - 0.01671 * Math.cos(g * this._D2R) -
            0.0014 * Math.cos(2 * g * this._D2R);
        return { "lambda": lambda, "R": R };
    },
    _eclipticObliquity: function (julianDay) {
        // Following the short term expression in
        // http://en.wikipedia.org/wiki/Axial_tilt#Obliquity_of_the_ecliptic_.28Earth.27s_axial_tilt.29
        var n = julianDay - 2451545.0;
        // Julian centuries since J2000.0
        var T = n / 36525;
        var epsilon = 23.43929111 -
            T * (46.836769 / 3600
                - T * (0.0001831 / 3600
                    + T * (0.00200340 / 3600
                        - T * (0.576e-6 / 3600
                            - T * 4.34e-8 / 3600))));
        return epsilon;
    },
    _sunEquatorialPosition: function (sunEclLng, eclObliq) {
        /* Compute the Sun's equatorial position from its ecliptic
         * position. Inputs are expected in degrees. Outputs are in
         * degrees as well. */
        var alpha = Math.atan(Math.cos(eclObliq * this._D2R)
            * Math.tan(sunEclLng * this._D2R)) * this._R2D;
        var delta = Math.asin(Math.sin(eclObliq * this._D2R)
            * Math.sin(sunEclLng * this._D2R)) * this._R2D;
        var lQuadrant = Math.floor(sunEclLng / 90) * 90;
        var raQuadrant = Math.floor(alpha / 90) * 90;
        alpha = alpha + (lQuadrant - raQuadrant);
        return { "alpha": alpha, "delta": delta };
    },
    _hourAngle: function (lng, sunPos, gst) {
        /* Compute the hour angle of the sun for a longitude on
         * Earth. Return the hour angle in degrees. */
        var lst = gst + lng / 15;
        return lst * 15 - sunPos.alpha;
    },
    _latitude: function (ha, sunPos) {
        /* For a given hour angle and sun position, compute the
         * latitude of the terminator in degrees. */
        var lat = Math.atan(-Math.cos(ha * this._D2R) /
            Math.tan(sunPos.delta * this._D2R)) * this._R2D;
        return lat;
    },
    _compute: function (showNight, time) {
        if (time == null)
            var today = new Date();
        else
            var today = new Date(time);
        var julianDay = today.getJulian();
        var gst = today.getGMST();
        var latLng = [];
        var ha, lat;
        var sunEclPos = this._sunEclipticPosition(julianDay);
        var eclObliq = this._eclipticObliquity(julianDay);
        var sunEqPos = this._sunEquatorialPosition(sunEclPos.lambda, eclObliq);
        for (var i = 0; i <= 720 * this.options.resolution; i++) {
            var lng = -360 + i / this.options.resolution;
            ha = this._hourAngle(lng, sunEqPos, gst);
            lat = this._latitude(ha, sunEqPos);
            latLng[i + 1] = [lat, lng];
        }
        if (showNight) {
            if (sunEqPos.delta < 0) {
                latLng[0] = [90, -360];
                latLng[latLng.length] = [90, 360];
            }
            else {
                latLng[0] = [-90, -360];
                latLng[latLng.length] = [-90, 360];
            }
        }
        else {
            if (sunEqPos.delta < 0) {
                latLng[0] = [-90, -360];
                latLng[latLng.length] = [-90, 360];
            }
            else {
                latLng[0] = [90, -360];
                latLng[latLng.length] = [90, 360];
            }
        }
        return latLng;
    }
});
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        'use strict';
        var NightDayDataSource = (function (_super) {
            __extends(NightDayDataSource, _super);
            function NightDayDataSource(service, $http) {
                _super.call(this, service, $http);
                this.service = service;
                this.title = "Day Night regions on the Earth";
            }
            NightDayDataSource.prototype.addLayer = function (layer, callback) {
                var _this = this;
                this.layer = layer;
                layer.isLoading = true;
                layer.count = 0;
                var showNight = true;
                var defaultValue = 0;
                if (typeof layer.dataSourceParameters !== 'undefined') {
                    var gridParams = layer.dataSourceParameters;
                    if (typeof gridParams.showNight !== 'undefined')
                        showNight = gridParams.showNight;
                    if (typeof gridParams.value !== 'undefined')
                        defaultValue = gridParams.value;
                }
                var terminator = new L.Terminator({ "showNight": showNight });
                var geojson = terminator.toGeoJSON();
                if (showNight) {
                    geojson.properties["Name"] = "Night";
                    geojson.properties["night_intensity"] = defaultValue;
                }
                else {
                    geojson.properties["Name"] = "Day";
                    geojson.properties["day_intensity"] = defaultValue;
                }
                var features = [];
                features.push({
                    type: "Feature",
                    geometry: geojson.geometry,
                    properties: geojson.properties
                });
                layer.data = csComp.Helpers.GeoExtensions.createFeatureCollection(features);
                if (layer.data.geometries && !layer.data.features) {
                    layer.data.features = layer.data.geometries;
                }
                layer.data.features.forEach(function (f) {
                    _this.service.initFeature(f, layer, false, false);
                });
                layer.isLoading = false;
                callback(layer);
            };
            return NightDayDataSource;
        })(csComp.Services.GeoJsonSource);
        Services.NightDayDataSource = NightDayDataSource;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var RssDataSource = (function (_super) {
            __extends(RssDataSource, _super);
            function RssDataSource(service, $http) {
                _super.call(this, service, $http);
                this.service = service;
                this.title = "RSS datasource";
            }
            RssDataSource.prototype.addLayer = function (layer, callback) {
                var _this = this;
                this.layer = layer;
                layer.type = 'geojson';
                // Open a layer URL
                layer.isLoading = true;
                layer.count = 0;
                this.$http({
                    url: '/api/rss',
                    method: "GET",
                    params: { url: layer.url }
                }).success(function (data) {
                    layer.data = data; //csComp.Helpers.GeoExtensions.createFeatureCollection(features);
                    if (layer.data.geometries && !layer.data.features) {
                        layer.data.features = layer.data.geometries;
                    }
                    layer.data.features.forEach(function (f) {
                        _this.service.initFeature(f, layer, false, false);
                    });
                    _this.service.$messageBusService.publish("timeline", "updateFeatures");
                    layer.isLoading = false;
                    callback(layer);
                })
                    .error(function () {
                    console.log('RssDataSource called $HTTP with errors...');
                });
            };
            return RssDataSource;
        })(csComp.Services.GeoJsonSource);
        Services.RssDataSource = RssDataSource;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        'use strict';
        var TileLayerSource = (function () {
            function TileLayerSource(service) {
                this.service = service;
                this.title = "tilelayer";
                //service : LayerService;
                this.requiresLayer = false;
                this.prevDateTimes = {};
            }
            TileLayerSource.prototype.refreshLayer = function (layer) {
                //console.log('refreshing');
                if (layer.mapLayer.getLayers().length > 0) {
                    var l = layer.mapLayer.getLayers()[0];
                    //console.log("layer ID: " + layer.id);
                    var u = layer.url;
                    if (layer.timeDependent) {
                        // convert epoch to time string parameter
                        var ft = this.service.project.timeLine.focus;
                        if (layer.timeResolution) {
                            var tr = layer.timeResolution;
                            ft = Math.floor(ft / tr) * tr;
                        }
                        ;
                        var d = new Date(0);
                        d.setUTCSeconds(ft / 1000);
                        //d.setFullYear(2011); // so the current year becomes 2011. For easier testing.
                        // this is for the Env4U project
                        var sDate = d.yyyymmdd();
                        var hrs = d.getHours();
                        var mins = d.getMinutes();
                        var secs = d.getSeconds();
                        var sDateTime = sDate + csComp.Utils.twoDigitStr(hrs) +
                            csComp.Utils.twoDigitStr(mins) + csComp.Utils.twoDigitStr(secs);
                        //console.log("DateTime: " + sDateTime);
                        if (sDateTime === this.prevDateTimes[layer.id]) {
                            //console.log("Same time stamp. No refresh");
                            return;
                        }
                        this.prevDateTimes[layer.id] = sDateTime;
                        u += "&time=" + sDateTime;
                    }
                    else if (layer.disableCache) {
                        // check if we need to create a unique url to force a refresh
                        layer.cacheKey = new Date().getTime().toString();
                        u += "&cache=" + layer.cacheKey;
                    }
                    l.setUrl(u);
                }
            };
            TileLayerSource.prototype.layerMenuOptions = function (layer) {
                var _this = this;
                return [
                    ['Refresh', (function ($itemScope) { return _this.refreshLayer(layer); })]
                ];
            };
            TileLayerSource.prototype.addLayer = function (layer, callback) {
                layer.renderType = "tilelayer";
                callback(layer);
                //this.$rootScope.$apply();
            };
            TileLayerSource.prototype.removeLayer = function (layer) {
            };
            return TileLayerSource;
        })();
        Services.TileLayerSource = TileLayerSource;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        'use strict';
        var WmsSource = (function () {
            //service : LayerService;
            function WmsSource(service) {
                this.service = service;
                this.title = "wms";
                this.requiresLayer = false;
            }
            WmsSource.prototype.refreshLayer = function (layer) {
            };
            WmsSource.prototype.layerMenuOptions = function (layer) {
                return null;
            };
            WmsSource.prototype.addLayer = function (layer, callback) {
                var wms = L.tileLayer.wms(layer.url, {
                    layers: layer.wmsLayers,
                    opacity: layer.opacity / 100,
                    format: 'image/png',
                    transparent: true,
                    attribution: layer.description
                });
                layer.renderType = "wms";
                callback(layer);
                //this.$rootScope.$apply();
            };
            WmsSource.prototype.removeLayer = function (layer) {
            };
            return WmsSource;
        })();
        Services.WmsSource = WmsSource;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

/*
 Generic  Canvas Overlay for leaflet,
 Stanislav Sumbera, April , 2014

 - added userDrawFunc that is called when Canvas need to be redrawn
 - added few useful params for userDrawFunc callback
  - fixed resize map bug
  inspired & portions taken from  :   https://github.com/Leaflet/Leaflet.heat

*/
var L;
(function (L) {
    var CanvasOverlay = L.Class.extend({
        initialize: function (userDrawFunc, layer, options) {
            this._layer = layer,
                this._userDrawFunc = userDrawFunc;
            L.Util.setOptions(this, options);
        },
        drawing: function (userDrawFunc) {
            this._userDrawFunc = userDrawFunc;
            return this;
        },
        params: function (options) {
            L.Util.setOptions(this, options);
            return this;
        },
        canvas: function () {
            return this._canvas;
        },
        redraw: function () {
            if (!this._frame) {
                this._frame = L.Util.requestAnimFrame(this._redraw, this);
            }
            return this;
        },
        onAdd: function (map) {
            var _this = this;
            this._map = map;
            this._canvas = L.DomUtil.create('canvas', 'leaflet-overlay-layer');
            var size = this._map.getSize();
            this._canvas.width = size.x;
            this._canvas.height = size.y;
            this._context = this._canvas.getContext("2d");
            this._popup = null;
            this.onMouseMoveDelay = _.debounce(function (evt) {
                var pos = _this._getCanvasPos();
                var rgb = _this._context.getImageData(evt.x - pos.left, evt.y - pos.top, 1, 1).data;
                // only show tooltip when a colored cell is located at the mouse cursor position
                if ((rgb[0] + rgb[1] + rgb[2]) > 0) {
                    var latLng = _this._map.containerPointToLatLng(new L.Point(evt.x - pos.left, evt.y - pos.top));
                    var i = Math.floor((latLng.lat - _this.options.topLeftLat) / _this.options.deltaLat);
                    var j = Math.floor((latLng.lng - _this.options.topLeftLon) / _this.options.deltaLon);
                    var value = '';
                    if (0 <= i && i < _this.options.data.length &&
                        0 <= j && j < _this.options.data[0].length) {
                        value = String.format("{0:0.00}", _this.options.data[i][j]);
                    }
                    (_this._layer.dataSourceParameters.legendStringFormat) ? value = String.format(_this._layer.dataSourceParameters.legendStringFormat, value) : null;
                    var content = '<table><td>' + value + '</td></tr>' + '</table>';
                    if (_this._popup != null) {
                        _this._popup.setLatLng(_this._map.containerPointToLatLng(new L.Point(evt.x, evt.y))).setContent(content);
                    }
                    else {
                        _this._popup = L.popup({
                            offset: new L.Point(-25, -15),
                            closeOnClick: true,
                            autoPan: false,
                            className: 'featureTooltip'
                        }).setLatLng(_this._map.containerPointToLatLng(new L.Point(evt.x, evt.y))).setContent(content).openOn(_this._map);
                    }
                }
                else {
                    _this._map.closePopup(_this._popup);
                    _this._popup = null;
                }
                //console.log('mousemoved ' + evt.x + ', ' + evt.y + ',  color: R' + rgb[0] + ' G' + rgb[1] + ' B' + rgb[2]);
            }, 250);
            this._canvas.addEventListener('mousemove', this.onMouseMoveDelay);
            var animated = this._map.options.zoomAnimation && L.Browser.any3d;
            L.DomUtil.addClass(this._canvas, 'leaflet-zoom-' + (animated ? 'animated' : 'hide'));
            map._panes.overlayPane.appendChild(this._canvas);
            map.on('moveend', this._reset, this);
            map.on('resize', this._resize, this);
            if (map.options.zoomAnimation && L.Browser.any3d) {
                map.on('zoomanim', this._animateZoom, this);
            }
            this._reset();
        },
        onRemove: function (map) {
            map.getPanes().overlayPane.removeChild(this._canvas);
            map.off('moveend', this._reset, this);
            map.off('resize', this._resize, this);
            this._canvas.removeEventListener('mousemove', this.onMouseMoveDelay);
            map.closePopup(this._popup);
            this._popup = null;
            if (map.options.zoomAnimation) {
                map.off('zoomanim', this._animateZoom, this);
            }
            this._canvas = null;
        },
        addTo: function (map) {
            map.addLayer(this);
            return this;
        },
        _getCanvasPos: function () {
            var obj = this._canvas;
            var top = 0;
            var left = 0;
            while (obj && obj.tagName != "BODY") {
                top += obj.offsetTop;
                left += obj.offsetLeft;
                obj = obj.offsetParent;
            }
            return {
                top: top,
                left: left
            };
        },
        _resize: function (resizeEvent) {
            this._canvas.width = resizeEvent.newSize.x;
            this._canvas.height = resizeEvent.newSize.y;
        },
        _reset: function () {
            var topLeft = this._map.containerPointToLayerPoint([0, 0]);
            L.DomUtil.setPosition(this._canvas, topLeft);
            this._redraw();
        },
        _redraw: function () {
            var size = this._map.getSize();
            var bounds = this._map.getBounds();
            var zoomScale = (size.x * 180) / (20037508.34 * (bounds.getEast() - bounds.getWest())); // resolution = 1/zoomScale
            var zoom = this._map.getZoom();
            // console.time('process');
            if (this._userDrawFunc) {
                this._userDrawFunc(this, this._layer, {
                    canvas: this._canvas,
                    bounds: bounds,
                    size: size,
                    zoomScale: zoomScale,
                    zoom: zoom,
                    options: this.options
                });
            }
            // console.timeEnd('process');
            this._frame = null;
        },
        _animateZoom: function (e) {
            var scale = this._map.getZoomScale(e.zoom), offset = this._map._getCenterOffset(e.center)._multiplyBy(-scale).subtract(this._map._getMapPanePos());
            this._canvas.style[L.DomUtil.TRANSFORM] = L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ')';
        }
    });
    function canvasOverlay(userDrawFunc, layer, options) {
        return new CanvasOverlay(userDrawFunc, layer, options);
    }
    L.canvasOverlay = canvasOverlay;
    ;
})(L || (L = {}));

var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var GeojsonRenderer = (function () {
            function GeojsonRenderer() {
            }
            GeojsonRenderer.render = function (service, layer, mapRenderer) {
                layer.mapLayer = new L.LayerGroup();
                service.map.map.addLayer(layer.mapLayer);
                if (!layer.data || !layer.data.features)
                    return;
                layer.data.features.forEach(function (f) {
                    var marker = mapRenderer.addFeature(f);
                    if (marker)
                        layer.group.markers[f.id] = marker;
                });
            };
            GeojsonRenderer.remove = function (service, layer) {
                var g = layer.group;
                //m = layer.group.vectors;
                if (g.clustering) {
                    var m = g.cluster;
                    service.project.features.forEach(function (feature) {
                        if (feature.layerId === layer.id) {
                            try {
                                m.removeLayer(layer.group.markers[feature.id]);
                                delete layer.group.markers[feature.id];
                            }
                            catch (error) { }
                        }
                    });
                }
                else {
                    service.project.features.forEach(function (feature) {
                        if (feature.layerId === layer.id && layer.group.markers.hasOwnProperty(feature.id)) {
                            delete layer.group.markers[feature.id];
                        }
                    });
                    if (service.map.map && layer.mapLayer) {
                        try {
                            service.map.map.removeLayer(layer.mapLayer);
                        }
                        catch (error) { }
                    }
                }
            };
            return GeojsonRenderer;
        })();
        Services.GeojsonRenderer = GeojsonRenderer;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var GridLayerRenderer = (function () {
            function GridLayerRenderer() {
            }
            GridLayerRenderer.render = function (service, layer) {
                var gridParams = layer.dataSourceParameters;
                var legend = [];
                var levels;
                if (typeof gridParams.contourLevels === 'number') {
                    levels = [];
                    var nrLevels = (gridParams.contourLevels);
                    var dl = (gridParams.maxThreshold - gridParams.minThreshold) / nrLevels;
                    for (var l = gridParams.minThreshold + dl / 2; l < gridParams.maxThreshold; l += dl)
                        levels.push(Math.round(l * 10) / 10); // round to nearest decimal.
                }
                else {
                    levels = gridParams.contourLevels;
                }
                // Create a new groupstyle. If no legend is provided, this style can be used to change the colors used to draw the grid.
                // If a legend is provided, that will be used as activelegend.
                var gs = new Services.GroupStyle(service.$translate);
                gs.id = csComp.Helpers.getGuid();
                gs.title = (gridParams.legendDescription) ? gridParams.legendDescription : layer.title;
                gs.meta = null;
                gs.visualAspect = 'fillColor';
                gs.availableAspects = ['fillColor'];
                gs.info = { min: 0, max: 0, count: 0, mean: 0, varience: 0, sd: 0 };
                gs.fixedColorRange = true;
                gs.enabled = true;
                gs.group = layer.group;
                if (!gridParams.legend) {
                    gs.property = 'gridlayer';
                    gs.canSelectColor = true;
                    gs.colors = [(gridParams.minColor) ? gridParams.minColor : '#00fbff', (gridParams.maxColor) ? gridParams.maxColor : '#0400ff'];
                    gs.activeLegend = {
                        legendKind: 'interpolated',
                        description: gs.title,
                        visualAspect: 'fillColor',
                        legendEntries: []
                    };
                }
                else {
                    gs.property = '';
                    gs.canSelectColor = false;
                    gs.colors = ['#ffffff', '#000000'];
                    gs.activeLegend = gridParams.legend;
                    gs.activeLegend.legendEntries.forEach(function (le) {
                        legend.push({ val: le.value, color: le.color });
                    });
                }
                service.saveStyle(layer.group, gs);
                var overlay = L.canvasOverlay(GridLayerRenderer.drawFunction, layer, {
                    data: layer.data,
                    noDataValue: gridParams.noDataValue,
                    topLeftLat: gridParams.startLat,
                    topLeftLon: gridParams.startLon,
                    deltaLat: gridParams.deltaLat,
                    deltaLon: gridParams.deltaLon,
                    min: gridParams.minThreshold,
                    max: gridParams.maxThreshold,
                    minColor: gs.colors[0],
                    maxColor: gs.colors[1],
                    areColorsUpdated: false,
                    levels: levels,
                    legend: legend,
                    opacity: (layer.opacity) ? (+layer.opacity) / 100 : 0.3
                });
                layer.mapLayer = new L.LayerGroup();
                service.map.map.addLayer(layer.mapLayer);
                layer.mapLayer.addLayer(overlay);
            };
            GridLayerRenderer.drawFunction = function (overlay, layer, settings) {
                var map = this._map;
                var opt = settings.options, data = opt.data;
                if (!data)
                    return;
                var row = data.length, col = data[0].length, size = settings.size, legend = opt.legend;
                // update the legend when new from- and to-colors are chosen.
                // the complete color range of the legend will be calculated using the hue value of the from and to colors.
                if (legend.length === 0 || opt.areColorsUpdated) {
                    legend = [];
                    if (opt.minColor[0] !== '#')
                        opt.minColor = ColorExt.Utils.colorNameToHex(opt.minColor);
                    if (opt.maxColor[0] !== '#')
                        opt.maxColor = ColorExt.Utils.colorNameToHex(opt.maxColor);
                    var fromHue = ColorExt.Utils.rgbToHue(opt.minColor);
                    var toHue = ColorExt.Utils.rgbToHue(opt.maxColor);
                    for (var i_1 = 0; i_1 < opt.levels.length; i_1++) {
                        var level = opt.levels[i_1];
                        legend.push({ val: level, color: ColorExt.Utils.toColor(level, opt.levels[0], opt.levels[opt.levels.length - 1], fromHue, toHue) });
                    }
                    if (layer.group.styles && layer.group.styles.length > 0) {
                        layer.group.styles[0].activeLegend = {
                            legendKind: 'interpolated',
                            description: layer.group.styles[0].title,
                            visualAspect: 'fillColor',
                            legendEntries: []
                        };
                        legend.forEach(function (i) {
                            var legEntry = { label: String.format(layer.dataSourceParameters['legendStringFormat'] || '{0:00}', i.val), value: i.val, color: i.color };
                            layer.group.styles[0].activeLegend.legendEntries.push(legEntry);
                        });
                    }
                    overlay.options.legend = opt.legend = legend;
                    opt.areColorsUpdated = false;
                }
                var min = opt.min || Number.MIN_VALUE, max = opt.max || Number.MAX_VALUE;
                var topLeft = map.latLngToContainerPoint(new L.LatLng(opt.topLeftLat, opt.topLeftLon)), botRight = map.latLngToContainerPoint(new L.LatLng(opt.topLeftLat + row * opt.deltaLat, opt.topLeftLon + col * opt.deltaLon));
                var startX = topLeft.x, startY = topLeft.y, deltaX = (botRight.x - topLeft.x) / col, botOfFirstRow = map.latLngToContainerPoint(new L.LatLng(opt.topLeftLat + opt.deltaLat, opt.topLeftLon)), deltaY = botOfFirstRow.y - topLeft.y;
                var ctx = settings.canvas.getContext("2d");
                ctx.clearRect(0, 0, size.x, size.y);
                // Check the boundaries
                if (startX > size.x || startY > size.y || botRight.x < 0 || botRight.y < 0) {
                    //console.log('Outside boundary');
                    return;
                }
                var sJ = 0, eI = row, eJ = col;
                if (startX < -deltaX) {
                    sJ = -Math.ceil(startX / deltaX);
                    startX += sJ * deltaX;
                }
                if (botRight.x > size.x) {
                    eJ -= Math.floor((botRight.x - size.x) / deltaX);
                }
                if (botRight.y > size.y && deltaY > 0) {
                    eI -= Math.floor((botRight.y - size.y) / deltaY);
                }
                var noDataValue = opt.noDataValue;
                ctx.globalAlpha = opt.opacity || 0.3;
                console.time('process');
                var y = startY;
                var lat = opt.topLeftLat; // + sI * opt.deltaLat;
                for (var i = 0; i < eI; i++) {
                    lat += opt.deltaLat;
                    var botY = map.latLngToContainerPoint(new L.LatLng(lat, opt.topLeftLon)).y;
                    deltaY = botY - y;
                    if (y <= -deltaY || deltaY === 0) {
                        y = botY;
                        continue;
                    }
                    var x = startX;
                    for (var j = sJ; j < eJ; j++) {
                        var cell = data[i][j];
                        if (cell === noDataValue || cell < min || cell > max) {
                            x += deltaX;
                            continue;
                        }
                        var closest = legend.reduce(function (prev, curr) {
                            return (Math.abs(curr.val - cell) < Math.abs(prev.val - cell) ? curr : prev);
                        });
                        ctx.fillStyle = closest.color;
                        ctx.fillRect(x, y, deltaX, deltaY);
                        x += deltaX;
                    }
                    y = botY;
                }
                console.timeEnd('process');
            };
            return GridLayerRenderer;
        })();
        Services.GridLayerRenderer = GridLayerRenderer;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var HeatmapRenderer = (function () {
            function HeatmapRenderer() {
            }
            HeatmapRenderer.render = function (service, layer, mapRenderer) {
                if (layer.quickRefresh && layer.quickRefresh == true)
                    return; //When only updating style of current heatmap, do not add a new layer.
                var time = new Date().getTime();
                // create leaflet layers
                layer.isLoading = true;
                if (layer.group.clustering) {
                    var markers = L.geoJson(layer.data, {
                        pointToLayer: function (feature, latlng) { return mapRenderer.createFeature(feature); },
                        onEachFeature: function (feature, lay) {
                            //We do not need to init the feature here: already done in style.
                            //this.initFeature(feature, layer);
                            layer.group.markers[feature.id] = lay;
                            lay.on({
                                mouseover: function (a) { return mapRenderer.showFeatureTooltip(a, layer.group); },
                                mouseout: function (s) { return mapRenderer.hideFeatureTooltip(s); }
                            });
                        }
                    });
                    layer.group.cluster.addLayer(markers);
                }
                else {
                    layer.mapLayer = new L.LayerGroup();
                    service.map.map.addLayer(layer.mapLayer);
                    if (layer.data && layer.data.features) {
                        var v = L.geoJson(layer.data, {
                            onEachFeature: function (feature, lay) {
                                //We do not need to init the feature here: already done in style.
                                //this.initFeature(feature, layer);
                                layer.group.markers[feature.id] = lay;
                                lay.on({
                                    mouseover: function (a) { return mapRenderer.showFeatureTooltip(a, layer.group); },
                                    mouseout: function (s) { return mapRenderer.hideFeatureTooltip(s); },
                                    mousemove: function (d) { return mapRenderer.updateFeatureTooltip(d); },
                                    click: function (e) {
                                        mapRenderer.selectFeature(feature);
                                    }
                                });
                            },
                            style: function (f, m) {
                                layer.group.markers[f.id] = m;
                                return f.effectiveStyle;
                            },
                            pointToLayer: function (feature, latlng) { return mapRenderer.createFeature(feature); }
                        });
                    }
                    else {
                        var v = L.geoJson([]);
                    }
                    service.project.features.forEach(function (f) {
                        if (f.layerId !== layer.id)
                            return;
                        var ft = service.getFeatureType(f);
                        f.properties['Name'] = f.properties[ft.style.nameLabel];
                    });
                    layer.mapLayer.addLayer(v);
                    layer.isLoading = false;
                    var time2 = new Date().getTime();
                }
            };
            return HeatmapRenderer;
        })();
        Services.HeatmapRenderer = HeatmapRenderer;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var TileLayerRenderer = (function () {
            function TileLayerRenderer() {
            }
            TileLayerRenderer.render = function (service, layer) {
                var u = layer.url;
                if (layer.timeDependent) {
                    // convert epoch to time string parameter
                    var ft = service.project.timeLine.focus;
                    if (layer.timeResolution) {
                        var tr = layer.timeResolution;
                        ft = Math.floor(ft / tr) * tr;
                    }
                    ;
                    var d = new Date(0);
                    d.setUTCSeconds(ft / 1000);
                    var sDate = d.yyyymmdd();
                    var hrs = d.getHours();
                    var mins = d.getMinutes();
                    var secs = d.getSeconds();
                    var sTime = csComp.Utils.twoDigitStr(hrs) +
                        csComp.Utils.twoDigitStr(mins) + csComp.Utils.twoDigitStr(secs);
                    u += "&time=" + sDate + sTime;
                }
                else if (layer.disableCache) {
                    // check if we need to create a unique url to force a refresh
                    layer.cacheKey = new Date().getTime().toString();
                    u += "&cache=" + layer.cacheKey;
                }
                var tileLayer = L.tileLayer(u, { attribution: layer.description });
                layer.mapLayer = new L.LayerGroup();
                tileLayer.setOpacity(layer.opacity / 100);
                service.map.map.addLayer(layer.mapLayer);
                layer.mapLayer.addLayer(tileLayer);
                tileLayer.on('loading', function (event) {
                    layer.isLoading = true;
                    service.$rootScope.$apply();
                    if (service.$rootScope.$$phase != '$apply' && service.$rootScope.$$phase != '$digest') {
                        service.$rootScope.$apply();
                    }
                });
                tileLayer.on('load', function (event) {
                    layer.isLoading = false;
                    if (service.$rootScope.$$phase != '$apply' && service.$rootScope.$$phase != '$digest') {
                        service.$rootScope.$apply();
                    }
                });
                layer.isLoading = true;
            };
            return TileLayerRenderer;
        })();
        Services.TileLayerRenderer = TileLayerRenderer;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var WmsRenderer = (function () {
            function WmsRenderer() {
            }
            WmsRenderer.render = function (service, layer) {
                var wms = L.tileLayer.wms(layer.url, {
                    layers: layer.wmsLayers,
                    opacity: layer.opacity / 100,
                    format: 'image/png',
                    transparent: true,
                    attribution: layer.description,
                    tiled: true
                });
                layer.mapLayer = new L.LayerGroup();
                service.map.map.addLayer(layer.mapLayer);
                layer.mapLayer.addLayer(wms);
                wms.on('loading', function (event) {
                    layer.isLoading = true;
                    service.$rootScope.$apply();
                    if (service.$rootScope.$$phase != '$apply' && service.$rootScope.$$phase != '$digest') {
                        service.$rootScope.$apply();
                    }
                });
                wms.on('load', function (event) {
                    layer.isLoading = false;
                    if (service.$rootScope.$$phase != '$apply' && service.$rootScope.$$phase != '$digest') {
                        service.$rootScope.$apply();
                    }
                });
                layer.isLoading = true;
            };
            return WmsRenderer;
        })();
        Services.WmsRenderer = WmsRenderer;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var CesiumRenderer = (function () {
            function CesiumRenderer() {
                this.title = "cesium";
                this.features = {};
            }
            CesiumRenderer.prototype.init = function (service) {
                this.service = service;
            };
            CesiumRenderer.prototype.enable = function () {
                var _this = this;
                this.viewer = new Cesium.Viewer('map', {
                    selectionIndicator: false,
                    infoBox: false,
                    scene3DOnly: true,
                    sceneModePicker: false,
                    fullscreenButton: false,
                    homeButton: false,
                    baseLayerPicker: false,
                    animation: false,
                    timeline: false,
                    navigationHelpButton: false
                });
                this.camera = this.viewer.camera;
                this.scene = this.viewer.scene;
                setTimeout(function () {
                    for (var i = 0; i < _this.service.project.features.length; ++i)
                        _this.addFeature(_this.service.project.features[i]);
                }, 0);
                // onclick events
                this.setUpMouseHandlers();
                this.fitBounds(this.service.$mapService.maxBounds);
                this.changeBaseLayer(this.service.$mapService.activeBaseLayer);
            };
            CesiumRenderer.prototype.getLatLon = function (x, y) {
                return { lat: 53, lon: 5 };
            };
            CesiumRenderer.prototype.refreshLayer = function () {
            };
            CesiumRenderer.prototype.getExtent = function () {
                var r = {};
                return r;
            };
            CesiumRenderer.prototype.getZoom = function () {
                // we dont get nearby relations for now
                return 0;
            };
            CesiumRenderer.prototype.fitBounds = function (bounds) {
                var ellipsoid = Cesium.Ellipsoid.WGS84;
                if (bounds) {
                    var west = Cesium.Math.toRadians(bounds.southWest[1]);
                    var south = Cesium.Math.toRadians(bounds.southWest[0]);
                    var east = Cesium.Math.toRadians(bounds.northEast[1]);
                    var north = Cesium.Math.toRadians(bounds.northEast[0]);
                    var extent = new Cesium.Rectangle(west, south, east, north);
                    this.camera.viewRectangle(extent, ellipsoid);
                }
            };
            CesiumRenderer.prototype.setUpMouseHandlers = function () {
                var _this = this;
                var handler = new Cesium.ScreenSpaceEventHandler(this.scene.canvas);
                handler.setInputAction(function (click) {
                    var pickedObject = _this.scene.pick(click.position);
                    if (Cesium.defined(pickedObject) && pickedObject.id !== undefined && pickedObject.id.feature !== undefined) {
                        _this.service.selectFeature(pickedObject.id.feature);
                    }
                }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
                handler.setInputAction(function (movement) {
                    var pickedObject = _this.scene.pick(movement.endPosition);
                    if (Cesium.defined(pickedObject) && pickedObject.id !== undefined && pickedObject.id.feature !== undefined)
                        _this.showFeatureTooltip(pickedObject.id.feature, movement.endPosition);
                    else
                        $(".cesiumPopup").fadeOut('fast').remove();
                }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
            };
            CesiumRenderer.prototype.disable = function () {
                this.viewer.destroy();
            };
            CesiumRenderer.prototype.changeBaseLayer = function (layer) {
                if (layer.cesium_url === undefined)
                    alert('This layer is not cesium compatible');
                else {
                    switch (layer.cesium_maptype.toUpperCase()) {
                        case "ARCGIS":
                            var mapProvider = new Cesium.ArcGisMapServerImageryProvider({
                                url: layer.cesium_url,
                                minimumLevel: layer.minZoom,
                                maximumLevel: layer.maxZoom
                            });
                            break;
                        case "OPENSTREETMAP":
                            var mapProvider = new Cesium.OpenStreetMapImageryProvider({
                                url: layer.cesium_url,
                                minimumLevel: layer.minZoom,
                                maximumLevel: layer.maxZoom
                            });
                            break;
                        case "WEBMAPTILE":
                            var mapProvider = new Cesium.WebMapTileServiceImageryProvider({
                                url: layer.cesium_url,
                                minimumLevel: layer.minZoom,
                                maximumLevel: layer.maxZoom
                            });
                            break;
                        case "TILEMAP":
                            var mapProvider = new Cesium.TileMapServiceImageryProvider({
                                url: layer.cesium_url,
                                minimumLevel: layer.minZoom,
                                maximumLevel: layer.maxZoom
                            });
                            break;
                        default:
                            alert('unknown maptype: ' + layer.cesium_maptype);
                            break;
                    }
                    this.viewer.imageryLayers.addImageryProvider(mapProvider);
                }
            };
            CesiumRenderer.prototype.showFeatureTooltip = function (feature, endPosition) {
                if (this.popupShownFor !== undefined && feature.id == this.popupShownFor.id)
                    return;
                $(".cesiumPopup").fadeOut('fast').remove();
                this.popupShownFor = feature;
                var layer = feature.layer;
                var group = layer.group;
                // var feature = <Feature>layer.feature;
                // add title
                var title = feature.properties["Name"];
                var rowLength = (title) ? title.length : 1;
                var content = '<td colspan=\'3\'>' + title + '</td></tr>';
                // add filter values
                if (group.filters != null && group.filters.length > 0) {
                    group.filters.forEach(function (f) {
                        if (!feature.properties.hasOwnProperty(f.property))
                            return;
                        var value = feature.properties[f.property];
                        if (value) {
                            var valueLength = value.toString().length;
                            if (f.meta != null) {
                                value = csComp.Helpers.convertPropertyInfo(f.meta, value);
                                if (f.meta.type !== 'bbcode')
                                    valueLength = value.toString().length;
                            }
                            rowLength = Math.max(rowLength, valueLength + f.title.length);
                            content += '<tr><td><div class=\'smallFilterIcon\'></td><td>' + f.title + '</td><td>' + value + '</td></tr>';
                        }
                    });
                }
                // add style values, only in case they haven't been added already as filter
                if (group.styles != null && group.styles.length > 0) {
                    group.styles.forEach(function (s) {
                        if (group.filters != null && group.filters.filter(function (f) { return f.property === s.property; }).length === 0 && feature.properties.hasOwnProperty(s.property)) {
                            var value = feature.properties[s.property];
                            var valueLength = value.toString().length;
                            if (s.meta != null) {
                                value = csComp.Helpers.convertPropertyInfo(s.meta, value);
                                if (s.meta.type !== 'bbcode')
                                    valueLength = value.toString().length;
                            }
                            var tl = s.title ? s.title.length : 10;
                            rowLength = Math.max(rowLength, valueLength + tl);
                            content += '<tr><td><div class=\'smallStyleIcon\'></td><td>' + s.title + '</td><td>' + value + '</td></tr>';
                        }
                    });
                }
                var widthInPixels = Math.max(Math.min(rowLength * 7 + 15, 250), 130);
                content = '<table style=\'width:' + widthInPixels + 'px;\'>' + content + '</table>';
                // cesium does not have a popup class like leaflet does, so we create our own div with absolute position
                this.popup = $("<div class='cesiumPopup featureTooltip'></div>").html(content).css({ position: 'absolute', top: endPosition.y - 30, left: endPosition.x - widthInPixels / 2 - 30, width: widthInPixels }).hide().fadeIn('fast');
                $("body").append(this.popup);
            };
            CesiumRenderer.prototype.addLayer = function (layer) {
                var _this = this;
                // console.log(layer);
                var dfd = jQuery.Deferred();
                switch (layer.renderType) {
                    case "geojson":
                        setTimeout(function () {
                            layer.data.features.forEach(function (f) {
                                _this.addFeature(f);
                            });
                            dfd.resolve();
                        }, 0);
                        break;
                    case "wms":
                        var wms_layer = this.viewer.imageryLayers.addImageryProvider(new Cesium.WebMapServiceImageryProvider({
                            url: layer.url,
                            layers: layer.wmsLayers,
                            parameters: {
                                format: 'image/png',
                                transparent: true,
                            }
                        }));
                        wms_layer.id = layer.id;
                        wms_layer.alpha = layer.opacity / 100;
                        dfd.resolve();
                        break;
                    default:
                        alert('unknown layertype: ' + layer.type);
                        dfd.resolve();
                        break;
                }
                return dfd.promise();
            };
            CesiumRenderer.prototype.removeLayer = function (layer) {
                var _this = this;
                var dfd = jQuery.Deferred();
                switch (layer.type.toUpperCase()) {
                    case "GEOJSON":
                    case "DYNAMICGEOJSON":
                    case "TOPOJSON":
                        setTimeout(function () {
                            layer.data.features.forEach(function (f) {
                                _this.removeFeature(f);
                            });
                            dfd.resolve();
                        }, 0);
                        break;
                    case "WMS":
                        this.viewer.imageryLayers._layers.forEach(function (ilayer) {
                            if (ilayer.id == layer.id)
                                _this.viewer.imageryLayers.remove(ilayer);
                        });
                        dfd.resolve();
                        break;
                    default:
                        alert('unknown layertype: ' + layer.type);
                        dfd.resolve();
                        break;
                }
                return dfd.promise();
            };
            CesiumRenderer.prototype.updateMapFilter = function (group) {
                var _this = this;
                var dfd = jQuery.Deferred();
                setTimeout(function () {
                    _this.viewer.entities.values.forEach(function (entity) {
                        var included;
                        if (group.filterResult)
                            included = group.filterResult.filter(function (f) { return f.id === entity.feature.id; }).length > 0;
                        if (included)
                            entity.show = true;
                        else
                            entity.show = false;
                    });
                    dfd.resolve();
                }, 0);
                return dfd.promise();
            };
            CesiumRenderer.prototype.addGroup = function (group) {
                console.log('addGroup called');
            };
            CesiumRenderer.prototype.removeGroup = function (group) {
                console.log('removeGroup called');
            };
            CesiumRenderer.prototype.removeFeature = function (feature) {
                var _this = this;
                //console.log('removeFeature called');
                var toRemove = [];
                this.viewer.entities.values.forEach(function (entity) {
                    if (entity.feature.id === feature.id) {
                        toRemove.push(entity);
                    }
                });
                toRemove.forEach(function (entity) {
                    _this.viewer.entities.remove(entity);
                });
            };
            CesiumRenderer.prototype.removeFeatures = function (features) {
                var _this = this;
                var dfd = jQuery.Deferred();
                setTimeout(function () {
                    var toRemove = [];
                    _this.viewer.entities.values.forEach(function (entity) {
                        features.forEach(function (feature) {
                            if (entity.feature.id === feature.id) {
                                entity.show(false);
                            }
                        });
                    });
                    toRemove.forEach(function (entity) {
                        _this.viewer.entities.remove(entity);
                    });
                    dfd.resolve();
                }, 0);
                return dfd.promise();
            };
            CesiumRenderer.prototype.updateFeature = function (feature) {
                var _this = this;
                this.viewer.entities.values.forEach(function (entity) {
                    if (entity.feature.id === feature.id)
                        _this.updateEntity(entity, feature);
                });
            };
            CesiumRenderer.prototype.updateEntity = function (entity, feature) {
                var height = feature.properties['mediaan_hoogte'] === undefined ? feature.effectiveStyle.height : feature.properties['mediaan_hoogte'];
                if (feature.fType.style.iconUri !== undefined && entity.billboard !== undefined) {
                    entity.billboard.width = feature.effectiveStyle.iconWidth;
                    entity.billboard.height = feature.effectiveStyle.iconHeight;
                }
                switch (feature.geometry.type.toUpperCase()) {
                    case "POINT":
                    case "MULTIPOINT":
                        entity.position = Cesium.Cartesian3.fromDegrees(feature.geometry.coordinates[0], feature.geometry.coordinates[1], feature.geometry.coordinates[2]);
                        entity.point.position = Cesium.Cartesian3.fromDegrees(feature.geometry.coordinates[0], feature.geometry.coordinates[1], feature.geometry.coordinates[2]);
                        entity.point.color = Cesium.Color.fromCssColorString(feature.effectiveStyle.fillColor);
                        entity.point.outlineColor = Cesium.Color.fromCssColorString(feature.effectiveStyle.strokeColor);
                        entity.point.outlineWidth = feature.effectiveStyle.strokeWidth;
                        break;
                    case "POLYGON":
                    case "MULTIPOLYGON":
                        entity.polygon.material = Cesium.Color.fromCssColorString(feature.effectiveStyle.fillColor);
                        entity.polygon.outlineColor = Cesium.Color.fromCssColorString(feature.effectiveStyle.strokeColor);
                        entity.polygon.outlineWidth = feature.effectiveStyle.strokeWidth; // does not do anything on windows webGL: http://stackoverflow.com/questions/25394677/how-do-you-change-the-width-on-an-ellipseoutlinegeometry-in-cesium-map/25405483#25405483
                        entity.polygon.extrudedHeight = height;
                        break;
                    case "LINESTRING":
                    case "MULTILINESTRING":
                        entity.polyline.material = Cesium.Color.fromCssColorString(feature.effectiveStyle.fillColor);
                        entity.polyline.width = feature.effectiveStyle.strokeWidth;
                        break;
                    default:
                        alert('unknown geometry type: ' + feature.geometry.type);
                        break;
                }
            };
            CesiumRenderer.prototype.addFeature = function (feature) {
                var entity = this.createFeature(feature);
            };
            CesiumRenderer.prototype.selectFeature = function (feature) {
                // TODO
                console.log("CesiumRenderer warning: selectFeature is not implemented!");
            };
            CesiumRenderer.prototype.createFeature = function (feature) {
                var entity = this.viewer.entities.getOrCreateEntity(feature.id);
                // link the feature to the entity for CommonSense.selectFeature
                entity.feature = feature;
                if (feature.properties['Name'] !== undefined)
                    entity.name = feature.properties['Name'];
                // override for buildings from Top10NL
                var height = feature.properties['mediaan_hoogte'] === undefined ? feature.effectiveStyle.height : feature.properties['mediaan_hoogte'];
                var pixelSize = 5;
                if (feature.fType.style.iconUri !== undefined) {
                    // a billboard is an icon for a feature
                    entity.billboard = {
                        image: feature.fType.style.iconUri,
                        width: feature.effectiveStyle.iconWidth,
                        height: feature.effectiveStyle.iconHeight
                    };
                    // we draw this point very large because it serves as a background for the billboards
                    pixelSize = 35;
                }
                switch (feature.geometry.type.toUpperCase()) {
                    case "POINT":
                        // if there is no icon, a PointGraphics object is used as a fallback mechanism
                        entity.position = Cesium.Cartesian3.fromDegrees(feature.geometry.coordinates[0], feature.geometry.coordinates[1], feature.geometry.coordinates[2]);
                        entity.point = {
                            pixelSize: pixelSize,
                            position: Cesium.Cartesian3.fromDegrees(feature.geometry.coordinates[0], feature.geometry.coordinates[1], feature.geometry.coordinates[2]),
                            color: Cesium.Color.fromCssColorString(feature.effectiveStyle.fillColor),
                            outlineColor: Cesium.Color.fromCssColorString(feature.effectiveStyle.strokeColor),
                            outlineWidth: feature.effectiveStyle.strokeWidth
                        };
                        break;
                    case "MULTIPOINT":
                        for (var i = 0; i < feature.geometry.coordinates.length; i++) {
                            var entity_multi = new Cesium.Entity();
                            entity_multi.feature = feature;
                            entity_multi.point = {
                                pixelSize: pixelSize,
                                position: Cesium.Cartesian3.fromDegrees(feature.geometry.coordinates[i][0], feature.geometry.coordinates[i][1], feature.geometry.coordinates[i][2]),
                                color: Cesium.Color.fromCssColorString(feature.effectiveStyle.fillColor),
                                outlineColor: Cesium.Color.fromCssColorString(feature.effectiveStyle.strokeColor),
                                outlineWidth: feature.effectiveStyle.strokeWidth
                            };
                            this.viewer.entities.add(entity_multi);
                        }
                        this.viewer.entities.remove(entity);
                        break;
                    case "POLYGON":
                        entity.polygon = new Cesium.PolygonGraphics({
                            hierarchy: this.createPolygon(feature.geometry.coordinates).hierarchy,
                            material: Cesium.Color.fromCssColorString(feature.effectiveStyle.fillColor),
                            outline: true,
                            outlineColor: Cesium.Color.fromCssColorString(feature.effectiveStyle.strokeColor),
                            outlineWidth: feature.effectiveStyle.strokeWidth,
                            extrudedHeight: height,
                            perPositionHeight: true
                        });
                        break;
                    case "MULTIPOLYGON":
                        var polygons = this.createMultiPolygon(feature.geometry.coordinates);
                        for (var i = 0; i < polygons.length; ++i) {
                            var entity_multi = new Cesium.Entity();
                            entity_multi.feature = feature;
                            var polygon = new Cesium.PolygonGraphics({
                                hierarchy: polygons[i].hierarchy,
                                material: Cesium.Color.fromCssColorString(feature.effectiveStyle.fillColor),
                                outline: true,
                                outlineColor: Cesium.Color.fromCssColorString(feature.effectiveStyle.strokeColor),
                                outlineWidth: feature.effectiveStyle.strokeWidth,
                                extrudedHeight: height,
                                perPositionHeight: true
                            });
                            entity_multi.polygon = polygon;
                            this.viewer.entities.add(entity_multi);
                        }
                        this.viewer.entities.remove(entity);
                        break;
                    case "LINESTRING":
                        entity.polyline = new Cesium.PolylineGraphics({
                            positions: this.coordinatesArrayToCartesianArray(feature.geometry.coordinates),
                            material: Cesium.Color.fromCssColorString(feature.effectiveStyle.fillColor),
                            width: feature.effectiveStyle.strokeWidth,
                        });
                        break;
                    case "MULTILINESTRING":
                        for (var i = 0; i < feature.geometry.coordinates.length; i++) {
                            var entity_multi = new Cesium.Entity();
                            entity_multi.feature = feature;
                            entity.polyline = new Cesium.PolylineGraphics({
                                positions: this.coordinatesArrayToCartesianArray(feature.geometry.coordinates[i]),
                                material: Cesium.Color.fromCssColorString(feature.effectiveStyle.fillColor),
                                width: feature.effectiveStyle.strokeWidth,
                            });
                            this.viewer.entities.add(entity_multi);
                        }
                        this.viewer.entities.remove(entity);
                        break;
                    default:
                        alert('unknown geometry type: ' + feature.geometry.type);
                        break;
                }
                // add a 3D model if we have one
                if (feature.properties["FeatureTypeId"] === "3Dmodel") {
                    var modelUri = feature.effectiveStyle.modelUri || feature.properties["modelUri"] || "";
                    var modelScale = feature.effectiveStyle.modelScale || feature.properties["modelScale"] || 1;
                    var modelMinimumPixelSize = feature.effectiveStyle.modelMinimumPixelSize || feature.properties["modelMinimumPixelSize"] || 32;
                    entity.model = new Cesium.ModelGraphics({
                        uri: modelUri,
                        scale: modelScale,
                        minimumPixelSize: modelMinimumPixelSize,
                    });
                    // Hide icon and point when we have a 3D model
                    if (entity.billboard !== undefined)
                        entity.billboard.show = false;
                    if (entity.point !== undefined)
                        entity.point.show = false;
                }
                //account for rotation
                if (feature.properties["Track"] !== undefined) {
                    var headingQuaternion = Cesium.Transforms.headingPitchRollQuaternion(Cesium.Cartesian3.fromDegrees(feature.geometry.coordinates[0], feature.geometry.coordinates[1], feature.geometry.coordinates[2]), Cesium.Math.toRadians(feature.properties["Track"]), 0, 0);
                    entity.orientation = headingQuaternion;
                }
                return entity;
            };
            CesiumRenderer.prototype.createPolygon = function (coordinates) {
                if (coordinates.length === 0 || coordinates[0].length === 0)
                    return;
                var polygon = new Cesium.PolygonGraphics();
                var holes = [];
                for (var i = 1, len = coordinates.length; i < len; i++)
                    holes.push(new Cesium.PolygonHierarchy(this.coordinatesArrayToCartesianArray(coordinates[i])));
                var positions = this.coordinatesArrayToCartesianArray(coordinates[0]);
                polygon.hierarchy = new Cesium.PolygonHierarchy(positions, holes);
                return polygon;
            };
            CesiumRenderer.prototype.createMultiPolygon = function (coordinates) {
                var polygons = [];
                for (var i = 0; i < coordinates.length; i++) {
                    polygons.push(this.createPolygon(coordinates[i]));
                }
                return polygons;
            };
            CesiumRenderer.prototype.coordinatesArrayToCartesianArray = function (coordinates) {
                var positions = new Array(coordinates.length);
                for (var i = 0; i < coordinates.length; i++)
                    positions[i] = this.defaultCrsFunction(coordinates[i]);
                return positions;
            };
            CesiumRenderer.prototype.defaultCrsFunction = function (coordinates) {
                return Cesium.Cartesian3.fromDegrees(coordinates[0], coordinates[1], coordinates[2]);
            };
            return CesiumRenderer;
        })();
        Services.CesiumRenderer = CesiumRenderer;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));

var csComp;
(function (csComp) {
    var Services;
    (function (Services) {
        var LeafletRenderer = (function () {
            function LeafletRenderer() {
                this.title = "leaflet";
                this.cntrlIsPressed = false;
            }
            LeafletRenderer.prototype.init = function (service) {
                var _this = this;
                this.service = service;
                this.$messageBusService = service.$messageBusService;
                $(document).keydown(function (e) {
                    _this.cntrlIsPressed = e.ctrlKey;
                });
                $(document).keyup(function () {
                    _this.cntrlIsPressed = false;
                });
            };
            LeafletRenderer.prototype.enable = function () {
                var _this = this;
                if ($("map").length !== 1)
                    return;
                this.service.$mapService.map = L.map("map", {
                    //var tl  = L.map("mapleft", {
                    zoomControl: false,
                    maxZoom: 19,
                    attributionControl: true
                });
                this.map = this.service.$mapService.map;
                this.service.$mapService.map.on('moveend', function (t, event) {
                    var b = (_this.service.$mapService.map).getBounds();
                    _this.$messageBusService.publish("mapbbox", "update", b.toBBoxString());
                    var boundingBox = { southWest: [b.getSouthWest().lat, b.getSouthWest().lng], northEast: [b.getNorthEast().lat, b.getNorthEast().lng] };
                    _this.service.$mapService.maxBounds = boundingBox;
                });
            };
            LeafletRenderer.prototype.getLatLon = function (x, y) {
                var position = this.map.containerPointToLatLng(new L.Point(x, y));
                return { lat: position.lat, lon: position.lng };
            };
            LeafletRenderer.prototype.getExtent = function () {
                var r = {};
                if (this.map) {
                    var b = this.map.getBounds();
                    var sw = b.getSouthWest();
                    var ne = b.getNorthEast();
                    r.southWest = [sw.lat, sw.lng];
                    r.northEast = [ne.lat, ne.lng];
                }
                return r;
            };
            LeafletRenderer.prototype.fitBounds = function (bounds) {
                var southWest = L.latLng(bounds.southWest[0], bounds.southWest[1]);
                var northEast = L.latLng(bounds.northEast[0], bounds.northEast[1]);
                var lb = L.latLngBounds(southWest, northEast);
                try {
                    this.service.$mapService.map.fitBounds(lb);
                }
                catch (e) { }
            };
            LeafletRenderer.prototype.getZoom = function () {
                return this.service.$mapService.map.getZoom();
            };
            LeafletRenderer.prototype.disable = function () {
                this.service.$mapService.map.remove();
                this.service.$mapService.map = null;
                $("#map").empty();
            };
            LeafletRenderer.prototype.refreshLayer = function () {
            };
            LeafletRenderer.prototype.addGroup = function (group) {
                // for clustering use a cluster layer
                if (group.clustering) {
                    group.cluster = new L.MarkerClusterGroup({
                        maxClusterRadius: function (zoom) { if (zoom > 18) {
                            return 2;
                        }
                        else {
                            return group.maxClusterRadius || 80;
                        } },
                        disableClusteringAtZoom: group.clusterLevel || 0
                    });
                    this.service.map.map.addLayer(group.cluster);
                }
                else {
                    group.vectors = new L.LayerGroup();
                    this.service.map.map.addLayer(group.vectors);
                }
            };
            LeafletRenderer.prototype.removeLayer = function (layer) {
                switch (layer.renderType) {
                    case "geojson":
                        Services.GeojsonRenderer.remove(this.service, layer);
                        break;
                    default:
                        if (this.service.map.map && layer.mapLayer)
                            this.service.map.map.removeLayer(layer.mapLayer);
                        break;
                }
            };
            LeafletRenderer.prototype.changeBaseLayer = function (layerObj) {
                if (layerObj == this.service.$mapService.activeBaseLayer)
                    return;
                if (this.baseLayer)
                    this.service.map.map.removeLayer(this.baseLayer);
                this.baseLayer = this.createBaseLayer(layerObj);
                this.service.map.map.addLayer(this.baseLayer);
                this.service.map.map.setZoom(this.service.map.map.getZoom());
                this.service.map.map.fire('baselayerchange', { layer: this.baseLayer });
            };
            LeafletRenderer.prototype.createBaseLayer = function (layerObj) {
                var options = { noWrap: true };
                options['subtitle'] = layerObj.subtitle;
                options['preview'] = layerObj.preview;
                if (layerObj.subdomains != null)
                    options['subdomains'] = layerObj.subdomains;
                if (layerObj.maxZoom != null)
                    options.maxZoom = layerObj.maxZoom;
                if (layerObj.minZoom != null)
                    options.minZoom = layerObj.minZoom;
                if (layerObj.attribution != null)
                    options.attribution = layerObj.attribution;
                if (layerObj.id != null)
                    options['id'] = layerObj.id;
                var layer = L.tileLayer(layerObj.url, options);
                return layer;
            };
            LeafletRenderer.prototype.getLeafletStyle = function (style) {
                var s = {
                    fillColor: style.fillColor,
                    weight: style.strokeWidth,
                    opacity: style.opacity,
                    fillOpacity: style.fillOpacity
                };
                s["color"] = (typeof style.stroke !== 'undefined' && style.stroke === false)
                    ? style.fillColor
                    : style.strokeColor;
                return s;
            };
            LeafletRenderer.prototype.addLayer = function (layer) {
                switch (layer.renderType) {
                    case "geojson":
                        Services.GeojsonRenderer.render(this.service, layer, this);
                        break;
                    case "tilelayer":
                        Services.TileLayerRenderer.render(this.service, layer);
                        break;
                    case "wms":
                        Services.WmsRenderer.render(this.service, layer);
                        break;
                    case "gridlayer":
                        Services.GridLayerRenderer.render(this.service, layer);
                        break;
                    case "heatmap":
                        Services.HeatmapRenderer.render(this.service, layer, this);
                        break;
                }
            };
            /***
             * Update map markers in cluster after changing filter
             */
            LeafletRenderer.prototype.updateMapFilter = function (group) {
                var _this = this;
                $.each(group.markers, function (key, marker) {
                    var included;
                    if (group.filterResult)
                        included = group.filterResult.filter(function (f) { return f.id === key; }).length > 0;
                    if (group.clustering) {
                        var incluster = group.cluster.hasLayer(marker);
                        if (!included && incluster)
                            group.cluster.removeLayer(marker);
                        if (included && !incluster)
                            group.cluster.addLayer(marker);
                    }
                    else {
                        //var onmap = group.vectors.hasLayer(marker);
                        var onmap = _this.service.map.map.hasLayer(marker);
                        if (!included && onmap)
                            _this.service.map.map.removeLayer(marker);
                        if (included && !onmap)
                            _this.service.map.map.addLayer(marker);
                    }
                });
            };
            LeafletRenderer.prototype.removeGroup = function (group) { };
            LeafletRenderer.prototype.removeFeature = function (feature) {
                var layer = feature.layer;
                switch (layer.renderType) {
                    case "geojson":
                        var g = layer.group;
                        if (g.clustering) {
                            var m = g.cluster;
                            try {
                                m.removeLayer(layer.group.markers[feature.id]);
                                delete layer.group.markers[feature.id];
                            }
                            catch (error) { }
                        }
                        else {
                            if (layer.group.markers.hasOwnProperty(feature.id)) {
                                layer.mapLayer.removeLayer(layer.group.markers[feature.id]);
                                layer.group.vectors.removeLayer(layer.group.markers[feature.id]);
                                delete layer.group.markers[feature.id];
                            }
                        }
                        break;
                }
                // var marker = <L.Marker>feature.layer.group.markers[feature.id];
                // if (marker != null) {
                //     feature.layer.mapLayer.removeLayer(marker);
                //     delete feature.layer.group.markers[feature.id];
                // }
            };
            LeafletRenderer.prototype.updateFeature = function (feature) {
                if (feature.layer.group == null)
                    return;
                var marker = feature.layer.group.markers[feature.id];
                if (marker == null)
                    return;
                if (feature.geometry.type === 'Point') {
                    marker.setIcon(this.getPointIcon(feature));
                    marker.setLatLng(new L.LatLng(feature.geometry.coordinates[1], feature.geometry.coordinates[0]));
                }
                else {
                    marker.setStyle(this.getLeafletStyle(feature.effectiveStyle));
                    if (feature.isSelected && feature.layer && !feature.layer.disableMoveSelectionToFront && feature.layer.group) {
                        if ((feature.layer.group.clustering && feature.layer.group.cluster && feature.layer.group.cluster.hasLayer(marker))
                            || feature.layer.group.markers.hasOwnProperty(marker.feature.id)) {
                            marker.bringToFront();
                        }
                    }
                }
                if (feature.layer.isDynamic) {
                    if (this.canDrag(feature)) {
                        marker.dragging.enable();
                    }
                    else {
                        marker.dragging.disable();
                    }
                    ;
                }
            };
            LeafletRenderer.prototype.selectFeature = function (feature) {
                if (feature.gui.hasOwnProperty("dragged")) {
                    delete feature.gui["dragged"];
                }
                else {
                    this.service.selectFeature(feature, this.cntrlIsPressed);
                }
            };
            LeafletRenderer.prototype.addFeature = function (feature) {
                var _this = this;
                if (feature.geometry != null) {
                    var m = this.createFeature(feature);
                    var l = feature.layer;
                    l.group.markers[feature.id] = m;
                    m.on({
                        mouseover: function (a) { return _this.showFeatureTooltip(a, l.group); },
                        mouseout: function (s) { return _this.hideFeatureTooltip(s); },
                        mousemove: function (d) { return _this.updateFeatureTooltip(d); },
                        click: function (e) {
                            _this.selectFeature(feature);
                        }
                    });
                    m.feature = feature;
                    if (l.group.clustering && l.group.cluster) {
                        l.group.cluster.addLayer(m);
                    }
                    else {
                        if (l.mapLayer) {
                            l.mapLayer.addLayer(m);
                        }
                    }
                    return m;
                }
                else
                    return null;
            };
            LeafletRenderer.prototype.canDrag = function (feature) {
                return feature.gui.hasOwnProperty('editMode') && feature.gui['editMode'] == true;
            };
            /**
             * add a feature
             */
            LeafletRenderer.prototype.createFeature = function (feature) {
                var _this = this;
                //this.service.initFeature(feature,layer);
                //var style = type.style;
                var marker;
                switch (feature.geometry.type) {
                    case 'Point':
                        var icon = this.getPointIcon(feature);
                        marker = new L.Marker(new L.LatLng(feature.geometry.coordinates[1], feature.geometry.coordinates[0]), {
                            icon: icon, draggable: this.canDrag(feature)
                        });
                        marker.on('contextmenu', function (e) {
                            _this.service._activeContextMenu = _this.service.getActions(feature, Services.ActionType.Context);
                            //e.stopPropagation();
                            var button = $("#map-contextmenu-button");
                            var menu = $("#map-contextmenu");
                            button.dropdown('toggle');
                            var mapSize = _this.map.getSize();
                            if (e.originalEvent.x < (mapSize.x / 2)) {
                                menu.css("left", e.originalEvent.x + 5);
                            }
                            else {
                                menu.css("left", e.originalEvent.x - 5 - menu.width());
                            }
                            if (e.originalEvent.y < (mapSize.y / 2)) {
                                menu.css("top", e.originalEvent.y - 35);
                            }
                            else {
                                menu.css("top", e.originalEvent.y - 70 - menu.height());
                            }
                            if (_this.service.$rootScope.$$phase != '$apply' && _this.service.$rootScope.$$phase != '$digest') {
                                _this.service.$rootScope.$apply();
                            }
                        });
                        marker.on('dragstart', function (event) {
                            feature.gui["dragged"] = true;
                        });
                        marker.on('dragend', function (event) {
                            var marker = event.target;
                            var position = marker.getLatLng();
                            feature.geometry.coordinates = [position.lng, position.lat];
                            //marker.setLatLng(new L.LatLng(), { draggable: 'false' });
                            //map.panTo(new L.LatLng(position.lat, position.lng))
                        });
                        break;
                    default:
                        marker = L.GeoJSON.geometryToLayer(feature);
                        marker.setStyle(this.getLeafletStyle(feature.effectiveStyle));
                        marker.on('contextmenu', function (e) {
                            _this.service._activeContextMenu = _this.service.getActions(feature, Services.ActionType.Context);
                            //e.stopPropagation();
                            var button = $("#map-contextmenu-button");
                            var menu = $("#map-contextmenu");
                            button.dropdown('toggle');
                            var mapSize = _this.map.getSize();
                            if (e.originalEvent.x < (mapSize.x / 2)) {
                                menu.css("left", e.originalEvent.x + 5);
                            }
                            else {
                                menu.css("left", e.originalEvent.x - 5 - menu.width());
                            }
                            if (e.originalEvent.y < (mapSize.y / 2)) {
                                menu.css("top", e.originalEvent.y - 35);
                            }
                            else {
                                menu.css("top", e.originalEvent.y - 70 - menu.height());
                            }
                            if (_this.service.$rootScope.$$phase != '$apply' && _this.service.$rootScope.$$phase != '$digest') {
                                _this.service.$rootScope.$apply();
                            }
                        });
                        //marker = L.multiPolygon(latlng, polyoptions);
                        break;
                }
                marker.feature = feature;
                feature.layer.group.markers[feature.id] = marker;
                return marker;
            };
            /**
             * create icon based of feature style
             */
            LeafletRenderer.prototype.getPointIcon = function (feature) {
                var icon;
                if (feature.htmlStyle != null) {
                    icon = new L.DivIcon({
                        className: '',
                        iconSize: new L.Point(feature.effectiveStyle.iconWidth, feature.effectiveStyle.iconHeight),
                        html: feature.htmlStyle
                    });
                }
                else {
                    var iconHtml = csComp.Helpers.createIconHtml(feature, this.service.getFeatureType(feature));
                    icon = new L.DivIcon({
                        className: '',
                        iconSize: new L.Point(iconHtml['iconPlusBorderWidth'], iconHtml['iconPlusBorderHeight']),
                        html: iconHtml['html']
                    });
                }
                return icon;
            };
            /***
             * Show tooltip with name, styles & filters.
             */
            LeafletRenderer.prototype.showFeatureTooltip = function (e, group) {
                var _this = this;
                var layer = e.target;
                var feature = layer.feature;
                // add title
                var title = layer.feature.properties.Name;
                var rowLength = (title) ? title.length : 1;
                var content = '<td colspan=\'3\'>' + title + '</td></tr>';
                // add filter values
                if (group.filters != null && group.filters.length > 0) {
                    group.filters.forEach(function (f) {
                        if (!feature.properties.hasOwnProperty(f.property))
                            return;
                        var value = feature.properties[f.property];
                        if (value) {
                            var valueLength = value.toString().length;
                            if (f.meta != null) {
                                value = csComp.Helpers.convertPropertyInfo(f.meta, value);
                                if (f.meta.type !== 'bbcode')
                                    valueLength = value.toString().length;
                            }
                            rowLength = Math.max(rowLength, valueLength + f.title.length);
                            content += '<tr><td><div class=\'smallFilterIcon\'></td><td>' + f.title + '</td><td>' + value + '</td></tr>';
                        }
                    });
                }
                // add style values, only in case they haven't been added already as filter
                if (group.styles != null && group.styles.length > 0) {
                    group.styles.forEach(function (s) {
                        if (group.filters != null && group.filters.filter(function (f) { return f.property === s.property; }).length === 0 && feature.properties.hasOwnProperty(s.property)) {
                            var value = feature.properties[s.property];
                            var valueLength = value.toString().length;
                            if (s.meta != null) {
                                value = csComp.Helpers.convertPropertyInfo(s.meta, value);
                                if (s.meta.type !== 'bbcode')
                                    valueLength = value.toString().length;
                            }
                            var tl = s.title ? s.title.length : 10;
                            rowLength = Math.max(rowLength, valueLength + tl);
                            content += '<tr><td><div class=\'smallStyleIcon\'></td><td>' + s.title + '</td><td>' + value + '</td></tr>';
                        }
                    });
                }
                var widthInPixels = Math.max(Math.min(rowLength * 7 + 15, 250), 130);
                content = '<table style=\'width:' + widthInPixels + 'px;\'>' + content + '</table>';
                this.popup = L.popup({
                    offset: new L.Point(-widthInPixels / 2 - 40, -5),
                    closeOnClick: true,
                    autoPan: false,
                    className: 'featureTooltip'
                }).setLatLng(e.latlng).setContent(content).openOn(this.service.map.map);
                //In case a contour is available, show it.
                var hoverActions = this.service.getActions(feature, Services.ActionType.Hover);
                hoverActions.forEach(function (ha) {
                    if (ha.title.toLowerCase() === 'show') {
                        ha.callback(feature, _this.service);
                    }
                });
            };
            LeafletRenderer.prototype.hideFeatureTooltip = function (e) {
                var _this = this;
                if (this.popup && this.service.map.map) {
                    this.service.map.map.closePopup(this.popup);
                    //this.map.map.closePopup(this.popup);
                    this.popup = null;
                }
                //In case a contour is being shown, hide it.
                var layer = e.target;
                var feature = layer.feature;
                if (feature) {
                    var hoverActions = this.service.getActions(feature, Services.ActionType.Hover);
                    hoverActions.forEach(function (ha) {
                        if (ha.title.toLowerCase() === 'hide') {
                            ha.callback(feature, _this.service);
                        }
                    });
                }
            };
            LeafletRenderer.prototype.updateFeatureTooltip = function (e) {
                if (this.popup != null && e.latlng != null)
                    this.popup.setLatLng(e.latlng);
            };
            return LeafletRenderer;
        })();
        Services.LeafletRenderer = LeafletRenderer;
    })(Services = csComp.Services || (csComp.Services = {}));
})(csComp || (csComp = {}));
